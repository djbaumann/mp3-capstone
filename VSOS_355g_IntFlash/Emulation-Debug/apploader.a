
//_____________________________________________________________
//
	.sect code,NextResource	// 91 words
	.export _NextResource
_NextResource:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	mv I2,A1	// I2 -> 'f'
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6)+1 ; sty I0,(I6)
// 	if (!f)
	sub A1,NULL,A1	// 'f' == (0) -> (0)
	ldc res_1,A0
	jzs F0B3	// signed compare
	nop
// jumped away
F0B4:
	ldc _resource,I0	// ET2
	ldx (I0)+1,B0 ; ldy (I6)-1,NULL
// 	if (resource.pos)
	ldx (I0)-1,B1
	ldc 0,B2	// update guard bits (cmp)
	sub B,NULL,B	// ET3 == (0) -> (0)
	ldc 3,A0	// 3 -> 1 -> ETb
	jzs F0B7	// unsigned compare
	ldc _resource+4,I0	// ET8
// jumped away
// 	}
// {
// 		f->pos = resource.pos + 8 + resource.header.length;
	ldc 0,C1	// 0 -> C1
	ldc 8,C0	// 8 -> 3 -> C0
	add B,C,C ; ldx (I0)+1,B0	// ET3 + ET4 -> ET5
	ldx (I0)-1,B1 ; add A1,A0,A0
	add C,B,B ; mv A0,I0	// ET5 + ET9 -> ETa
	stx B0,(I0)+1 ; sub NULL,ONES,C0	// AT23 -> ETc
	stx B1,(I0)-1 ; and NULL,NULL,C1
// 		if (f->pos & 1)
	ldx (I0)+1,B0
	ldx (I0)-1,B1
	and B,C,C	// ETd and ETe -> ETf
	ldc 0,C2	// update guard bits (cmp)
	sub C,NULL,C	// ETf == (0) -> (0)
	nop
	jzs F0B7	// unsigned compare
	sub B,ONES,B	// ETd - (-1) -> ET11
// jumped away
// f->pos++;
	stx B0,(I0)+1
	stx B1,(I0)-1
F0B7:
	ldc 3,A0	// 3 -> 1 -> ETb
	add A1,A0,A0 ; ldy (I6)+1,NULL	// I6 += 1
	mv A0,I0	// AT24 -> ETc
// 	resource.pos = f->pos;
	ldc 4,A0	// 4 -> 1 -> ET13
	ldx (I0)+1,B0
	ldx (I0)-1,B1
	ldc _resource,I0	// ET2
	stx B0,(I0)+1
	stx B1,(I0)-1
// 	}

// (p, 1, sizeof(resource.header), f);
	ldc _resource+2,I0	// AT28
	stx A1,(I6)+1	// 'f'
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET13
	stx A0,(I6)+1	// ET14
	call _vo_fread
	stx I0,(I6)	// AT28
// jumped away
	ldc 2561,A0	// 2561 -> 1 -> ET17
	ldc _resource+2,I2	// ET7
	ldx (I2),A1 ; ldy (I6)-4,NULL	// I6 += -4
// 		if (resource.header.resourceType != 0x0a01)
	sub A1,A0,A1	// ET16 == ET17 -> AT21
	nop
	jzs F0B12	// unsigned compare
	nop
// jumped away
// 		}
// {
// 			ovlChecksum += *p++;
	ldc _ovlChecksum,I2	// ET1c
	ldx (I0)+1,A1	// AT28 ==> ET1b
	ldx (I2),A0/*V*/	// ET1c ==> 'ovlChecksum'
	add A0,A1,A0	// 'ovlChecksum' + ET1b -> ET1d
	stx A0,(I2)/*V*/	// ET1d ==> ET1c
// 			ovlChecksum += *p++;
	ldx (I0)+1,A0	// AT28 ==> ET1b
	ldx (I2),A1/*V*/	// ET1c ==> 'ovlChecksum'
	add A1,A0,A0	// 'ovlChecksum' + ET1b -> ET1d
	stx A0,(I2)/*V*/	// ET1d ==> ET1c
// 			ovlChecksum += *p++;
	ldx (I0)+1,A1	// AT28 ==> ET1b
	ldx (I2),A0/*V*/	// ET1c ==> 'ovlChecksum'
	add A0,A1,A0	// 'ovlChecksum' + ET1b -> ET1d
	stx A0,(I2)/*V*/	// ET1d ==> ET1c
// 			ovlChecksum += *p++;
	ldx (I0),A0	// AT28 ==> ET1b
	ldx (I2),A1/*V*/	// ET1c ==> 'ovlChecksum'
	add A1,A0,A0	// 'ovlChecksum' + ET1b -> ET1d
	stx A0,(I2)/*V*/	// ET1d ==> ET1c
F0B12:
// 	return resource.header.resourceType;
	ldc _resource+2,I0	// ET7
	ldx (I0),A0 ; ldy (I6),I0	// ET7 ==> 2 -> ET16
	ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc res_1,A0	// ET0
	ldx (I6)+1,NULL	// I6 += 1
F0B3:
// 	}
// {
// 		SysError("0Res");
	stx A0,(I6)	// ET0
	call _SysError
	ldc F0B4,LR0
// jumped away

//_____________________________________________________________
//
	.sect code,ResGet16	// 21 words
	.export _ResGet16
_ResGet16:
	ldx (I6)+1,NULL ; sub NULL,ONES,A0	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6)+1 ; sty I0,(I6)
	stx I2,(I6)+1 ; ldy (I4)+1,NULL	// I4 += 1
// (&res, 1, 1, f);
	stx A0,(I6)+1	// ET0
	stx A0,(I6)+1	// ET0
	call _vo_fread
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET1
// jumped away
	ldc _ovlChecksum,I0	// ET3
	ldx (I0),A1/*V*/ ; ldy (I4)+1,NULL	// I4 += 1
// 	ovlChecksum += res;
	ldx (I4)-1,A0 ; ldy (I6)-4,NULL	// I4 ==> 'res'
	add A1,A0,A1	// 'ovlChecksum' + 'res' -> ET4
	stx A1,(I0)/*V*/ ; ldy (I6),I0	// ET4 ==> ET3
// 	return res;
	ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,ResGet32	// 28 words
	.export _ResGet32
_ResGet32:
	ldc 2,A0	// 2 -> 1 -> ET0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx I0,(I6)+1 ; ldy (I4)+1,NULL
// (&res, 1, 2, f);
	stx I2,(I6)+1	// 'f'
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET0
	stx A0,(I6)+1	// ET1
	call _vo_fread
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET2
// jumped away
	ldc _ovlChecksum,I0	// ET9
	ldy (I4)+1,NULL ; ldx (I0),A0/*V*/	// I4 += 1
// 	ovlChecksum += (res >> 16);
	ldx (I4)+1,C0 ; ldy (I6)-4,NULL
	ldx (I4)-2,C1
	add A0,C1,A0	// 'ovlChecksum' + ET8 -> ETa
	stx A0,(I0)/*V*/ ; add A0,C0,A0	// ETa ==> ET9
// 	ovlChecksum += (res);
	stx A0,(I0)/*V*/ ; add C,NULL,A	// ETc ==> ET9
// 	return res;
	ldx (I6)-1,I0	// 'res' returns via A
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,RemoveLibFromList	// 56 words
	.export _RemoveLibFromList
_RemoveLibFromList:
	ldx (I6)+2,NULL	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	ldc _loadedLib,B0	// ET2
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; and NULL,NULL,C1	// 0 -> ETc
	ldc 16,D0	// 16 -> 1 -> ET1
	sty D1,(I6)+1 ; ldx (I4)-2,NULL
	stx I0,(I6) ; sty I2,(I6)+1
	ldc _loadedLib+15,I0	// ETe
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6) ; and NULL,NULL,A0
// (i=0; i< 16; i++)
	ldx (I4)+2,A1	// 0 -> 'i'
F3B6:	// (loop lvl 2)
	sub A0,D0,B1	// 'i' >= ET1 -> AT19
	nop
	jcs F3B4	// unsigned compare
	add B0,A0,B1	// ET2 + 'i' -> AT1a
// jumped away
	mv B1,I2	// AT1a -> ET3
// 	}
// {
// 		if (loadedLib[i] == lib)
	ldx (I2),B1	// ET3 ==> ET4
	sub B1,A1,B1	// ET4 != 'lib' -> AT18
	nop	// 'i' -> 'j'
	jzc F3B8	// signed compare
	nop
// jumped away
// 		}
// (j=i; j< 16 -1; j++)
	ldc 15,C0	// 15 -> AT15
	sub A0,C0,C0 ; mv A0,B1	// 'j' <= AT15 -> AT16
	nop
	jcs F3B10	// unsigned compare
	nop
// jumped away
	sub ONES,C0,C0	// (-1) - AT16 -> AT16
	loop C0,F3B10-1
	nop
//loop resumes
// 			}
// {
// 				loadedLib[j] = loadedLib[j+1];
	sub B1,ONES,C0	// 'j' - (-1) -> ET7
	add B0,C0,D1	// ET2 + ET7 -> AT1c
	mv D1,I2 ; add B0,B1,B1	// AT1c -> ET8
	ldx (I2),D1	// ET8 ==> ET9
	mv B1,I2 ; add C0,NULL,B1	// AT1b -> ETa
	stx D1,(I2)	// ET9 ==> ETa
//	(0 nop's needed)
// loop end
F3B10:	// loop exit
// 			loadedLib[16 -1] = 0;
	stx C1,(I0)	// ETc ==> ETe
F3B8:	// (loop lvl 2)
	j F3B6
	sub A0,ONES,A0	// 'i' - (-1) -> 'i'
// jumped away
F3B4:
// 	loadedLibs--;
	ldc _loadedLibs,I0	// ET11
	ldx (I0),A0/*V*/	// ET11 ==> 'loadedLibs'
	add A0,ONES,A0	// 'loadedLibs' + (-1) -> ET14
	stx A0,(I0)/*V*/	// ET14 ==> ET11
	ldx (I6)-1,LE
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,CallToDroppedLibrary	// 27 words
	.export _CallToDroppedLibrary
_CallToDroppedLibrary:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
// zerocall
// ();
	call _Disable
	stx A0,(I6) ; sty I0,(I6)
// jumped away
	ldc 64518,I0	// 64518 -> ET1
	ldx (I6)+1,NULL ; ldy (I0)+1,A0/*V*/	// I6 += 1
//  vo_fprintf(vo_stderr,"\nCall to dropped lib! Interrupt level (encount): %d, last int vector: %d\n",(*(__y volatile u_int16 *)(u_int16)(0xFC07))-1,(*(__y volatile u_int16 *)(u_int16)(0xFC06)));
	stx A0,(I6)+1 ; ldy (I0),A0/*V*/	// ET2
	ldc _vo_stderr,I0	// ET9
	add A0,ONES,A0	// ET4 + (-1) -> ET7
	stx A0,(I6)+1	// ET7
	ldc calltod_2,A0	// ET8
	stx A0,(I6)+1	// ET8
	ldx (I0),A0/*V*/	// ET9 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-4,NULL ; and NULL,NULL,A0	// I6 += -4
	mv A0,LR0
// 	zerocall();
	jr
	ldc lo(F4B5),LR0	// (return address)
// jumped away
F4B5:
	ldy (I6),I0 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DisableIntVector	// 29 words
	.export _DisableIntVector
_DisableIntVector:
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 32,A1	// 32 -> 1 -> ET0
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; sub C0,A1,A0
//   if ((addr-=0x20U) < 0x20U)
	sub A0,A1,A1 ; mv A0,B0	// 'addr' >= ET0 -> AT13
	ldc -4,A1	// -4 -> 0 -> ET4
	jcs F5B1	// unsigned compare
	ldc 0,B1
// jumped away
//   }
// intBase
	ashl B,A1,B	// AT14 <- ET4 -> AT15
	ldc 64512,A1	// 64512 -> 1 -> ET2
	add A1,B0,A1	// ET2 + ET5 -> 'intBase'
// intMask
	ldc 15,B0	// 15 -> 1 -> ET8
	and A0,B0,A0 ; mv A1,I0	// 'addr' and ET8 -> ET9
	sub NULL,ONES,B0	// 1 -> 1 -> ET7
	ashl B0,A0,A0 ; ldy (I0),B0/*V*/	// ET7 << ET9 -> ETa
	xor A0,ONES,A0	// ETa xor (-1) -> 'intMask'
// *(__y volatile u_int16 *)(u_int16)(intBase)) &= intMask;
	and B0,A0,B0	// ETd and 'intMask' -> ETe
	sty B0,(I0)/*V*/	// ETe ==> ETc
//     intBase += 0xFC02 - 0xFC00;
	ldc 2,B0	// 2 -> 1 -> ETf
	add A1,B0,A1	// 'intBase' + ETf -> 'intBase'
	mv A1,I0	// 'intBase' -> ETc
// (*(__y volatile u_int16 *)(u_int16)(intBase)) &= intMask;
	ldy (I0),A1/*V*/	// ETc ==> ET11
	and A1,A0,A0	// ET11 and 'intMask' -> ET12
	sty A0,(I0)/*V*/	// ET12 ==> ETc
F5B1:
	ldx (I6)-1,I0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DropLibrary	// 149 words
	.export _DropLibrary
_DropLibrary:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+5,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I0,(I6) ; sty I2,(I6)+1
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6) ; ldy (I4)-2,NULL

// (!lib)
	ldx (I4)+2,D0	// unspill 'lib' from #-2
	mv D0,I2 ; sub D0,NULL,D0	// 'lib' -> ET6
	nop
	jzs F6B1	// signed compare
	nop
// jumped away
// 	if (--lib[1])
	sub D0,ONES,A0	// 'lib' - (-1) -> AT45
	mv A0,I0	// AT45 -> ET1
	ldx (I0),A0	// ET1 ==> 1 -> ET2
	add A0,ONES,A0	// ET2 + (-1) -> ET4
	stx A0,(I0) ; sub A0,NULL,A0	// ET4 ==> ET1
	nop
	jzs F6B6	// unsigned compare
	nop
// jumped away
F6B1:
	ldx (I6)-1,LE
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F6B6:
	ldx (I6)+1,NULL	// I6 += 1
// 	RemoveLibFromList(lib);
	call _RemoveLibFromList
	stx D0,(I6)	// 'lib'
// jumped away
	ldx (I2)+3,B0 ; ldy (I4)+1,NULL	// I4 += 1
// 	entries = *p++;
// 	p++;
// p++;
// 	fini = *p++;
	ldx (I2)+1,A1 ; ldy (I6)-1,NULL	// ET6 ==> 'fini'
// 	entrylist = p;
// 	p += entries;
	mv I2,A0 ; mv A1,LR0	// ET6 -> 'p'
	add A0,B0,A0	// 'p' + 'entries' -> ET8
	mv A0,I2	// ET8 -> AT4b
// 	libfileptr = *(u_int32*)p;
// 	p+= 2;
// 	nSections = *p++;
	ldx (I2)+2,NULL	// AT4b += 2
	ldx (I2)+1,A0	// AT4b ==> 'nSections'
	stx A0,(I4)-1	// 'nSections' spills to #0
// 	}
// finalize
// ();
	jr
	ldc lo(F6B8),LR0	// (return address)
// jumped away
F6B8:
// 	for (;nSections;nSections--)
	ldc 6,A0	// 6 -> 0 -> ET1d
	ldc _CallToDroppedLibrary,B0	// ET31
	ldc 0,B1	// I4 += 3
	sub NULL,ONES,C0 ; ldx (I4)+3,NULL	// 1 -> 1 -> ET2c
	mv B1,B0 ; ashl B,A0,A
	ldc 10752,B1	// 10752 -> B1
	add B,A,B	// ET30 + ET34 -> ET35
	stx B0,(I4) ; sty B1,(I4)-3	// B0 spills to #0
F6B12:	// (loop lvl 2)
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	ldx (I4)-1,A0	// unspill 'nSections' from #0
	sub A0,NULL,A0	// 'nSections' == (0) -> (0)
	nop	// I6 += 1
	jzs F6B10	// unsigned compare
	nop
// jumped away
	ldc 3,A0	// 3 -> ET10
	ldx (I2),A1 ; ldy (I6)-1,NULL
// 	}
// page
	and A1,A0,B1 ; ldx (I2)+1,A0	// ETf and ET10 -> 'page'
// size
	lsr A0,A0 ; ldx (I2)+1,B0	// ET7 << (-1) -> AT13
	lsr A0,A0	// AT13 << (-1) -> ET14
	add A0,A0,C1	// ET14 >> (-1) -> 'size'
// addr
// (page)
	sub B1,NULL,B1	// 'page' != (0) -> (0)
	nop
	jzc F6B15	// unsigned compare
	nop
// jumped away
// 			if ((u_int16)addr >= 256)
	ldc 256,A0	// 256 -> ET19
	sub B0,A0,B1	// 'addr' < ET19 -> AT42
	nop
	jcc F6B13	// unsigned compare
	nop
// jumped away
// 			}
// (i=0; i<0x20; i++)
	ldc 31,LC	// loop 32 iterations
	loop LC,F6B19-1
	ldc 0,B1	// 0 -> 'i'
//loop resumes
// 				}
// {
// 					if ((((ReadFromProgramRam(i+0x20)>>6L) & 0xffff) - (u_int16)addr) < size)
	ldc 32,A0	// 32 -> 1 -> ET1a
	add B1,A0,C0 ; ldx (I4)+2,NULL	// 'i' + ET1a -> ET1b
	call _ReadFromProgramRam
	mv C0,I0	// ET1b -> I0
// jumped away
	stx D0,(I4) ; sty D1,(I4) ; add A,NULL,D	// D0 spills to #0
	ldc 0,D2	// clear guard bits
	ldc -6,A0	// -6 -> 0 -> ET1e
	mv B0,D0 ; ashl D,A0,A	// 'addr' msw ET22
	ldc 0,A1
	mv A1,D1
	mv C1,D0 ; sub A,D,A	// 'size' msw ET24
	sub A,D,A	// ET23 >= ET24 -> AT44
	ldc _defaultIntVector,A0	// ET25
	jcs F6B56	// unsigned compare
	nop	// I4 += 2
// jumped away
	add B1,B1,A1 ; ldx (I4),D0	// I4 += 2
	ldy (I4)-2,D1 ; add A0,A1,A0	// unspill D0 from #0
	mv A0,I0	// AT46 -> ET28
// 					}
// {
// 						WriteToProgramRam(i+0x20,defaultIntVector[i]);
	ldy (I0)+1,A0
	ldy (I0)-1,A1
	call _WriteToProgramRam
	mv C0,I0	// ET1b -> I0
// jumped away
// 						DisableIntVector(i+0x20);
	call _DisableIntVector
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
F6B23:	// (loop lvl 3)
	sub B1,ONES,B1	// 'i' - (-1) -> 'i'
	sub NULL,ONES,C0	// 1 -> 1 -> ET2c
//	(0 nop's needed)
// loop end
F6B19:	// loop exit
// 				for(a=(u_int16)addr; a<(u_int16)addr+size-1; a++)
	add B0,C1,A0 ; mv B0,B1	// 'addr' + 'size' -> ET2e
	add A0,ONES,D1	// ET2e + (-1) -> ET2f
	sub B0,D1,A0	// 'a' <= ET2f -> AT3b
	nop
	jcs F6B28	// unsigned compare
	nop
// jumped away
	sub ONES,A0,A0	// (-1) - AT3b -> AT3b
	loop A0,F6B28-1
	nop
//loop resumes
	mv B1,I0	// 'a' -> ET36
	ldx (I4)+3,NULL	// I4 += 3
// 				}
// {
// 					WriteIMem((void*)a, 0x2a000000+((u_int32)((u_int16)CallToDroppedLibrary) << 6));
	call _WriteIMem
	ldx (I4),A0 ; ldy (I4)-3,A1	// unspill A0 from #0
// jumped away
	sub B1,ONES,B1	// 'a' - (-1) -> 'a'
//	(0 nop's needed)
// loop end
F6B28:	// loop exit
	ldx (I6)+1,NULL	// I6 += 1
// 				__FreeMemI(addr,size);
	stx C1,(I6)+1	// 'size'
	call ___FreeMemI
	stx B0,(I6)	// 'addr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F6B13:	// (loop lvl 2)
	ldx (I4)+1,NULL	// I4 += 1
	ldx (I4),A0	// unspill 'nSections' from #0
	add A0,ONES,A0	// 'nSections' + (-1) -> 'nSections'
	j F6B12
	stx A0,(I4)-1	// 'nSections' spills to #0
// jumped away
F6B56:	// (loop lvl 3)
	j F6B23
	ldx (I4),D0 ; ldy (I4)-2,D1	// unspill D0 from #0
// jumped away
F6B15:	// (loop lvl 2)
	sub B1,C0,B1 ; ldx (I6)+1,NULL	// 'page' == ET2c -> AT43
	stx C1,(I6)+1	// 'size'
	jzs F6B33	// unsigned compare
	nop	// I6 += 1
// jumped away
// 			FreeMemY((__y void*)addr, size);
	call _FreeMemY
	stx B0,(I6)	// ET38
// jumped away
// 			break;
	j F6B13
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
F6B33:	// (loop lvl 2)
// 			FreeMemX(addr, size);
	call _FreeMemX
	stx B0,(I6)	// 'addr'
// jumped away
// 			break;
	j F6B13
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
F6B10:
// 	free(lib);
	call _free
	stx D0,(I6)	// 'lib'
// jumped away
	j F6B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away

//_____________________________________________________________
//
	.sect code,LoadLibraryP	// 82 words
	.export _LoadLibraryP
_LoadLibraryP:
	ldc 26,I7
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)*,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx I0,(I6) ; sty I2,(I6)
	ldc _kernelDebugLevel,I0	// ET0
// (kernelDebugLevel)
	ldx (I0),A0/*V*/ ; ldy (I4)-2,NULL	// ET0 ==> 'kernelDebugLevel'
	sub A0,NULL,A0 ; ldx (I4)+2,I0	// 'kernelDebugLevel' != (0) -> (0)
	ldc s_3,A0	// ET1
	jzc F7B3	// signed compare
	nop	// I4 += -2
// jumped away
F7B4:
// 	if (filename[1] != ':')
	ldc 58,A0	// 58 -> 0 -> ET7
	ldx (I0)+1,NULL ; ldy (I4)+1,NULL	// 'filename' += 1
	ldx (I0)-1,A1 ; ldy (I6)+1,NULL	// 'filename' ==> 1 -> ET6
	sub A1,A0,A1	// ET6 != ET7 -> AT1a
	ldc ssyssd_4,A0	// ET8
	jzc F7B6	// signed compare
	nop	// I4 += 1
// jumped away
	ldc rb_5,A0	// ETb
	stx A0,(I6)+1 ; ldy (I4)-1,NULL
// 	}
// else {
// 		f = vo_fopen(filename,"rb");
	call _vo_fopen
	stx I0,(I6)	// 'filename'
// jumped away
F7B8:
	ldx (I6)-1,NULL ; ldy (I4)-3,NULL	// I6 += -2
	sub A0,NULL,B0	// 'f' != (0) -> (0)
// 	if (!f)
	ldc snotfou_6,A0	// ETe
	jzc F7B13	// signed compare
	nop
// jumped away
	stx I0,(I6)+1 ; ldy (I4)+3,NULL
// 	}
// {
// 		SysError("%s not found",filename);
	call _SysError
	stx A0,(I6)	// ETe
// jumped away
	ldx (I6)-2,NULL ; and NULL,NULL,A0	// I6 += -2
// 		return 0;
F7B1:
	ldy (I6),I2 ; ldx (I6)-1,I0
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldx (I4)-3,NULL ; ldy (I6)+1,NULL	// I4 += -3
F7B13:
// 	lib = LoadLibraryFile(f,parameters);
	ldx (I4)+3,A0	// unspill 'parameters' from #0
	stx A0,(I6)+1	// 'parameters'
	call _LoadLibraryFile
	stx B0,(I6)	// 'f'
// jumped away
	ldx (I6)-2,NULL ; add A0,NULL,A1	// I6 += -2
//  vo_fclose(f);
	call _vo_fclose
	mv B0,I0	// A0 -> 'lib'
// jumped away
// 	if (!lib)
	sub A1,NULL,A1	// 'lib' != (0) -> (0)
	ldc 4096,A0	// 4096 -> 1 -> ET15
	jzc F7B18	// signed compare
	nop
// jumped away
	ldc lib_7,A0	// ET13
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// {
// 		SysError("lib");
	call _SysError
	stx A0,(I6)	// ET13
// jumped away
// 		return 0;
	j F7B1
	ldx (I6)-1,NULL ; and NULL,NULL,A0	// I6 += -1
// jumped away
F7B18:
// (*(__y volatile u_int16 *)(u_int16)(0xfecb)) |=(1<<12);
	ldc 65227,I0	// 65227 -> ET16
	ldy (I0),B0/*V*/	// ET16 ==> ET17
	or B0,A0,A0	// ET17 or ET15 -> ET18
// 	return lib;
	j F7B1
	sty A0,(I0)/*V*/ ; add A1,NULL,A0	// ET18 ==> ET16
// jumped away
F7B6:
// 	}
// {
// 		sprintf(s,"S:SYS/%s.DL3",filename);
	stx I0,(I6)+1	// 'filename'
	stx A0,(I6)+1	// ET8
	call _sprintf
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET9
// jumped away
	ldc rb_5,A0	// ETb
	ldy (I6)-2,NULL ; ldx (I4)+1,NULL	// I4 += 1
// 		f = vo_fopen(s,"rb");
	stx A0,(I6)+1	// ETb
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET9
	call _vo_fopen
	ldc F7B8,LR0
// jumped away
F7B3:
	ldc _vo_stderr,I2	// ET2
	ldy (I6)+1,NULL	// I4 += -2
// 	}
// {
//  vo_fprintf(vo_stderr,"%s... ",filename);
	stx I0,(I6)+1	// 'filename'
	stx A0,(I6)+1	// ET1
	ldx (I2),A0/*V*/	// ET2 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	j F7B4
	ldx (I6)-3,NULL	// I6 += -3
// jumped away

//_____________________________________________________________
//
	.sect code,LoadLibrary	// 14 words
	.export _LoadLibrary
_LoadLibrary:
	ldc String_8,A0	// ET0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	ldy (I4)-2,NULL ; stx A0,(I6)+1	// I4 += -2
// 	return LoadLibraryP(filename,"");
	ldx (I4)+2,A0	// unspill 'filename' from #0
	call _LoadLibraryP
	stx A0,(I6)	// 'filename'
// jumped away
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,RunLibraryFunction	// 49 words
	.export _RunLibraryFunction
_RunLibraryFunction:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx I0,(I6)+1 ; ldy (I4)-2,NULL

// lib
// (!lib)
	ldx (I4)+2,A0 ; or NULL,ONES,B0	// -1 -> 'r'
// 	}
// {
// 		lib = LoadLibrary(filename);
	call _LoadLibrary
	stx A0,(I6)	// 'filename'
// jumped away
	ldx (I6)-1,NULL ; sub A0,NULL,A1	// I6 += -1
// 	if (lib)
	mv A1,I0
	jzc F9B7	// signed compare
	ldc 2,A0
// jumped away
F9B8:
// 	return r;
	add B0,NULL,A0 ; ldx (I6)-1,I0	// 'r' returns via A0
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	mv A1,I0	// 'lib' -> AT15
	ldc 2,A0	// 2 -> 1 -> ETa
F9B7:
	ldy (I4)-3,NULL ; ldx (I0),B1	// I4 += -3
// 	}
// {
// 		if ((entry < lib[0]+2) && lib[entry+2])
	add B1,A0,C0 ; ldx (I4)+3,B1	// ET9 + ETa -> ETb
	sub B1,C0,C0	// 'entry' >= ETb -> AT12
	nop
	jcs F9B10	// unsigned compare
	nop
// jumped away
	add B1,A0,A0	// 'entry' + ETa -> ETc
	add A1,A0,A0	// 'lib' + ETc -> AT16
	mv A0,I0	// AT16 -> ETd
	ldx (I0),A0	// ETd ==> ETe
	sub A0,NULL,A0	// ETe == (0) -> (0)
	mv A0,LR0
	jzs F9B10	// unsigned compare
	nop
// jumped away
	ldx (I4)-4,NULL ; ldy (I6)+1,NULL	// I4 += -4
// 		}
// {
// 			r = ((int(*)(int))(lib[entry+2]))(i);
	ldx (I4)+4,B0	// unspill 'i' from #0
	stx B0,(I6)	// 'i'
	jr
	ldc lo(F9B12),LR0	// (return address)
// jumped away
F9B12:
	ldx (I6)-1,NULL ; add A0,NULL,B0	// I6 += -1
F9B10:
	ldx (I6)+1,NULL	// I6 += 1
// 		DropLibrary(lib);
	call _DropLibrary
	stx A1,(I6)	// 'lib'
// jumped away
	j F9B8
	ldx (I6)-1,NULL	// I6 += -1
// jumped away

//_____________________________________________________________
//
	.sect code,VOGetSymbolAddress	// 29 words
	.export _VOGetSymbolAddress
_VOGetSymbolAddress:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty I0,(I6)+1
	stx I2,(I6) ; ldy (I4)-2,NULL

	call _SymbolCalcCrc32String
	ldx (I4)+2,I2	// unspill 's' from #-2
// jumped away
	call _SymbolFindByCrc
	add A,NULL,C	// ET0 -> C
// jumped away
// (!h)
	sub A0,NULL,A0	// 'h' != (0) -> (0)
	ldc 3,A1
	jzc F10B6	// signed compare
	nop
// jumped away
// return 0;
	and NULL,NULL,A0	// 0 -> 1 -> ET2
F10B1:
	ldx (I6)-1,I2
	ldy (I6),I0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
//   return h->addr;
	ldc 3,A1	// 3 -> 1 -> ET3
F10B6:
	add A0,A1,A0	// 'h' + ET3 -> AT9
	mv A0,I0	// AT9 -> ET4
	j F10B1
	ldy (I0),A0	// ET4 ==> 3 -> ET5
// jumped away

//_____________________________________________________________
//
	.sect code,LoadLibraryFile	// 738 words
	.export _LoadLibraryFile
_LoadLibraryFile:
	ldc 23,I7
	ldx (I6)+1,NULL ; and NULL,NULL,A0	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)*,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	stx I3,(I6) ; sty LC,(I6)+1
	ldc _mutex9dfea0,I3	// I3
	stx LS,(I6)+1 ; sty LE,(I6)
	ldx (I4)+2,NULL ; and NULL,NULL,D1	// I4 += 2
// lib
// secn
// init
// fatalErrors
// wrongRom
// (&mutex);
	sty A0,(I4)-1	// 'wrongRom' spills to #0
	sty A0,(I4)+1	// 'fatalErrors' spills to #0
	stx A0,(I4)+1	// 'init' spills to #0
	call _ObtainMutex
	stx A0,(I4)-3	// 0 -> 'secn'
// jumped away
// 	}
// (i=0; i<loadedLibs; i++)
	ldc _loadedLib,A0	// ET5
	ldc 0,A1	// 0 -> 'i'
	ldc 4,C1	// 4 -> 1 -> ET9
	j F11B7
	ldc _loadedLibs,I0	// ET4
// jumped away
F11B242:	// (loop lvl 2)
	sub A1,ONES,A1 ; ldx (I4),D0	// I4 += 4
	ldy (I4)-4,D1	// unspill D0 from #0
F11B7:	// (loop lvl 2)
	ldx (I0),B0/*V*/	// ET4 ==> 'loadedLibs'
	sub A1,B0,B0	// 'i' >= 'loadedLibs' -> ATef
	nop
	jcs F11B5	// unsigned compare
	nop
// jumped away
	ldx (I4)+4,NULL ; add A0,A1,B0	// I4 += 4
	mv B0,I2	// AT128 -> ET6
	stx D0,(I4) ; sty D1,(I4)-6	// D0 spills to #0
// 		}

	ldx (I2),I2	// ET6 ==> 'p'
// += *p + 4;
	ldx (I2),B0	// 'p' ==> ET8
	add B0,C1,B1 ; mv I2,B0	// ET8 + ET9 -> ETa
	add B0,B1,B0	// AT127 + ETa -> ETb
	mv B0,I2	// ETb -> 'p'
// 			lptr = *(u_int32*)p;
	ldx (I2)+1,D0
	ldx (I2)-1,D1
// 			if (lptr == ((FatFileInfo*)f->fileInfo)->startCluster)
	ldc 0,D2	// update guard bits (cmp)
	ldx (I4)+6,I2	// unspill 'f' from #0
	ldx (I2)+7,NULL	// ETe += 15
	ldx (I2)+7,NULL	// ...
	ldx (I2)+7,NULL	// ...
	ldx (I2)+1,B0
	ldx (I2)-1,B1
	ldc 0,B2	// update guard bits (cmp)
	sub D,B,B	// 'lptr' != ET12 -> ATee
	nop	// I4 += 4
	jzc F11B242	// unsigned compare
	nop
// jumped away
	ldc _kernelDebugLevel,I0	// ET13
	ldx (I4),D0 ; ldy (I4)-4,D1	// unspill D0 from #0
// 			}
// {
// 				if (kernelDebugLevel)
	ldx (I0),A0/*V*/	// ET13 ==> 'kernelDebugLevel'
	sub A0,NULL,A0	// 'kernelDebugLevel' == (0) -> (0)
	ldc _loadedLib,A0
	jzs F11B11	// signed compare
	ldc _vo_stderr,I0	// ET15
// jumped away
	ldc alreadylo_9,A0	// ET14
	ldx (I6)+1,NULL	// I6 += 1
// 				}
// {
//  vo_fprintf(vo_stderr,"Already loaded(LIB%d).\n",i);
	stx A1,(I6)+1	// 'i'
	stx A0,(I6)+1	// ET14
	ldx (I0),A0/*V*/	// ET15 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc _loadedLib,A0	// ET5
	ldx (I6)-3,NULL	// I6 += -3
// 				p = loadedLib[i];
F11B11:
	add A0,A1,A0 ; ldy (I6)+1,NULL	// ET5 + 'i' -> AT129
	mv A0,I0	// AT129 -> ET6
	ldx (I0),I0	// ET6 ==> 'p'
// 				p[1]++;
	ldx (I0)+1,NULL	// 'p' += 1
	ldx (I0),A0	// 'p' ==> 1 -> ET19
	sub A0,ONES,A0	// ET19 - (-1) -> ET1c
	stx A0,(I0)-1	// ET1c ==> 'p'
// 				ReleaseMutex(&mutex);
	call _ReleaseMutex
	ldc _mutex9dfea0,I3	// I3
// jumped away
	mv I0,A0	// 'p' returns via A0
// 				return p;
F11B1:
	ldy (I6),LE ; ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F11B5:
// 	memset(&resource,0,sizeof(resource));
	ldc 6,A0	// 6 -> A0
	ldx (I4)-2,NULL ; and NULL,NULL,A1	// 0 -> A1
	call _memset
	ldc _resource,I0	// I0
// jumped away
// 	}
// t32
	ldc 17713,B1	// 17713 -> B1
	ldc 22084,B0	// 22084 -> 3 -> B0
	call _ResGet32
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
// (t32 != 0x45315644 && t32 != 0x45325644)
	ldc 0,A2	// update guard bits (cmp)
	ldc 0,B2	// update guard bits (cmp)
	sub A,B,B	// 't32' == ET22 -> ATf2
	nop	// update guard bits (cmp)
	jzs F11B24	// unsigned compare
	nop
// jumped away
	ldc 17714,B1	// 17714 -> B1
	ldc 0,B2	// update guard bits (cmp)
	ldc 22084,B0	// 22084 -> 3 -> B0
	sub A,B,B	// 't32' == ET23 -> ATf3
	ldc toooldap_10,A0	// ET24
	jzs F11B24	// unsigned compare
	nop
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// {
// 			SysError("Too old APP");
	call _SysError
	stx A0,(I6)	// ET24
// jumped away
// 			ReleaseMutex(&mutex);
	call _ReleaseMutex
	ldc _mutex9dfea0,I3	// I3
// jumped away
// 			return 0;
	j F11B1
	and NULL,NULL,A0	// 0 -> ET0
// jumped away
F11B24:	// (loop lvl 2)
	ldx (I4)-2,NULL	// I4 += -2
	call _NextResource
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	sub A0,NULL,A0 ; ldx (I4)+3,NULL	// ET26 == (0) -> (0)
	ldc _resource,A0	// ET1f
	jzs F11B22	// unsigned compare
	nop	// I4 += 3
// jumped away
	ldx (I4)-5,NULL ; ldy (I6)+1,NULL
// 	}
// {
// 		if (ResourceLoadHook(&resource, f))
	ldx (I4)+2,I0	// unspill 'f' from #0
	stx I0,(I6)+1	// 'f'
	call _ResourceLoadHook
	stx A0,(I6)	// ET1f
// jumped away
	ldx (I6)-2,NULL ; sub A0,NULL,A0	// I6 += -2
	nop
	jzc F11B24	// signed compare
	nop
// jumped away
	ldc 65280,A1	// 65280 -> 1 -> ET2b
	ldx (I4)+2,NULL	// I4 += 2
// 		if (wrongRom)
	ldy (I4)-2,A0	// unspill 'wrongRom' from #0
	sub A0,NULL,A0	// 'wrongRom' != (0) -> (0)
	ldc _resource+2,I0	// ET29
	jzc F11B29	// signed compare
	ldx (I0),A0	// ET29 ==> 2 -> ET2a
// jumped away
// 		switch(resource.header.resourceType & 0xff00u)
	and A0,A1,A0	// ET2a and ET2b -> ET2c
	ldc 768,A1	// 768 -> 1 -> ET32
	sub A0,A1,A1	// ET2c == ET32 -> ATfa
	ldc 15,A1	// 15 -> 1 -> ETd
	jzs F11B40	// unsigned compare
	nop	// ET29
// jumped away
	ldc 1024,A1	// 1024 -> 1 -> ET53
	sub A0,A1,A1	// ET2c == ET53 -> ATfe
	ldc 1025,A1	// 1025 -> 1 -> ET54
	jzs F11B66	// unsigned compare
	sub A0,NULL,A0	// ET2c == (0) -> (0)
// jumped away
	ldc 10,A1	// 10 -> 1 -> ET2d
	jzs F11B113	// unsigned compare
	nop	// ET29
// jumped away
	ldc 2304,A1	// 2304 -> 1 -> ETaf
	sub A0,A1,A1	// ET2c != ETaf -> AT113
	ldc 2560,A1	// 2560 -> 1 -> ETd9
	jzc F11B127	// unsigned compare
	nop
// jumped away
// 			}

	ldc 6,A0	// 6 -> 3 -> A0
	ldc _resource+4,I0	// ET61
	ldx (I0)+1,B0 ; and NULL,NULL,A1
	call divide32unsigned
	ldx (I0)-1,B1
// jumped away
	add A0,NULL,C1 ; ldx (I6)+1,NULL	// I6 += 1

	ldc 17,A0	// 17 -> 1 -> ETb3
	add A0,C1,A1	// ETb3 + 'n' -> ETb4
	add D1,D1,A0	// 'secn' + 'secn' -> ETb5
	add A1,A0,A0	// ETb4 + ETb5 -> ETb6
	call _malloc
	stx A0,(I6)	// ETb6
// jumped away
	mv A0,I3	// 'lib' -> AT14a
	ldx (I4)+3,NULL ; ldy (I6)-1,NULL	// I4 += 3
	stx A0,(I4)-3 ; sub A0,NULL,A0	// 'lib' spills to #0
// (lib)
	nop
	jzs F11B24	// signed compare
	nop
// jumped away
// 				}
// {
// 					*p++ = n;
	stx C1,(I3)+1 ; sub NULL,ONES,A0	// 'n' ==> AT14a
// 					*p++ = 1;
	stx A0,(I3)+1 ; sub NULL,ONES,B0	// ET1b ==> AT14a
// 					*p++ = (u_int16)CommonOkResultFunction;
	ldc _CommonOkResultFunction,A0	// ETba
	stx A0,(I3)+1	// ETba ==> AT14a
// 					*p++ = (u_int16)CommonOkResultFunction;
	stx A0,(I3)+1 ; sub C1,B0,A0	// ETba ==> AT14a
// 					for (i=1; i<=n; i++)
	nop
	jlt F11B133	// signed compare
	nop	// AT14a += 1
// jumped away
	loop A0,F11B133-1
	nop
//loop resumes
	ldx (I4)-2,NULL	// I4 += -2
// 					}
// ident
	call _ResGet16
	ldx (I4),I2	// unspill 'f' from #0
// jumped away
// sect
	call _ResGet16
	ldx (I4),I2 ; add A0,NULL,A1	// A0 -> 'ident'
// jumped away
// value
	call _ResGet16
	ldx (I4)+2,I2 ; add A0,NULL,B1	// A0 -> 'sect'
// jumped away
	mv A0,C0	// A0 -> 'value'

	ldc _secbase9dfea0,A0	// ET3b
	add A0,B1,A0	// ET3b + 'sect' -> AT130
	mv A0,I0	// AT130 -> ETc0
	ldc 28001,B1	// 28001 -> 1 -> ETc3
	ldx (I0),A0	// ETc0 ==> ETc1
	add C0,A0,A0	// 'value' + ETc1 -> 'a'
// p++ = a;
	stx A0,(I3)+1 ; sub A1,B1,B1	// 'a' ==> AT14a
// 						if (ident == 0x6d61)
	ldc 26217,B1
	jzc F11B140	// unsigned compare
	nop	// AT14a += 1
// jumped away
	ldc 2,C0	// 2 -> 0 -> ETc4
	ldx (I4)+3,NULL	// I4 += 3
// 						}
// {
// 							lib[2]=a;
	ldx (I4)-3,B1	// unspill 'lib' from #0
	add B1,C0,B1	// 'lib' + ETc4 -> AT131
	mv B1,I0	// AT131 -> ETc5
	ldc 26217,B1	// 26217 -> 1 -> ETc6
	stx A0,(I0)	// 'a' ==> ETc5
// 						if (ident == 0x6669)
F11B140:	// (loop lvl 3)
	sub A1,B1,B1	// 'ident' != ETc6 -> AT11e
	ldc 26990,B1
	jzc F11B142	// unsigned compare
	nop
// jumped away
	ldc 3,C0	// 3 -> 0 -> ETc7
	ldx (I4)+3,NULL	// I4 += 3
// 						}
// {
// 							lib[3]=a;
	ldx (I4)-3,B1	// unspill 'lib' from #0
	add B1,C0,B1	// 'lib' + ETc7 -> AT132
	mv B1,I0	// AT132 -> ETc8
	ldc 26990,B1	// 26990 -> 1 -> ETc9
	stx A0,(I0)	// 'a' ==> ETc8
// 						if (ident == 0x696e)
F11B142:	// (loop lvl 3)
	sub A1,B1,B1 ; ldx (I4)+2,NULL	// 'ident' != ETc9 -> AT11f
	ldc 28786,B1
	jzc F11B144	// unsigned compare
	nop
// jumped away
// 						}
// {
// 							init = a;
	stx A0,(I4)	// A0 spills to #0
// 						if (ident == 0x7072)
F11B144:	// (loop lvl 3)
	sub A1,B1,A1 ; mv A0,I0	// 'ident' != ETcb -> AT120
	ldx (I4)-1,NULL	// 'a' -> ETca
	jzc F11B199	// unsigned compare
	ldx (I4),A0	// unspill 'preloadResult' from #0
// jumped away
// 						}
// {
// 							*((u_int16*)a)=preloadResult;
	stx A0,(I0)	// 'preloadResult' ==> ETca
F11B199:	// (loop lvl 3)
	ldx (I4)-1,NULL
//	(0 nop's needed)
// loop end
F11B133:	// loop exit
	ldx (I4)-2,NULL	// I4 += -2
// 					*(u_int32*)p = ((FatFileInfo*)f->fileInfo)->startCluster;
	ldx (I4)+2,I0	// unspill 'f' from #0
	ldx (I0)+7,NULL	// ET11 += 15
	ldx (I0)+7,NULL	// ...
	ldx (I0)+7,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	stx A0,(I3)+1 ; and NULL,NULL,A0
	stx A1,(I3)+1 ; sub D1,A0,A1
// 					p += 2;
// 					*p++ = secn;
	stx D1,(I3)+1	// 'secn' ==> AT14a
// 					for (i=0; i<secn; i++)
	jle F11B148	// signed compare
	add A1,ONES,A1	// ATeb + (-1) -> ATeb
// jumped away
	loop A1,F11B148-1
	nop
//loop resumes
// 					}
// {
// 						*p++ = secpage[i];
	ldc _secpage9dfea0,A1	// ET3f
	add A1,A0,A1	// ET3f + 'i' -> AT134
	mv A1,I0	// AT134 -> ETce
	ldy (I0),A1	// ETce ==> ETcf
	stx A1,(I3)+1	// ETcf ==> AT14a
// 						*p++ = secbase[i];
	ldc _secbase9dfea0,A1	// ET3b
	add A1,A0,A1	// ET3b + 'i' -> AT133
	mv A1,I0 ; sub A0,ONES,A0	// AT133 -> ETd0
	ldx (I0),A1	// ETd0 ==> ETd1
	stx A1,(I3)+1	// ETd1 ==> AT14a
//	(0 nop's needed)
// loop end
F11B148:	// loop exit
	ldc 0,A1	// 0 -> 1 -> ET1
	ldy (I6)+1,NULL ; stx A1,(I3)+1	// I4 += -2
// 					*p++=0;
	and NULL,NULL,A0 ; ldy (I4)-2,NULL	// ET1 ==> AT14a
// 					}
// 					{
// 						strncpy(p,f->Identify(f,0,0),8);
	stx A1,(I6)+1	// ET1
	stx A0,(I6)	// ET2
	ldx (I4),I2	// unspill 'f' from #0
	mv I2,I0	// 'f' -> I0
	ldx (I2)+1,NULL	// 'f' += 1
	ldx (I2)-1,A0	// 'f' ==> 1 -> ETd4
	mv A0,LR0
	stx I2,(I4)+2	// 'f' spills to #0
	jr
	ldc lo(F11B151),LR0	// (return address)
// jumped away
F11B151:	// (loop lvl 2)
	mv I3,I0	// AT14a -> I0
	mv A0,I2	// A0 -> ETd5
	mv I2,I1	// ETd5 -> I1
	ldx (I6)-2,NULL	// I6 += -2
	call _strncpy
	ldc 8,A0	// 8 -> A0
// jumped away
// 						p += 8;
// 						*p++ = 0;
	ldx (I3)+7,NULL	// AT14a += 8
	ldx (I3)+1,NULL	// ...
	j F11B24
	stx A1,(I3)	// ET1 ==> AT14a
// jumped away
F11B127:	// (loop lvl 2)
	sub A0,A1,A0	// ET2c == ETd9 -> AT11b
	nop
	jzc F11B24	// unsigned compare
	nop	// 2561 -> 1 -> ETda
// jumped away
// 			}
// {
// 				if (resource.header.resourceType == 0x0a01 && resource.header.subType != ovlChecksum)
	ldc _resource+2,I0	// ET29
	sub A1,ONES,A1 ; ldx (I0),A0
	sub A0,A1,A0	// ET2a != ETda -> AT121
	ldc _resource+3,I0	// ET4b
	jzc F11B156	// unsigned compare
	ldx (I0),A0	// ET4b ==> 3 -> ET4c
// jumped away
	ldc _ovlChecksum,I0	// ETdb
	ldx (I0),A1/*V*/	// ETdb ==> 'ovlChecksum'
	sub A0,A1,A0	// ET4c == 'ovlChecksum' -> AT122
	nop
	jzs F11B156	// unsigned compare
	nop
// jumped away
	ldx (I4)-2,NULL ; ldy (I6)+1,NULL	// I4 += -2
	and NULL,NULL,A0	// 0 -> 1 -> ET1
// 				}
// {
// 					SysError("Corrupt lib %s",f->Identify(f,0,0));
	stx A0,(I6)+1	// ET1
	stx A0,(I6)	// ET2
	ldx (I4),I2	// unspill 'f' from #0
	mv I2,I0	// 'f' -> I0
	ldx (I2)+1,NULL	// 'f' += 1
	ldx (I2)-1,A0	// 'f' ==> 1 -> ETd4
	mv A0,LR0
	stx I2,(I4)+2	// 'f' spills to #0
	jr
	ldc lo(F11B158),LR0	// (return address)
// jumped away
F11B158:	// (loop lvl 2)
	ldx (I6)-1,NULL	// I6 += 1
	stx A0,(I6)+1	// ETdc
	ldc corruptli_11,A0	// ETdd
	call _SysError
	stx A0,(I6)	// ETdd
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)-2,NULL	// I4 += 1
// 					fatalErrors++;
	ldy (I4),A0	// unspill 'fatalErrors' from #0
	sub A0,ONES,A0	// 'fatalErrors' - (-1) -> 'fatalErrors'
	sty A0,(I4)-1	// 'fatalErrors' spills to #0
F11B156:	// (loop lvl 2)
// 				ovlChecksum = 0;
	ldc _ovlChecksum,I0	// ETdb
	and NULL,NULL,A0	// 0 -> 1 -> ET1
// 				break;
	j F11B24
	stx A0,(I0)/*V*/	// ET1 ==> ETdb
// jumped away
F11B113:	// (loop lvl 2)
// 			}
// {
// 				if (resource.header.resourceType == 0x000a)
	ldx (I0),A0 ; ldy (I4)-2,NULL	// ET29 ==> 2 -> ET2a
	sub A0,A1,A0	// ET2a == ET2d -> AT112
	nop	// I4 += -2
	jzs F11B115	// unsigned compare
	nop
// jumped away
	ldx (I0),A0 ; ldy (I4)+2,NULL
	sub A1,ONES,A1
// else if (resource.header.resourceType == 0x000b)
	sub A0,A1,A0	// ET2a != ETa7 -> AT114
	ldc _secbase9dfea0,A0	// ET3b
	jzc F11B24	// unsigned compare
	nop
// jumped away
// 				}
// preload
	add D1,ONES,A1	// 'secn' + (-1) -> ETa8
	add A0,A1,A0	// ET3b + ETa8 -> AT12f
	mv A0,I0	// AT12f -> ETa9
	ldx (I0),A0	// ETa9 ==> 'preload'
	mv A0,LR0
// = preload();
	jr
	ldc lo(F11B125),LR0	// (return address)
// jumped away
F11B125:	// (loop lvl 2)
	ldx (I4)+1,NULL	// I4 += 1
	j F11B24
	stx A0,(I4)-1	// A0 spills to #0
// jumped away
F11B115:	// (loop lvl 2)
// 				}

	call _ResGet32
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	ldx (I4)+2,NULL ; add A,NULL,B	// I4 += 2
	ldc 0,B2	// update guard bits (cmp)
	ldc 0,A0	// 0 -> 'wrongRom'
// = (t && t != ReadFromProgramRam(0xFFFF));
	sty A0,(I4)-2 ; sub B,NULL,B	// 'wrongRom' spills to #0
	nop
	jzs F11B24	// unsigned compare
	nop
// jumped away
	call _ReadFromProgramRam
	ldc 65535,I0	// 65535 -> I0
// jumped away
	ldc 0,A2	// update guard bits (cmp)
	ldc 0,B2	// update guard bits (cmp)
	sub B,A,B	// 't' != ETa6 -> AT116
	nop
	jzs F11B24	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL ; sub NULL,ONES,A0	// I4 += 2
	j F11B24
	sty A0,(I4)-2	// 'wrongRom' spills to #0
// jumped away
F11B66:	// (loop lvl 2)
// 			}
// (resource.header.resourceType == 0x0401)
	ldx (I0),A0	// ET29 ==> 2 -> ET2a
	sub A0,A1,A0	// ET2a != ET54 -> AT105
	ldc 1026,A1
	jzc F11B69	// unsigned compare
	ldx (I0),A0
// jumped away
// 				}
// {
// 					rBase = secbase[resource.header.subType];
	ldc _secbase9dfea0,A1	// ET3b
	ldc _resource+3,I0	// ET4b
	ldx (I0),A0	// ET4b ==> 3 -> ET4c
	add A1,A0,A1	// ET3b + ET4c -> AT12d
	mv A1,I0	// AT12d -> ET55
	ldx (I0),A1	// ET55 ==> ET56
	ldc _rBaseab36a0,I0	// ET57
	sty A1,(I0)/*V*/	// ET56 ==> ET57
// 					rPage = secpage[resource.header.subType]&3;
	ldc _secpage9dfea0,A1	// ET3f
	add A1,A0,A0	// ET3f + ET4c -> AT12c
	mv A0,I0	// AT12c -> ET58
	ldc 3,A1	// 3 -> 1 -> ET5b
	ldy (I0),A0	// ET58 ==> ET59
	ldc _rPageab36a0,I0	// ET5d
	and A0,A1,A0	// ET59 and ET5b -> ET5c
	ldc 1026,A1	// 1026 -> 1 -> ET5e
	stx A0,(I0)/*V*/	// ET5c ==> ET5d
// 				if (resource.header.resourceType == 0x0402)
	ldc _resource+2,I0	// ET29
	ldx (I0),A0	// ET29 ==> 2 -> ET2a
F11B69:	// (loop lvl 2)
	sub A0,A1,A0	// ET2a != ET5e -> AT107
	nop
	jzc F11B71	// unsigned compare
	nop
// jumped away
	ldx (I4)+7,NULL ; and NULL,NULL,A1	// I4 += 7
	mv I4,I0	// 0 -> 'i'
// 				}

// (i=0; i<resource.header.length/2; i++)
	j F11B75
	ldx (I4)-7,NULL	// I4 += -7
// jumped away
F11B72:	// (loop lvl 3)
// *p++ = ResGet16(f);
	call _ResGet16
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	stx A0,(I0)+1 ; sub A1,ONES,A1	// ET66 ==> 'p'
F11B75:	// (loop lvl 3)
	ldc _resource+4,I2	// ET61
	ldx (I2)+1,B0 ; or NULL,ONES,A0	// -1 -> AT64
	ldx (I2)-1,B1 ; add A1,NULL,C0	// 'i' msw ET60
	and C1,NULL,C1 ; ldx (I4)-2,NULL
	ldc 0,C2	// update guard bits (cmp)
	ashl B,A0,B	// ET62 << AT64 -> ET65
	ldc 0,B2	// update guard bits (cmp)
	sub C,B,B	// ET60 < ET65 -> AT109
	nop	// I4 += -2
	jcc F11B72	// unsigned compare
	nop
// jumped away
	ldx (I4)+7,NULL ; ldy (I6)+1,NULL
	ldx (I4)+2,NULL	// I4 += 7
// 					extAddr = GetSymbolAddress(s);
	call _GetSymbolAddress
	stx I4,(I6) ; ldy (I4)-7,NULL	// ET5f
// jumped away
	ldc _extAddrab36a0,I0	// ET6c
	stx A0,(I0)/*V*/ ; ldy (I6)-1,NULL	// I6 += -1
	sub A0,NULL,A0	// ET6b != (0) -> (0)
// 					if (!extAddr)
	nop
	jzc F11B71	// unsigned compare
	nop
// jumped away
	ldx (I4)+7,NULL	// I4 += 7
	mv I4,I2	// I4 -> [] -> I2
// 					}
// crc32
	call _SymbolCalcCrc32String
	ldx (I4)-7,NULL	// I4 += -7
// jumped away
	ldc _eab36e8,I0	// ET70
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	ldy (I4),A0 ; add A,NULL,B	// A -> 'crc32'
// ++;
	sub A0,ONES,A0 ; stx B0,(I6)+1	// 'fatalErrors' - (-1) -> 'fatalErrors'
	sty A0,(I4)+6 ; stx B1,(I6)+1	// 'fatalErrors' spills to #0
// 						vo_fprintf(vo_stderr, e, s, crc32);
	stx I4,(I6)+1 ; ldy (I4)-7,NULL	// ET5f
	ldx (I0),A0/*V*/	// ET70 ==> 'e'
	ldc _vo_stderr,I0	// ET15
	stx A0,(I6)+1	// 'e'
	ldx (I0),A0/*V*/	// ET15 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
// 						Forbid();
	call _Forbid
	ldx (I6)-5,NULL	// I6 += -5
// jumped away
F11B71:	// (loop lvl 2)
// 				if (resource.header.resourceType == 0x0404)
	ldc 1028,A1	// 1028 -> 1 -> ET72
	ldc _resource+2,I0	// ET29
	ldx (I0),A0 ; ldy (I4)-2,NULL	// ET29 ==> 2 -> ET2a
	sub A0,A1,A0 ; ldx (I4)+2,I2	// ET2a == ET72 -> AT108
	nop	// unspill 'f' from #0
	jzs F11B83	// unsigned compare
	nop
// jumped away
F11B84:	// (loop lvl 2)
// 				if (resource.header.resourceType == 0x0403)
	ldc 1027,A1	// 1027 -> 1 -> ET8c
	ldc _resource+2,I0	// ET29
	ldx (I0),A0	// ET29 ==> 2 -> ET2a
	sub A0,A1,A0	// ET2a == ET8c -> AT10b
	ldc _secbase9dfea0,A0	// ET3b
	jzc F11B24	// unsigned compare
	nop
// jumped away
	ldc _resource+3,I0	// ET4b
	ldy (I4)-2,NULL ; ldx (I0),A1	// I4 += -2
// 				}
// ts
// tBase
	add A0,A1,A0 ; ldx (I4)+2,I2	// ET3b + 'ts' -> AT12e
	mv A0,I0	// AT12e -> ET8d

	ldx (I0),C1	// ET8d ==> 'tBase'
	call _ResGet16
	ldc F11B104,LR0
// jumped away
F11B101:	// (loop lvl 3)
	ldc _rBaseab36a0,I0	// ET57
	ldx (I4)-2,NULL ; ldy (I0),A1/*V*/	// I4 += -2
// 					}
// addr
	ldc _rPageab36a0,I0	// ET5d
	call _ResGet16
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	add A1,A0,C0 ; ldx (I0),A0/*V*/	// ET76 + ET92 -> 'addr'
// (rPage)
	sub A0,NULL,A0 ; ldx (I4)+4,NULL	// 'rPage' != (0) -> (0)
	nop	// I4 += 4
	jzc F11B108	// unsigned compare
	nop
// jumped away
// 							}
// text
	call _ReadFromProgramRam
	mv C0,I0	// 'addr' -> I0
// jumped away
	stx B0,(I4) ; sty B1,(I4)+1	// B0 spills to #0
	stx D0,(I4) ; sty D1,(I4)-1	// D0 spills to #0
	ldc 63,D0	// 63 -> 3 -> D0
	ldc 65472,D1	// 65472 -> D1
	mv C0,I0 ; add A,NULL,B	// A -> 'text'
// ro
	ldc 0,B2	// clear guard bits
	ldc -6,A0	// -6 -> 0 -> ET7b
	ashl B,A0,A	// 'text' <- ET7b -> ET95
// to
	ldc 0,A1
	add C1,A0,A0	// 'tBase' + 'ro' -> 'to'
// &= ~(0xffffL << 6);
	and B,D,D ; ldx (I4)+1,B0	// 'text' and ET80 -> 'text'
// 								text |= ((u_int32)to << 6);
	ldc 6,B1	// 6 -> 0 -> ET7a
	ashl A,B1,A	// ET9a << ET7a -> ET9b
	or D,A,A ; ldx (I4),D0	// 'text' or ET9b -> 'text'
// 								WriteToProgramRam(addr,text);
	call _WriteToProgramRam
	ldy (I4)-5,D1	// unspill D1 from #0
// jumped away
F11B229:	// (loop lvl 3)
	mv B0,A0	// AT13c -> AT14e
F11B104:	// (loop lvl 3)
	add A0,ONES,B0	// AT14e + (-1) -> AT13c
	sub A0,NULL,A0	// AT14e != (0) -> (0)
	nop
	jzc F11B101	// unsigned compare
	nop
// jumped away
	j F11B24
	nop
// jumped away
F11B108:	// (loop lvl 3)
	ldx (I0),A0/*V*/ ; sub NULL,ONES,A1	// ET5d ==> 'rPage'
	sub A0,A1,A0 ; mv C0,I0	// 'rPage' == ET1b -> AT111
	ldy (I0),A0 ; ldx (I4)-4,NULL	// ETa1 ==> ETa2
	jzs F11B111	// unsigned compare
	add A0,C1,A0	// ETa2 + 'tBase' -> ETa3
// jumped away
// *(__y u_int16*)addr += tBase;
// break;
	j F11B229
	sty A0,(I0)	// ETa3 ==> ETa1
// jumped away
F11B111:	// (loop lvl 3)
// *(u_int16*)addr += tBase;
	ldx (I0),A0	// ET9e ==> ET9f
	add A0,C1,A0	// ET9f + 'tBase' -> ETa0
// break;
	j F11B229
	stx A0,(I0)	// ETa0 ==> ET9e
// jumped away
F11B83:	// (loop lvl 2)
// 				}

	call _ResGet16
	ldc F11B89,LR0
// jumped away
F11B86:	// (loop lvl 3)
	ldx (I4)-2,NULL ; ldy (I0),A1/*V*/	// I4 += -2
// 					}
// addr
	ldc _rPageab36a0,I0	// ET5d
	call _ResGet16
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	add A1,A0,C0 ; ldx (I0),A0/*V*/	// ET76 + ET77 -> 'addr'
// (rPage)
	sub A0,NULL,A0	// 'rPage' != (0) -> (0)
	nop	// ET5d
	jzc F11B93	// unsigned compare
	nop
// jumped away
// 							}
// text
	call _ReadFromProgramRam
	mv C0,I0	// 'addr' -> I0
// jumped away
	ldc 6,D0	// 6 -> 0 -> ET7a
	ldc _extAddrab36a0,I0	// ET6c
	ldx (I4)+4,NULL	// I4 += 4
	stx C0,(I4) ; sty C1,(I4) ; add A,NULL,C	// C0 spills to #0
// ro
	ldc 0,C2	// clear guard bits
	ldc -6,A0	// -6 -> 0 -> ET7b
	ashl C,A0,B ; ldx (I0),A0/*V*/	// 'text' <- ET7b -> ET7c
// to
	ldc 65472,B1	// 65472 -> B1
	add A0,B0,A0	// 'extAddr' + 'ro' -> 'to'
// &= ~(0xffffL << 6);
	ldc 63,B0	// 63 -> 3 -> B0
	and C,B,B ; ldx (I4),C0	// 'text' and ET80 -> 'text'
// 								text |= ((u_int32)to << 6);
	ldy (I4)-4,C1 ; and A1,NULL,A1
	ashl A,D0,A ; mv C0,I0	// ET82 << ET7a -> ET83
// 								WriteToProgramRam(addr,text);
	call _WriteToProgramRam
	or B,A,A	// 'text' or ET83 -> 'text'
// jumped away
F11B227:	// (loop lvl 3)
	mv C1,A0	// AT13a -> AT14d
F11B89:	// (loop lvl 3)
	add A0,ONES,C1	// AT14d + (-1) -> AT13a
	sub A0,NULL,A0	// AT14d != (0) -> (0)
	ldc _rBaseab36a0,I0	// ET57
	jzc F11B86	// unsigned compare
	nop
// jumped away
	j F11B84
	nop
// jumped away
F11B93:	// (loop lvl 3)
	ldx (I0),A1/*V*/ ; sub NULL,ONES,A0	// ET5d ==> 'rPage'
	sub A1,A0,A0 ; mv C0,I0	// 'rPage' == ET1b -> AT10e
	ldc _extAddrab36a0,I2	// ET6c
	jzs F11B96	// unsigned compare
	nop	// ET6c
// jumped away
// *(__y u_int16*)addr += extAddr;
	ldy (I0),A1 ; ldx (I2),A0/*V*/	// ET89 ==> ET8a
	add A1,A0,A0	// ET8a + 'extAddr' -> ET8b
// break;
	j F11B227
	sty A0,(I0)	// ET8b ==> ET89
// jumped away
F11B96:	// (loop lvl 3)
// *(u_int16*)addr += extAddr;
	ldx (I0),A1	// ET86 ==> ET87
	ldx (I2),A0/*V*/	// ET6c ==> 'extAddr'
	add A1,A0,A0	// ET87 + 'extAddr' -> ET88
// break;
	j F11B227
	stx A0,(I0)	// ET88 ==> ET86
// jumped away
F11B40:	// (loop lvl 2)
	ldy (I4)-2,NULL ; ldx (I0),A0	// I4 += -2
// 			}
// page
// address
	call _ResGet16
	ldx (I4),I2 ; and A0,A1,C1	// ET2a and ETd -> 'page'
// jumped away
// align
	call _ResGet16
	ldx (I4),I2 ; add A0,NULL,B0	// A0 -> 'address'
// jumped away
// realSizeWords
	add A0,NULL,B1 ; ldx (I4)+2,I2	// I6 += 1
	call _ResGet16
	ldy (I6)+1,NULL	// A0 -> 'align'
// jumped away
	add A0,NULL,C0 ; stx B1,(I6)+1	// A0 -> AT14c
// sizeWords
	ldc 2,A0	// 2 -> 1 -> ET28
	add C0,A0,A1	// AT14c + ET28 -> ET37
	ldc 65534,A0	// 65534 -> 1 -> ET38
	and A1,A0,A1	// ET37 and ET38 -> 'sizeWords'
// = GetMemory(page,address,sizeWords,align);
	stx A1,(I6)+1	// 'sizeWords'
	stx B0,(I6)+1	// 'address'
	call _GetMemory
	stx C1,(I6)	// 'page'
// jumped away
	add A0,NULL,B0 ; ldx (I6)-4,NULL	// I6 += -4
	sub D1,ONES,D0	// 'secn' - (-1) -> AT136
	ldc _secbase9dfea0,A0	// ET3b
// 				secbase[secn] = address;
	add A0,D1,A0	// ET3b + 'secn' -> AT12b
	mv A0,I0 ; add A1,A1,A0	// AT12b -> ET3c
	stx B0,(I0) ; or C1,A0,B1	// 'address' ==> ET3c
// 				secpage[secn++] = page | (sizeWords << 1);
	ldc _secpage9dfea0,A0	// ET3f
	add A0,D1,A0	// ET3f + 'secn' -> AT12a
	mv A0,I0 ; sub NULL,ONES,A0	// AT12a -> ET42
	sty B1,(I0) ; sub C1,A0,A0	// ET3e ==> ET42
// 				if (page==1)
	ldc 2,A0	// 2 -> 1 -> ET28
	jzc F11B47	// unsigned compare
	nop
// jumped away
// 				}
// {
// 					*(u_int16 *)(address+sizeWords-1) = 0xbeef;
	add B0,A1,A0	// 'address' + 'sizeWords' -> ET44
	add A0,ONES,A0	// ET44 + (-1) -> ET45
	mv A0,I0	// ET45 -> ET46
	ldc 48879,A0	// 48879 -> 1 -> ET43
	stx A0,(I0)	// ET43 ==> ET46
F11B54:	// (loop lvl 3)
	add C0,ONES,B1	// AT14c + (-1) -> AT138
	sub C0,NULL,C0	// AT14c != (0) -> (0)
	nop
	jzs F11B210	// unsigned compare
	nop
// jumped away
// 				}
// text
// (!(resource.header.subType))
	ldc _resource+3,I0	// ET4b
	ldx (I0),A0 ; and NULL,NULL,A1	// ET4b ==> 3 -> ET4c
	sub A0,NULL,A0 ; ldx (I4)-2,NULL	// ET4c != (0) -> (0)
	nop	// I4 += -2
	jzc F11B56	// unsigned compare
	nop
// jumped away
// text = ResGet16(f);
	call _ResGet16
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	add A0,NULL,A1 ; ldx (I4)-2,NULL	// A0 -> 'text'
F11B56:	// (loop lvl 3)
	ldx (I4)+2,NULL ; sub C1,NULL,C1
// 					switch(page)
	ldc 1,A0
	jzc F11B60	// unsigned compare
	nop	// 1 -> 1 -> ET1b
// jumped away
// DisableIntVector(address);
	add B0,NULL,C0 ; ldx (I6)+1,NULL	// I4 += -2
	call _DisableIntVector
	ldy (I4)-2,NULL	// 'address' -> C0
// jumped away
// WriteToProgramRam16Swapped(address, text, ResGet16(f));
	call _ResGet16
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	add A0,NULL,C0 ; mv B0,I0	// A0 -> ET4e
	call _WriteToProgramRam16Swapped
	add A0,NULL,A1 ; mv A1,A0	// ET4e -> A1
// jumped away
F11B58:	// (loop lvl 3)
// 					address++;
	sub B0,ONES,B0	// 'address' - (-1) -> 'address'
	j F11B54
	add B1,NULL,C0	// AT138 -> AT14c
// jumped away
F11B60:	// (loop lvl 3)
	sub C1,A0,A0 ; mv B0,I0	// 'page' != ET1b -> AT104
	nop	// 'address' -> ET51
	jzc F11B65	// unsigned compare
	nop
// jumped away
// *(u_int16 *)address = text;
// break;
	j F11B58
	stx A1,(I0)	// 'text' ==> ET50
// jumped away
F11B65:	// (loop lvl 3)
// *(__y u_int16 *)address = text;
// break;
	j F11B58
	sty A1,(I0)	// 'text' ==> ET51
// jumped away
F11B210:	// (loop lvl 2)
	j F11B24
	add D0,NULL,D1	// AT136 -> 'secn'
// jumped away
F11B47:	// (loop lvl 2)
// else if (page==2)
	sub C1,A0,A0	// 'page' == ET28 -> AT100
	nop
	jzc F11B54	// unsigned compare
	add B0,A1,A0	// 'address' + 'sizeWords' -> ET44
// jumped away
// 				}
// {
// 					*(__y u_int16 *)(address+sizeWords-1) = 0xbeef;
	add A0,ONES,A0	// ET44 + (-1) -> ET45
	mv A0,I0	// ET45 -> ET47
	ldc 48879,A0	// 48879 -> 1 -> ET43
	j F11B54
	sty A0,(I0)	// ET43 ==> ET47
// jumped away
F11B29:	// (loop lvl 2)
// 		}
// {
// 		  if ((resource.header.resourceType & 0xff00u) == 0x0000 && resource.header.resourceType == 0x000a)
	and A0,A1,A1	// ET2a and ET2b -> ET2c
	nop
	jzc F11B24	// compare against zero
	nop
// jumped away
	ldc 10,A1	// 10 -> 1 -> ET2d
	sub A0,A1,A0	// ET2a != ET2d -> ATfb
	nop
	jzc F11B24	// unsigned compare
	nop
// jumped away
	ldx (I4)-2,NULL	// I4 += -2
// 		  }

	call _ResGet32
	ldx (I4)+2,I2	// unspill 'f' from #0
// jumped away
	ldx (I4)+2,NULL ; add A,NULL,B	// I4 += 2
	ldc 0,B2	// update guard bits (cmp)
	ldc 0,A0	// 0 -> 'wrongRom'
// = (t && t != ReadFromProgramRam(0xFFFF));
	sty A0,(I4)-2 ; sub B,NULL,B	// 'wrongRom' spills to #0
	nop
	jzs F11B24	// unsigned compare
	nop
// jumped away
	call _ReadFromProgramRam
	ldc 65535,I0	// 65535 -> I0
// jumped away
	ldc 0,A2	// update guard bits (cmp)
	ldc 0,B2	// update guard bits (cmp)
	sub B,A,B	// 't' != ET31 -> ATfd
	nop
	jzs F11B24	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL ; sub NULL,ONES,A0	// I4 += 2
	j F11B24
	sty A0,(I4)-2	// 'wrongRom' spills to #0
// jumped away
F11B22:
// 	if (lib)
	ldx (I4)-2,A0	// unspill 'lib' from #0
	sub A0,NULL,A0	// 'lib' == (0) -> (0)
	ldc _mutex9dfea0,I3
	jzs F11B161	// signed compare
	nop	// I3
// jumped away
	ldc _loadedLibs,I0	// ET4
	ldx (I0),A0/*V*/ ; ldy (I4)+2,NULL	// I4 += 3
// loadedLib[loadedLibs++] = lib;
	sub A0,ONES,A1	// ETdf - (-1) -> ETe0
	stx A1,(I0)/*V*/	// ETe0 ==> ET4
	ldc _loadedLib,A1	// ET5
	add A1,A0,A0	// ET5 + ETdf -> AT135
	mv A0,I0	// AT135 -> ETe1
	ldx (I4)-2,A0	// unspill 'lib' from #0
	stx A0,(I0)	// 'lib' ==> ETe1
// 	ReleaseMutex(&mutex);
F11B161:
	call _ReleaseMutex
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
// 	if (fatalErrors)
	ldy (I4)+1,A0	// unspill 'fatalErrors' from #0
	sub A0,NULL,A0	// 'fatalErrors' != (0) -> (0)
	ldx (I4)+1,A0	// unspill 'init' from #0
	jzc F11B163	// unsigned compare
	nop
// jumped away
// 	if (init)
	sub A0,NULL,A0	// 'init' == (0) -> (0)
	nop
	jzs F11B171	// signed compare
	nop
// jumped away
// 	}
// stackSave
	call _GetI6
	ldx (I4)-3,NULL
// jumped away
	ldx (I4)+3,NULL ; ldy (I6)+1,NULL	// I4 += 3
	ldx (I4)-6,A0 ; add A0,NULL,A1	// A0 -> 'stackSave'
// (parameters, lib);
	stx A0,(I6)+1	// 'lib'
	ldx (I4)+5,A0	// unspill 'parameters' from #0
	stx A0,(I6)	// 'parameters'
	ldx (I4)-2,A0	// unspill 'init' from #0
	mv A0,LR0
	jr
	ldc lo(F11B173),LR0	// (return address)
// jumped away
F11B173:
// 		if (GetI6() != stackSave)
	call _GetI6
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
	sub A0,A1,D1 ; ldx (I6)+1,NULL	// ETe7 != 'stackSave' -> AT126
	ldc stacktra_13,A0	// ETe8
	jzc F11B174	// unsigned compare
	nop	// I6 += 1
// jumped away
	ldx (I6)-1,NULL ; ldy (I4)+3,NULL
F11B171:
// 	return lib;
	j F11B1
	ldx (I4)-3,A0	// unspill 'lib' from #0
// jumped away
F11B174:
// ;
// 		}
// {
//  vo_printf("\nStack trashed.\n");
	call _vo_printf
	stx A0,(I6)	// ETe8
// jumped away
	ldc stacktra_13,A0	// ETe8
	ldc _vo_stderr,I0	// ET15
	stx A0,(I6)+1	// I6 += 1
//  vo_fprintf(vo_stderr,"\nStack trashed.\n");
	ldx (I0),A0/*V*/	// ET15 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
// 			while(1)
F11B182:
	j F11B182
	nop
// jumped away
F11B163:
	ldc _vo_stderr,I0	// ET15
	ldx (I4)-2,NULL ; ldy (I6)+1,NULL
// 	}

// (vo_stderr, e, fatalErrors);
	ldy (I4)-1,A0	// unspill 'fatalErrors' from #0
	stx A0,(I6)+1	// 'fatalErrors'
	ldc dfatale_12,A0	// 'e'
	stx A0,(I6)+1	// 'e'
	ldx (I0),A0/*V*/	// ET15 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-3,NULL	// I6 += -3
// 	  	while (1)
F11B169:
	j F11B169
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,RunAppFile3	// 39 words
	.export _RunAppFile3
_RunAppFile3:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	ldc _appFile,I0	// ET3
	stx I2,(I6)+1 ; ldy (I4)-2,NULL

// ->pos = 0;
	ldx (I0),I2/*V*/ ; and A,NULL,A	// ET3 ==> 'appFile'
	ldx (I2)+3,NULL ; or NULL,ONES,B1	// ET4 += 3
	stx A0,(I2)+1/*V*/
	stx A1,(I2)-1/*V*/
// 	lib = LoadLibraryFile(appFile, parameters);
	ldx (I4)+2,B0	// unspill 'parameters' from #-2
	stx B0,(I6)+1	// 'parameters'
	ldx (I0),A0/*V*/	// ET3 ==> 'appFile'
	call _LoadLibraryFile
	stx A0,(I6)	// 'appFile'
// jumped away
	ldx (I6)-2,NULL ; sub A0,NULL,A1	// I6 += -2
// 	if (lib)
	ldc 2,A0	// 2 -> 0 -> ET6
	jzs F12B5	// signed compare
	nop
// jumped away
	ldx (I6)+1,NULL ; add A1,A0,A0	// I6 += 1
	mv A0,I0	// ATd -> ET7
// 	}
// {
// 		r = ((int(*)(void*))(lib[2]))(parameters);
	stx B0,(I6)	// 'parameters'
	ldx (I0),A0	// ET7 ==> 2 -> ET8
	mv A0,LR0
	jr
	ldc lo(F12B6),LR0	// (return address)
// jumped away
F12B6:
// 		DropLibrary(lib);
	call _DropLibrary
	stx A1,(I6) ; add A0,NULL,B1	// I6 += 1
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
F12B5:
// 	return r;
	add B1,NULL,A0 ; ldx (I6)-1,I2	// 'r' returns via A0
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect data_x,apploaderbss_x	// 26 words
_resource:
	.bss 6
_secbase9dfea0:
	.bss 20

//_____________________________________________________________
//
	.sect data_x,apploaderinit_x	// 4 words
	.export _ovlChecksum
_ovlChecksum:
	.word 0
_mutex9dfea0:
	.word 1
_rPageab36a0:
	.word 0
_extAddrab36a0:
	.word 0

//_____________________________________________________________
//
	.sect data_y,apploaderconst_y	// 64 words
	.export _defaultIntVector
_defaultIntVector:
	.word lo(707060046), hi(707060046), lo(706751054), hi(706751054), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(707064142), hi(707064142), lo(704676686), hi(704676686)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)
	.word lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158), lo(706750158), hi(706750158)

//_____________________________________________________________
//
	.sect data_x,apploaderconst_x	// 255 words
res_1:
	.word "0Res"

	.zero 1
calltod_2:
	.word "\nCall to dropped lib! Interrupt level (encount): %d, last int vector: %d\n"

	.zero 1
s_3:
	.word "%s... "

	.zero 1
ssyssd_4:
	.word "S:SYS/%s.DL3"

	.zero 1
rb_5:
	.word "rb"

	.zero 1
snotfou_6:
	.word "%s not found"

	.zero 1
lib_7:
	.word "lib"

	.zero 1
String_8:

	.zero 1
alreadylo_9:
	.word "Already loaded(LIB%d).\n"

	.zero 1
toooldap_10:
	.word "Too old APP"

	.zero 1
_eab36e8:
	.word String_14
corruptli_11:
	.word "Corrupt lib %s"

	.zero 1
dfatale_12:
	.word "%d fatal errors. Stop.\n"

	.zero 1
stacktra_13:
	.word "\nStack trashed.\n"

	.zero 1
String_14:
	.word "E: Symbol %-15s (CRC32 %08lx) not found.\n"

	.zero 1

//_____________________________________________________________
//
	.sect data_y,apploaderbss_y	// 20 words
_secpage9dfea0:
	.bss 20

//_____________________________________________________________
//
	.sect data_y,apploaderinit_y	// 1 word
_rBaseab36a0:
	.word 0

	.end
