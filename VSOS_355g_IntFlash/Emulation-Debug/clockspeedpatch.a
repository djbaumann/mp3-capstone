
//_____________________________________________________________
//
	.sect code,DelayMicroSecPatch	// 27 words
	.export _DelayMicroSecPatch
_DelayMicroSecPatch:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -22,A0	// -22 -> 0 -> ET4
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; ldy (I4)-3,NULL
	ldc _clockSpeed,I0	// ET0
// 	BusyDelay4x(microSec * (u_int32)((u_int16)((s_int32)clockSpeed.cpuClkHz >> 22)));
	ldx (I0)+1,B0
	ldx (I0)-1,B1
	mv B1,B1	// update guard bits
	ashl B,A0,A ; mv C0,I7	// ET1 << ET4 -> ET5
	ldx (I4)+1,B0	// unspill B0 from #0
	ldx (I4)+2,B1	// unspill B1 from #0
	muluu A0,B1 ; mv A0,C0	// 'microSec' * ET6 -> ET8
	add NULL,P,A	// (32x16)
	muluu C0,B0 ; mv I7,C0
	call _BusyDelay4x
	add A0,P,A
// jumped away
	ldx (I6)-1,I0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,GetDivider	// 41 words
	.export _GetDivider
_GetDivider:
	ldc 2000,A0	// 2000 lsw ET3
	ldx (I6)+1,NULL ; mulsu A0,C0	// I6 += 1
	stx LR0,(I6)+1
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; and NULL,NULL,B0	// 0 -> 'div'
	sty D0,(I6)+1 ; add C1,NULL,D0
	stx I0,(I6) ; add NULL,P,A
	ldc 0,A2	// update guard bits (cmp)
	ldc _clockSpeed,I0	// ET6
// div
// maxSpeedHzTimes2
	ldx (I0)+1,C0	// ET3 * 'maxSpeedKHz' -> 'maxSpeedHzTimes2'
	ldx (I0)-1,C1	// 16x16->32bit
// (maxSpeedHzTimes2 <= clockSpeed.cpuClkHz)
	ldc 0,C2	// update guard bits (cmp)
	sub C,A,C	// ET7 > 'maxSpeedHzTimes2' -> AT10
	nop
	jcc F1B4	// unsigned compare
	add C,A,C	// restore value
// jumped away
//   }
// {
//     div = (u_int16)((clockSpeed.cpuClkHz + maxSpeedHzTimes2 - 1) /
// 		    maxSpeedHzTimes2) - 1;
	add C,A,B	// ET7 + 'maxSpeedHzTimes2' -> ET8
	call divide32unsigned
	add B,ONES,B	// ET8 + (-1) -> ETa
// jumped away
	ldc 0,C2	// update guard bits (cmp)
	ldc _lastCpu8e6250,I0	// ETf
	ldx (I0)+1,A0/*V*/ ; add A0,ONES,B0	// ETc + (-1) -> 'div'
//     if (lastCpu != clockSpeed.cpuClkHz)
	ldx (I0)-1,A1/*V*/
	ldc 0,A2	// update guard bits (cmp)
	sub A,C,A	// 'lastCpu' == ET7 -> AT16
	nop
	jzs F1B7	// unsigned compare
	sub D0,B0,A0
// jumped away
//     }
// {
//       lastCpu = clockSpeed.cpuClkHz;
	stx C0,(I0)+1/*V*/ ; sub D0,B0,A0
	stx C1,(I0)-1/*V*/
//     if (div > maxVal)
F1B7:
	nop
	jcs F1B4	// unsigned compare
	add D0,NULL,A0	// 'maxVal' returns via A0
// jumped away
//     }
// {
//       return maxVal;
F1B1:
	ldx (I6)-1,I0
	ldy (I6),D0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F1B4:
//   return div;
	j F1B1
	add B0,NULL,A0	// 'div' returns via A0
// jumped away

//_____________________________________________________________
//
	.sect data_x,clockspeedpatchinit_x	// 2 words
_lastCpu8e6250:
	.word lo(0), hi(0)

	.end
