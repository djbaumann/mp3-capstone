
//_____________________________________________________________
//
	.sect code,DevHwSpiIdentify	// 4 words
	.export _DevHwSpiIdentify
_DevHwSpiIdentify:
// 	return deviceName;
	ldc _deviceName,I0	// ET0
	ldx (I0),A0/*V*/	// ET0 ==> 'deviceName'
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevHwSpiCreate	// 141 words
	.export _DevHwSpiCreate
_DevHwSpiCreate:
	ldc 33,A0	// 33 -> A0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	ldc _devHwSpiDefaults,I1	// I1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I3	// I0 -> 'dev'
	mv I3,I2	// 'dev' -> 'hw'
	mv I3,I0	// 'dev' -> I0
// hw
// (dev, &devHwSpiDefaults, sizeof(*dev));
	ldx (I2)+7,NULL	// 'hw' += 11
	call _memcpy
	ldx (I2)+4,NULL	// ...
// jumped away
	ldc ___nextDeviceInstance,I0	// ET6
	ldx (I0),A0/*V*/ ; ldy (I4)-2,NULL	// I4 += -2
// 	dev->deviceInstance = __nextDeviceInstance++;
	sub A0,ONES,A1	// ET7 - (-1) -> ET9
	stx A1,(I0)/*V*/	// ET9 ==> ET6
	mv I3,I0	// 'dev' -> ETb
	ldx (I0)+7,NULL	// ETb += 10
	ldx (I0)+3,NULL	// ...
	stx A0,(I0)	// ET7 ==> ETb
	mv I2,I0	// 'hw' -> I0
	ldc 9,A0	// 9 -> A0
// 	memcpy(hw, name, sizeof(devHwSpiHwInfo));
	call _memcpy
	ldx (I4)+2,I1	// unspill 'name' from #0
// jumped away
// 	hw->regs->config = 0x1be &(1<<11) &(1<<0);
	ldc 1020,A1	// 1020 -> 1 -> ET10
	ldx (I2),I0 ; and NULL,NULL,A0	// 'hw' ==> ETf
	sty A0,(I0)+1/*V*/ ; and B,NULL,B	// ETe ==> ETf
// 	hw->regs->clkconfig = 255 << 2;
	sty A1,(I0)/*V*/	// ET10 ==> ET11
	mv I2,I0	// 'hw' -> ET14
	ldc 4095,A1	// 4095 -> 1 -> ET19
// 	hw->peripMask = hw->ioMask = 0;
	ldx (I0)+4,NULL	// ET14 += 4
	stx B0,(I0)+1
	stx B1,(I0)+1
	stx B0,(I0)+1
	stx B1,(I0)-6
// 	if (hw->csPin == 0x0fffu)
	ldx (I0),B0	// ET14 ==> 1 -> ET18
	mv I2,I0 ; sub B0,A1,A1	// 'hw' -> ET16
	nop
	jzs F1B5	// unsigned compare
	ldx (I0)+6,NULL	// ET16 += 6
// jumped away
// 	}
// else {
// 		if ((u_int16)(hw->regs) == 0xFC40)
	ldc 64576,A0	// 64576 -> 1 -> ET2d
	ldx (I2),A1	// 'hw' ==> ET2c
	sub A1,A0,A0	// ET2c != ET2d -> AT42
	ldc 64592,A1
	jzc F1B9	// unsigned compare
	ldx (I2)+1,A0
// jumped away
	ldc 64561,I0	// 64561 -> ET2f
	ldc 14,A1	// 14 -> 1 -> ET2e
// 		}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFC31)) |= (1<<1)|(1<<2)|(1<<3);
	ldy (I0),A0/*V*/ ; ldx (I2)+5,NULL	// ET2f ==> ET30
	or A0,A1,A0	// ET30 or ET2e -> ET31
	sty A0,(I0)/*V*/ ; and NULL,NULL,A1	// ET31 ==> ET2f
// 			hw->peripMask =(1UL<< 8);
	ldc 256,A0	// 256 -> 3 -> A0
	stx A0,(I2)+1	// 0 -> A1
	ldc 16,A0	// 16 -> 3 -> A0
	stx A1,(I2)-3
// 			hw->ioMask =(1UL<< 4);
	stx A0,(I2)+1
	stx A1,(I2)-5
// 		if ((u_int16)(hw->regs) == 0xFC50)
	ldc 64592,A1	// 64592 -> 1 -> ET33
	ldx (I2)+1,A0	// 'hw' ==> ET2c
F1B9:
	sub A0,A1,A0	// ET2c != ET33 -> AT44
	ldc 65535,A1
	jzc F1B11	// unsigned compare
	ldx (I2)-1,A0
// jumped away
	ldc 64561,I0	// 64561 -> ET2f
	ldc 224,A1	// 224 -> 1 -> ET34
	ldy (I0),A0/*V*/ ; ldx (I2)+6,NULL
// 		}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFC31)) |= (1<<5)|(1<<6)|(1<<7);
	or A0,A1,A0	// ET35 or ET34 -> ET36
	sty A0,(I0)/*V*/ ; and NULL,NULL,A1	// ET36 ==> ET2f
// 			hw->peripMask =(1UL<< 9);
	ldc 512,A0	// 512 -> 3 -> A0
	stx A0,(I2)+1	// 0 -> A1
	ldc 4,A0	// 4 -> 3 -> A0
	stx A1,(I2)-3
// 			hw->ioMask =(1UL<< 2);
	stx A0,(I2)+1
	stx A1,(I2)-4
// 		if (hw->csPin == 0xffffu)
	ldc 65535,A1	// 65535 -> 1 -> ET39
	ldx (I2)-1,A0	// 'hw' ==> 1 -> ET18
F1B11:
	sub A0,A1,A0	// ET18 == ET39 -> AT45
	nop
	jzs F1B12	// unsigned compare
	nop
// jumped away
// 		}
// else {
// 			ObtainHwLocksBIP(0, PinToGpioHwLockMask(hw->csPin),0);
	ldx (I2)+1,NULL ; ldy (I6)+1,NULL	// 'hw' += 1
	call _PinToGpioHwLockMask
	ldx (I2),D0	// 'hw' ==> 1 -> ET18
// jumped away
	and B,NULL,B ; ldx (I6)+1,NULL	// 0 -> B
	add A,NULL,C	// ET3d -> C
	call _ObtainHwLocksBIP
	and D,NULL,D	// 0 -> D
// jumped away
// 			GpioSetPin(hw->csPin, 1);
	ldx (I2),C0 ; ldy (I6)+1,NULL	// 'hw' ==> 1 -> ET18
	call _GpioSetPin
	sub NULL,ONES,C1	// 1 -> C1
// jumped away
F1B7:
// 	dev->flags =(1 << 0) |(1 << 1) |(1 << 5) |(1 << 6);
	ldc 99,A0	// 99 -> 1 -> ET3f
	stx A0,(I3) ; ldy (I6),I3	// ET3f ==> 'dev'
// 	return 0;
	ldx (I6)-1,I2 ; and NULL,NULL,A0	// 0 -> 0 -> ET40
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F1B12:
// 		}
// {
// 			hw->ioMask |=((1UL<< 1)|(1UL<< 12)|(1UL<< 5));
	ldc 4130,B0	// 4130 -> 3 -> B0
	ldx (I2)+4,NULL ; and NULL,NULL,B1	// 'hw' += 4
	ldx (I2)+1,A0
	ldx (I2)-1,A1
	or A,B,A	// ET3b or ET3a -> ET3c
	stx A0,(I2)+1
	j F1B7
	stx A1,(I2)-1
// jumped away
F1B5:
// 	}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) &= ~(1<<6);
	ldc 8,B1	// 8 -> 1 -> ET21
	ldc 65471,A1	// 65471 -> 1 -> ET1a
	ldc 65230,I2	// 65230 -> ET1b
	ldy (I2),B0/*V*/	// ET1b ==> ET1c
	and B0,A1,A1	// ET1c and ET1a -> ET1d
	sty A1,(I2)/*V*/	// ET1d ==> ET1b
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) &= ~0x0008;
	ldc 65527,A1	// 65527 -> 1 -> ET1e
	ldy (I2),B0/*V*/	// ET1b ==> ET1f
	and B0,A1,B0	// ET1f and ET1e -> ET20
	sty B0,(I2)/*V*/	// ET20 ==> ET1b
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) |=  0x0008;
	ldy (I2),B0/*V*/	// ET1b ==> ET22
	or B0,B1,B0	// ET22 or ET21 -> ET23
	sty B0,(I2)/*V*/ ; and NULL,NULL,B1	// ET23 ==> ET1b
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) &= ~0x0008;
	ldy (I2),B0/*V*/	// ET1b ==> ET24
	and B0,A1,A1	// ET24 and ET1e -> ET25
	ldc 4096,B0	// 4096 -> 1 -> ET26
	sty A1,(I2)/*V*/	// ET25 ==> ET1b
// (*(__y volatile u_int16 *)(u_int16)(0xFC3E)) |=(1<<12);
	ldc 64574,I2	// 64574 -> ET27
	ldy (I2),A1/*V*/	// ET27 ==> ET28
	or A1,B0,A1	// ET28 or ET26 -> ET29
	ldc 256,B0	// 256 -> 3 -> B0
	sty A1,(I2)/*V*/ ; stx B0,(I0)+1	// ET29 ==> ET27
// 		hw->peripMask =(1UL<< 8);
	stx B1,(I0)-1
// (*(__y volatile u_int16 *)(u_int16)(0xFC44)) = 0;
	ldc 64580,I0	// 64580 -> ET2b
	j F1B7
	sty A0,(I0)/*V*/	// ETe ==> ET2b
// jumped away

//_____________________________________________________________
//
	.sect code,DevHwSpiDelete	// 35 words
	.export _DevHwSpiDelete
_DevHwSpiDelete:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 65535,A1	// 65535 -> 1 -> ET6
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I2,(I6)
	mv I0,I2	// 'dev' -> 'hw'
// hw
// (hw->csPin == 0xffffu)
	ldx (I2)+7,NULL	// 'hw' += 11
	ldx (I2)+5,NULL	// ...
	ldx (I2)-1,A0	// 'hw' ==> 1 -> ET5
	sub A0,A1,A0	// ET5 == ET6 -> ATc
	nop
	jzs F2B5	// unsigned compare
	nop
// jumped away
// 	}
// else {
// 		ReleaseHwLocksBIP(0, PinToGpioHwLockMask(hw->csPin),0);
	ldx (I2)+1,NULL ; ldy (I6)+1,NULL	// 'hw' += 1
	call _PinToGpioHwLockMask
	ldx (I2),D0	// 'hw' ==> 1 -> ET5
// jumped away
	and B,NULL,B ; ldx (I6)+1,NULL	// 0 -> B
	add A,NULL,C	// ET8 -> C
	call _ReleaseHwLocksBIP
	and D,NULL,D	// 0 -> D
// jumped away
F2B5:
// 	dev->flags = 0;
	and NULL,NULL,A0 ; ldy (I6),I2	// 0 -> 1 -> ETa
	stx A0,(I0)	// ETa ==> 'dev'
// 	return 0;
	ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevHwSpiRead	// 134 words
	.export _DevHwSpiRead
_DevHwSpiRead:
	ldc 2,A0	// 2 -> 1 -> ET4
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2	// I0 -> 'dev'
	ldx (I4)-2,NULL ; ldy (I2)+7,NULL	// I4 += -2
// hw
// wbuf
// ; }
// while (hw->regs->status &(1<<1))
	ldx (I4)-1,C1 ; ldy (I2)+4,NULL	// unspill 'buf' from #-2
	mv C1,I3	// 'buf' -> 'wbuf'
	ldx (I4)-1,C0	// unspill 'destinationIndex' from #-3
	ldx (I4)+4,B1	// unspill AT39 from #-4
F3B6:	// (loop lvl 2)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET5 += 2
	ldy (I0),A1/*V*/	// ET5 ==> ET6
	and A1,A0,A0	// ET6 and ET4 -> ET7
	ldc 2,A0
	jzc F3B6	// compare against zero
	nop
// jumped away
// ;
// 	if (!buf)
	sub C1,NULL,C1	// 'buf' != (0) -> (0)
	ldc 430,A0	// 430 -> 1 -> ET8
	jzc F3B16	// signed compare
	nop
// jumped away
// 	}
// {
// 		hw->regs->config = 0x1ae;
	ldc 2,B1	// 2 -> 1 -> ET4
	ldx (I2),I0	// 'dev' ==> ET3
	sty A0,(I0)+3/*V*/	// ET8 ==> ET3
// 		hw->regs->data = 0xff;
	ldc 255,A0	// 255 -> 1 -> ET9
	sty A0,(I0)/*V*/ ; ldx (I2),I0	// ET9 ==> ETb
	mv I0,I1	// ET3 -> ET5
// ; }
// { while (hw->regs->status &(1<<1))
	ldx (I1)+2,NULL	// ET5 += 2
F3B12:	// (loop lvl 2)
	ldy (I1),A0/*V*/	// ET5 ==> ETc
	and A0,B1,A0 ; mv I0,I1	// ETc and ET4 -> ETd
	ldx (I1)+2,NULL
	jzc F3B12	// compare against zero
	ldc 255,A0	// 255 -> 1 -> ET9
// jumped away
// ;
// 		return hw->regs->data & 0xff;
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+3,NULL	// ETb += 3
	ldy (I0),A1/*V*/	// ETb ==> ETe
	and A1,A0,A0	// ETe and ET9 -> ETf
F3B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F3B36:	// (loop lvl 2)
// ;
// 			if (destinationIndex)
	sub C0,NULL,C0 ; ldx (I2),I0	// 'destinationIndex' != (0) -> (0)
	ldx (I0)+3,NULL	// ETb += 3
	jzc F3B39	// unsigned compare
	ldy (I0),A0/*V*/	// ETb ==> ET27
// jumped away
// 			}
// else {
// 				*wbuf++ = hw->regs->data;
	stx A0,(I3)+1	// ET27 ==> 'wbuf'
F3B41:	// (loop lvl 2)
// 			bytes-=2;
	ldc 2,A0	// 2 -> 1 -> ET4
	sub B1,A0,B1	// AT39 - ET4 -> AT39
F3B16:	// (loop lvl 2)
	sub B1,NULL,B1	// AT39 == (0) -> (0)
	ldc 1,A0
	jzs F3B14	// unsigned compare
	sub B1,A0,A0	// AT39 == ET10 -> AT2d
// jumped away
// 	}
// {
// 		if (bytes == 1)
	ldc 446,A0	// 446 -> 1 -> ET1d
	jzs F3B23	// unsigned compare
	ldx (I2),I0	// 'dev' ==> ET3
// jumped away
// 		}
// else {
// 			if (hw->regs->config != 0x1be)
	ldy (I0),A1/*V*/	// ET3 ==> ET1c
	sub A1,A0,A0	// ET1c != ET1d -> AT30
	ldc 65535,A0
	jzs F3B30	// unsigned compare
	nop
// jumped away
	ldc 2,A0	// 2 -> 1 -> ET4
F3B34:	// (loop lvl 3)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET5 += 2
	ldy (I0),A1/*V*/	// ET5 ==> ET1e
	and A1,A0,A0	// ET1e and ET4 -> ET1f
	ldc 2,A0
	jzc F3B34	// compare against zero
	nop
// jumped away
// ;
// 				hw->regs->config = 0x1be;
	ldc 446,A0	// 446 -> 1 -> ET1d
	ldx (I2),I0	// 'dev' ==> ET3
	sty A0,(I0)/*V*/	// ET1d ==> ET3
// 			hw->regs->data = 0xffff;
	ldc 65535,A0	// 65535 -> 1 -> ET13
F3B30:	// (loop lvl 2)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+3,NULL	// ETb += 3
	sty A0,(I0)/*V*/ ; ldx (I2),I0	// ET13 ==> ETb
// ; }
// { while (hw->regs->status &(1<<1))
	ldc 2,A0	// 2 -> 1 -> ET4
	ldx (I0)+2,NULL	// ET5 += 2
F3B38:	// (loop lvl 3)
	ldy (I0),A1/*V*/ ; ldx (I2),I0	// ET5 ==> ET20
	and A1,A0,A0 ; ldx (I0)+2,NULL	// ET20 and ET4 -> ET21
	ldc 2,A0
	jzc F3B38	// compare against zero
	nop
// jumped away
	j F3B36
	nop
// jumped away
F3B23:	// (loop lvl 3)
	ldc 2,A0	// 2 -> 1 -> ET4
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET5 += 2
	ldy (I0),A1/*V*/ ; ldx (I2),I0	// ET5 ==> ET11
	and A1,A0,A0	// ET11 and ET4 -> ET12
	ldc 430,A0	// 430 -> 1 -> ET8
	jzc F3B23	// compare against zero
	nop	// 'dev' ==> ET3
// jumped away
// ;
// 			hw->regs->config = 0x1ae;
	sty A0,(I0)+3/*V*/	// ET8 ==> ET3
// 			hw->regs->data = 0xffff;
	ldc 65535,A0	// 65535 -> 1 -> ET13
	sty A0,(I0)/*V*/	// ET13 ==> ETb
// ; }
// { while (hw->regs->status &(1<<1))
	ldc 2,A0	// 2 -> 1 -> ET4
F3B27:	// (loop lvl 3)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET5 += 2
	ldy (I0),A1/*V*/	// ET5 ==> ET14
	and A1,A0,A0	// ET14 and ET4 -> ET15
	ldc 2,A0
	jzc F3B27	// compare against zero
	nop
// jumped away
	ldc 255,A0	// 255 -> 1 -> ET9
	ldx (I2),I0 ; ldy (I4)+1,NULL	// I4 += 1
// ;
// 			w[0] = hw->regs->data & 0xff;
	ldx (I0)+3,NULL	// ETb += 3
	ldy (I0),A1/*V*/	// ETb ==> ET16
	and A1,A0,A0 ; mv C1,I0	// ET16 and ET9 -> ET17
	stx A0,(I4) ; sub NULL,ONES,A1
// 			MemCopyPackedBigEndian(buf, destinationIndex, w, 1, 1);
	mv I4,I1 ; add C0,NULL,A0	// 'destinationIndex' -> A0
	call _MemCopyPackedBigEndian
	ldx (I4)-1,NULL ; sub NULL,ONES,B0	// I4 += -1
// jumped away
// 			bytes--;
	j F3B16
	add B1,ONES,B1	// AT39 + (-1) -> AT39
// jumped away
F3B14:
// 	return 0;
	j F3B1
	and NULL,NULL,A0	// 0 -> 1 -> ET23
// jumped away
F3B39:	// (loop lvl 2)
	mv I3,I0	// 'wbuf' -> I0
	ldc 2,B0	// 2 -> B0
	ldx (I4)+1,NULL ; ldy (I3)+1,NULL	// I4 += 1
// 			}
// {
// 				w[0] = hw->regs->data;
	stx A0,(I4) ; add C0,NULL,A0
// 				MemCopyPackedBigEndian(wbuf++, destinationIndex, w, 0, 2);
	mv I4,I1 ; and NULL,NULL,A1	// 'destinationIndex' -> A0
	ldx (I4)-1,NULL	// I4 += -1
	call _MemCopyPackedBigEndian
	ldc F3B41,LR0
// jumped away

//_____________________________________________________________
//
	.sect code,DevHwSpiWrite	// 129 words
	.export _DevHwSpiWrite
_DevHwSpiWrite:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)
	mv I0,I2	// I0 -> 'dev'
	ldx (I4)-2,NULL ; ldy (I2)+7,NULL	// I4 += -2
// hw
// (!buf)
	ldx (I4)-2,C1 ; ldy (I2)+4,NULL	// ...
	sub C1,NULL,C1 ; ldx (I4)+1,C0	// 'buf' != (0) -> (0)
	ldc 430,A0	// 430 -> 1 -> ET5
	jzc F4B53	// signed compare
	nop	// unspill AT34 from #-4
// jumped away
	ldx (I2),I0
// 	}
// {
// 		if (hw->regs->config != 0x1ae)
	ldy (I0),A1/*V*/	// ET3 ==> ET4
	sub A1,A0,B1	// ET4 == ET5 -> AT22
	ldc 2,A1	// 2 -> 1 -> ET6
	jzs F4B58	// unsigned compare
	nop
// jumped away
	ldx (I4)-1,B1
	ldx (I4)+4,C0	// unspill AT2f from #-4
F4B10:	// (loop lvl 2)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET7 += 2
	ldy (I0),A0/*V*/	// ET7 ==> ET8
	and A0,A1,A0	// ET8 and ET6 -> ET9
	ldc 2,A1
	jzc F4B10	// compare against zero
	ldc 430,A0	// 430 -> 1 -> ET5
// jumped away
// ;
// 			hw->regs->config = 0x1ae;
	ldx (I2),I0	// 'dev' ==> ET3
	sty A0,(I0)/*V*/	// ET5 ==> ET3
F4B50:
	j F4B14
	ldc 64,C1	// 64 -> 1 -> ETe
// jumped away
F4B16:	// (loop lvl 2)
// ;
// 			hw->regs->data = sourceIndex;
	ldx (I2),I0 ; add A0,NULL,C0	// 'dev' ==> ET3
	ldx (I0)+3,NULL	// ET11 += 3
	sty B1,(I0)/*V*/	// 'sourceIndex' ==> ET11
F4B14:	// (loop lvl 2)
	add C0,ONES,A0	// AT2f + (-1) -> ETc
	sub C0,NULL,C0	// AT2f == (0) -> (0)
	nop
	jzs F4B12	// unsigned compare
	nop
// jumped away
	ldx (I2),I0	// 'dev' ==> ET3
	mv I0,I1	// ET3 -> ET7
	ldx (I1)+2,NULL	// ET7 += 2
F4B18:	// (loop lvl 3)
	ldy (I1),A1/*V*/	// ET7 ==> ETd
	and A1,C1,A1 ; mv I0,I1	// ETd and ETe -> ETf
	nop
	jzc F4B18	// compare against zero
	ldx (I1)+2,NULL
// jumped away
	j F4B16
	nop
// jumped away
F4B12:
// 		return 0;
	and NULL,NULL,A0 ; ldy (I6),I2	// 0 -> 1 -> ET12
	ldx (I6)-1,I1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldx (I4)-3,NULL	// I4 += -3
F4B58:
	ldx (I4)-1,B1	// unspill 'sourceIndex' from #-3
	j F4B50
	ldx (I4)+4,C0	// unspill AT2f from #-4
// jumped away
F4B53:
	j F4B22
	ldx (I4)+3,B1	// unspill AT35 from #-3
// jumped away
F4B39:	// (loop lvl 2)
	ldy (I4)+1,NULL ; ldx (I2),I0	// I4 += 1
// ;
// 			hw->regs->data = w;
	ldx (I4)-1,A0 ; ldy (I0)+3,NULL	// I4 ==> 'w'
	sty A0,(I0)/*V*/	// 'w' ==> ET11
F4B22:	// (loop lvl 2)
	sub C0,NULL,C0	// AT34 == (0) -> (0)
	ldc 2,B0	// 2 -> B0
	jzs F4B12	// unsigned compare
	nop
// jumped away
	ldx (I4)+1,NULL ; and NULL,NULL,A0	// I4 += 1
// 	}

	stx A0,(I4) ; sub NULL,ONES,A0
// (bytes == 1)
	sub C0,A0,A0 ; mv B1,A1	// AT34 == ET13 -> AT27
	mv I4,I0
	jzs F4B23	// unsigned compare
	and NULL,NULL,A0 ; mv C1,I1	// 0 -> A0
// jumped away
// 		}
// else {
// 			MemCopyPackedBigEndian(&w, 0, buf, sourceIndex, 2);
	call _MemCopyPackedBigEndian
	ldx (I4)-1,NULL ; add B1,NULL,A1	// AT35 -> A1
// jumped away
// 			sourceIndex+=2;
	ldc 2,A0	// 2 -> 1 -> ET6
	add B1,A0,B1 ; ldx (I2),I0	// AT35 + ET6 -> AT35
// 			bytes-=2;
	sub C0,A0,C0 ; ldy (I0),A1/*V*/	// AT34 - ET6 -> AT34
// 			if (hw->regs->config != 0x1be)
	ldc 446,A0	// 446 -> 1 -> ET1c
	sub A1,A0,A0	// ET1b != ET1c -> AT2b
	ldc 2,A0	// 2 -> 1 -> ET6
	jzs F4B41	// unsigned compare
	nop
// jumped away
F4B37:	// (loop lvl 3)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET7 += 2
	ldy (I0),A1/*V*/	// ET7 ==> ET1d
	and A1,A0,A0	// ET1d and ET6 -> ET1e
	ldc 2,A0
	jzc F4B37	// compare against zero
	nop
// jumped away
// ;
// 				hw->regs->config = 0x1be;
	ldc 446,A0	// 446 -> 1 -> ET1c
	ldx (I2),I0	// 'dev' ==> ET3
	sty A0,(I0)/*V*/	// ET1c ==> ET3
F4B41:	// (loop lvl 3)
	ldc 64,A0	// 64 -> 1 -> ETe
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET7 += 2
	ldy (I0),A1/*V*/	// ET7 ==> ET1f
	and A1,A0,A0	// ET1f and ETe -> ET20
	nop
	jzc F4B41	// compare against zero
	nop
// jumped away
	j F4B39
	nop
// jumped away
F4B23:	// (loop lvl 2)
// 		}
// {
// 			MemCopyPackedBigEndian(&w, 1, buf, sourceIndex++, 1);
	sub B1,ONES,D0 ; ldx (I4)-1,NULL	// AT35 - (-1) -> ET15
	sub NULL,ONES,A0	// 1 -> A0
	sub NULL,ONES,B0	// I4 += -1
	call _MemCopyPackedBigEndian
	add D0,NULL,B1	// ET15 -> AT35
// jumped away
	ldc 2,A0	// 2 -> 1 -> ET6
F4B30:	// (loop lvl 3)
	ldx (I2),I0	// 'dev' ==> ET3
	ldx (I0)+2,NULL	// ET7 += 2
	ldy (I0),A1/*V*/	// ET7 ==> ET17
	and A1,A0,A0	// ET17 and ET6 -> ET18
	ldc 2,A0
	jzc F4B30	// compare against zero
	nop
// jumped away
	ldc 430,A0	// 430 -> 1 -> ET5
	ldy (I4)+1,NULL ; ldx (I2),I0	// I4 += 1
// ;
// 			hw->regs->config = 0x1ae;
	sty A0,(I0)+3/*V*/ ; ldx (I4)-1,A0	// ET5 ==> ET3
// 			hw->regs->data = w;
// 			bytes--;
	j F4B22
	sty A0,(I0)/*V*/ ; add C0,ONES,C0	// 'w' ==> ET11
// jumped away
// 	return 0;

//_____________________________________________________________
//
	.sect code,DevHwSpiIoctl	// 173 words
	.export _DevHwSpiIoctl
_DevHwSpiIoctl:
	ldx (I6)+1,NULL ; ldy (I0)+7,NULL	// I6 += 1
	stx LR0,(I6)+1 ; ldy (I0)+7,NULL
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4 ; ldy (I0)+3,NULL
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6)+1 ; sty I2,(I6)
	ldx (I4)-2,NULL	// I4 += -2
// hw
// (request)
	ldx (I4)+2,A0	// unspill 'request' from #-2
	add A0,ONES,A1	// 'request' == (-1) -> AT43
	nop	// 'dev' += 6
	jzs F5B4	// signed compare
	nop	// 0 -> B
// jumped away
	ldc 2,A1	// 2 -> 0 -> ET11
	ldx (I0)-6,NULL ; ldy (I6)-1,NULL
	sub A0,A1,A1	// 'request' == ET11 -> AT45
	ldc 3,A1	// 3 -> 0 -> ET3e
	jzs F5B26	// signed compare
	sub A0,A1,A0	// 'request' == ET3e -> AT4b
// jumped away
	ldc 2,A0
	jzs F5B44	// signed compare
	nop
// jumped away
// 			return -1;
	or NULL,ONES,A0	// -1 -> 0 -> ET41
F5B1:
	ldy (I6),I2 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 2,A0	// 2 -> 1 -> ET2e
F5B44:
	ldx (I0),I0	// 'dev' ==> ET14
	mv I0,I2	// ET14 -> ET37
	ldx (I2)+2,NULL	// ET37 += 2
F5B41:	// (loop lvl 2)
	ldy (I2),A1/*V*/	// ET37 ==> ET3f
	and A1,A0,A1 ; mv I0,I2	// ET3f and ET2e -> ET40
	nop
	jzc F5B41	// compare against zero
	ldx (I2)+2,NULL
// jumped away
	j F5B3
	nop
// jumped away
F5B24:
// ;
// (*(__y volatile u_int16 *)(u_int16)(0xFC40)) |=(1<<0);
	ldc 64576,I2	// 64576 -> ET23
	ldy (I2),A0/*V*/ ; sub NULL,ONES,A1	// 1 -> 1 -> ET15
	ldx (I0)+1,NULL ; or A0,A1,A0	// ET23 ==> ET3a
	ldc 4095,A1	// 4095 -> 1 -> ET1b
	sty A0,(I2)/*V*/ ; ldx (I0)-1,A0	// ET3b ==> ET23
// 			if (!(hw->csPin == 0x0fffu))
	sub A0,A1,A1	// ET1a == ET1b -> AT4c
	nop
	jzs F5B28	// unsigned compare
	nop
// jumped away
// 			}
// {
// 				if (hw->csPin == 0xffffu)
	ldc 65535,A1	// 65535 -> 1 -> ET29
	sub A0,A1,A0	// ET1a == ET29 -> AT4e
	nop
	jzs F5B29	// unsigned compare
	nop
// jumped away
// 				}
// else {
// 					GpioSetPin(hw->csPin, 1);
	ldx (I0)+1,NULL ; ldy (I6)+1,NULL	// 'dev' += 1
	call _GpioSetPin
	ldx (I0)-1,C0 ; sub NULL,ONES,C1	// 'dev' ==> 1 -> ET1a
// jumped away
F5B28:
	mv I0,I2	// 'dev' -> ET18
// 			if (hw->hasHwResources)
	ldx (I2)+7,NULL	// ET18 += 8
	ldx (I2)+1,NULL	// ...
	ldx (I2),A0	// ET18 ==> 8 -> ET3c
	sub A0,NULL,A0	// ET3c == (0) -> (0)
	nop
	jzs F5B3	// unsigned compare
	nop
// jumped away
// 			}
// {
// 				ReleaseHwLocksBIP(0, hw->ioMask, hw->peripMask);
	ldx (I0)+6,NULL ; ldy (I6)+1,NULL	// 'dev' += 6
	ldx (I0)+1,D0 ; and B,NULL,B
	ldx (I0)-3,D1
	ldx (I0)+1,C0
	call _ReleaseHwLocksBIP
	ldx (I0)-1,C1
// jumped away
// 				hw->hasHwResources = 0;
	ldc 0,A0	// 0 -> 1 -> ET1c
	stx A0,(I2)	// ET1c ==> ET18
F5B3:
// 	return 0;
	j F5B1
	and NULL,NULL,A0	// 0 -> 0 -> ET42
// jumped away
F5B29:
// ;
// 				}

// {
// {(*(__y volatile u_int16 *)(u_int16)(0xFCC6))=(1 << 15) | (1 << 0);
	ldc 32769,A0	// 32769 -> 1 -> ET2a
	ldc 64710,I2	// 64710 -> ET2b
	sty A0,(I2)/*V*/	// ET2a ==> ET2b
// (*(__y volatile u_int16 *)(u_int16)(0xFCA6))=(1 << 11);
	ldc 2048,A0	// 2048 -> 1 -> ET2c
	ldc 64678,I2	// 64678 -> ET2d
	j F5B28
	sty A0,(I2)/*V*/	// ET2c ==> ET2d
// jumped away
F5B26:	// (loop lvl 2)
	ldc 2,A1	// 2 -> 1 -> ET2e
	ldx (I0),I2	// 'dev' ==> ET14
	ldx (I2)+2,NULL	// ET37 += 2
	ldy (I2),A0/*V*/	// ET37 ==> ET38
	and A0,A1,A0	// ET38 and ET2e -> ET39
	nop
	jzc F5B26	// compare against zero
	nop
// jumped away
	j F5B24
	nop
// jumped away
F5B4:
// 			ObtainHwLocksBIP(0, hw->ioMask, hw->peripMask);
	ldx (I0)+1,D0 ; and B,NULL,B
	ldx (I0)-3,D1
	ldx (I0)+1,C0
	call _ObtainHwLocksBIP
	ldx (I0)-5,C1
// jumped away
// 			hw->regs->clkconfig = GetDivider(hw->maxClockKHz, 255) << 2;
	ldx (I0)+3,NULL	// 'dev' += 3
	ldx (I0)-3,C0	// 'dev' ==> 3 -> ETf
	call _GetDivider
	ldc 255,C1	// 255 -> C1
// jumped away
	add A0,A0,A0 ; ldx (I0)+7,I2	// ET10 >> (-1) -> AT12
	add A0,A0,A1 ; ldx (I2)+1,NULL	// AT12 >> (-1) -> ET13
	sty A1,(I2)/*V*/ ; sub NULL,ONES,A0	// 1 -> 1 -> ET15
// 			hw->hasHwResources = 1;
	ldx (I0)+1,NULL	// ...
	stx A0,(I0)-7	// ET15 ==> 'dev'
// 			if (hw->csPin == 0x0fffu)
	ldc 4095,A0	// 4095 -> 1 -> ET1b
	ldx (I0)-1,A1	// 'dev' ==> 1 -> ET1a
	sub A1,A0,A0	// ET1a == ET1b -> AT46
	ldc 4096,A1	// 4096 -> 1 -> ET1e
	jzs F5B8	// unsigned compare
	and NULL,NULL,A0	// 0 -> 1 -> ET1c
// jumped away
// 			}
// else {
// (*(__y volatile u_int16 *)(u_int16)(0xFC3E)) &= ~(1<<12);
	ldc 61439,A0	// 61439 -> 1 -> ET26
	ldc 64574,I2	// 64574 -> ET1f
	ldc 65535,B0	// 65535 -> 1 -> ET29
	ldy (I2),A1/*V*/ ; ldx (I0)+1,NULL	// ET1f ==> ET27
	and A1,A0,A0 ; ldx (I0)-1,A1	// ET27 and ET26 -> ET28
	sty A0,(I2)/*V*/ ; sub NULL,ONES,A0	// ET28 ==> ET1f
// 				if (hw->csPin == 0xffffu)
	sub A1,B0,A1	// ET1a == ET29 -> AT47
	nop
	jzs F5B11	// unsigned compare
	nop
// jumped away
// 				}
// else {
// 					GpioSetPin(hw->csPin, 0);
	ldx (I0)+1,NULL ; ldy (I6)+1,NULL	// 'dev' += 1
	ldx (I0),C0 ; and NULL,NULL,C1	// 'dev' ==> 1 -> ET1a
	call _GpioSetPin
	ldc F5B3,LR0
// jumped away
F5B11:
// ;
// 				}


// {
// {{(*(__y volatile u_int16 *)(u_int16)(0xFCC6))=(1 << 15) | (1 << 0);
	ldc 32769,A1	// 32769 -> 1 -> ET2a
	ldc 64710,I2	// 64710 -> ET2b
	sty A1,(I2)/*V*/ ; ldx (I0)+2,NULL	// ET2a ==> ET2b
// (*(__y volatile u_int16 *)(u_int16)(0xFCA6))=(1 << 11);
	ldc 2048,A1	// 2048 -> 1 -> ET2c
	ldc 64678,I2	// 64678 -> ET2d
	sty A1,(I2)/*V*/ ; ldx (I0),A1	// ET2c ==> ET2d
// ; if (!(hw->ioChannel &1))
	and A1,A0,A0	// ET30 and ET15 -> ET31
	sub A0,NULL,A0	// ET31 != (0) -> (0)
	ldc 2,A0
	jzc F5B15	// unsigned compare
	nop
// jumped away

// {(*(__y volatile u_int16 *)(u_int16)(0xFCC7)) = (1 << 15);
	ldc 32768,A0	// 32768 -> 1 -> ET32
	ldc 64711,I2	// 64711 -> ET33
	sty A0,(I2)/*V*/ ; ldx (I0),A1	// ET32 ==> ET33
// if (!(hw->ioChannel &2))
	ldc 2,A0	// 2 -> 1 -> ET2e
F5B15:
	and A1,A0,A0 ; ldx (I0),A1	// ET30 and ET2e -> ET34
	sub A0,NULL,A0	// ET34 != (0) -> (0)
	ldc 4,A0
	jzc F5B17	// unsigned compare
	nop
// jumped away

// {(*(__y volatile u_int16 *)(u_int16)(0xFCA7)) = (1 << 11);
	ldc 2048,A0	// 2048 -> 1 -> ET2c
	ldc 64679,I2	// 64679 -> ET35
	sty A0,(I2)/*V*/ ; ldx (I0),A1	// ET2c ==> ET35
// if (!(hw->ioChannel &4))
	ldc 4,A0	// 4 -> 1 -> ET7
F5B17:
	and A1,A0,A0	// ET30 and ET7 -> ET36
	nop
	jzc F5B3	// compare against zero
	nop
// jumped away

// {(*(__y volatile u_int16 *)(u_int16)(0xFCC7)) = (1 << 0);
	ldc 64711,I0	// 64711 -> ET33
	sub NULL,ONES,A0	// 1 -> 1 -> ET15
	j F5B3
	sty A0,(I0)/*V*/	// ET15 ==> ET33
// jumped away
F5B8:
// 			}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFC44)) = 0;
	ldc 64580,I0	// 64580 -> ET1d
	sty A0,(I0)-6/*V*/	// ET1c ==> ET1d
// (*(__y volatile u_int16 *)(u_int16)(0xFC3E)) |=(1<<12);
	ldy (I0),A0/*V*/	// ET1f ==> ET20
	or A0,A1,A0	// ET20 or ET1e -> ET21
	ldc 65534,A1	// 65534 -> 1 -> ET22
	sty A0,(I0)/*V*/	// ET21 ==> ET1f
// (*(__y volatile u_int16 *)(u_int16)(0xFC40)) &= ~(1<<0);
	ldc 64576,I0	// 64576 -> ET23
	ldy (I0),A0/*V*/	// ET23 ==> ET24
	and A0,A1,A0	// ET24 and ET22 -> ET25
	j F5B3
	sty A0,(I0)/*V*/	// ET25 ==> ET23
// jumped away

//_____________________________________________________________
//
	.sect data_x,devHwSpiconst_x	// 51 words
	.export _devHwSpiDefaults
_devHwSpiDefaults:
	.word 0, _DevHwSpiIdentify, _DevHwSpiCreate, _DevHwSpiDelete, _DevHwSpiIoctl, _DevHwSpiRead, _DevHwSpiWrite, _CommonErrorResultFunction
	.word _CommonErrorResultFunction
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
String_1:
	.word "Hardware SPI Port"

	.zero 1

//_____________________________________________________________
//
	.sect data_x,devHwSpiinit_x	// 1 word
_deviceName:
	.word String_1

	.end
