
//_____________________________________________________________
//
	.sect code,DevSpiFlashCreate	// 53 words
	.export _DevSpiFlashCreate
_DevSpiFlashCreate:
	ldc 2064,A0	// 2064 -> A0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2 ; and NULL,NULL,A1	// I0 -> 'dev'
	mv I2,I3	// 0 -> A1
	ldc _c,I0	// I0
// hw
// (&c, 0, sizeof(c));
	ldx (I3)+7,NULL	// 'hw' += 11
	call _memset
	ldx (I3)+4,NULL	// ...
// jumped away
	mv I2,I0	// 'dev' -> I0
	ldc 33,A0	// 33 -> A0
// 	memcpyYX(dev, &devSpiFlashDefaults, sizeof(struct device_descriptor));
	call _memcpyYX
	ldc _devSpiFlashDefaults,I1	// I1
// jumped away
	ldc ___nextDeviceInstance,I0	// ET19
	ldc 256,B0	// 256 -> 2 -> B0
	mv I2,I1 ; and NULL,NULL,B1	// 0 -> ETa
	ldx (I4)-2,NULL ; ldy (I1)+7,NULL	// I4 += -2
// 	hw->ph = (struct device_descriptor *)name;
	ldx (I4)-1,A0 ; ldy (I1)+3,NULL	// unspill 'name' from #0
	stx A0,(I3)+1 ; and NULL,NULL,A0	// 'name' ==> 'hw'
// 	hw->currentWriteBuffer = 0;
	stx A0,(I3)+1 ; ldy (I6)+1,NULL	// ETa ==> 'hw'
// 	hw->currentWriteBlock = 0;
	stx A0,(I3)+1	// ETd ==> 'hw'
// 	hw->reservedSectors = extraInfo;
	ldx (I4)+3,A0	// unspill 'extraInfo' from #0
	stx A0,(I3)+1 ; add A0,A0,A0	// 'extraInfo' ==> 'hw'
// 	hw->totalBlocks = (extraInfo*2) -(2*65536/512);
	sub A0,B0,A0	// ET13 - ET14 -> ET15
	stx A0,(I3)	// ET16 ==> 'hw'
// 	dev->deviceInstance = __nextDeviceInstance++;
	ldx (I0),A0/*V*/	// ET19 ==> ET1a
	sub A0,ONES,A1	// ET1a - (-1) -> ET1b
	stx A1,(I0)/*V*/	// ET1b ==> ET19
	mv I2,I0	// 0 -> 0 -> ET4
	stx A0,(I1)-6	// ET1a ==> ET1d
// 	dev->flags =(1 << 0) |(1 << 1) |(1 << 4) |(1 << 5) |(1 << 6);
	ldc 115,A0	// 115 -> 1 -> ET1e
	stx A0,(I2) ; and NULL,NULL,A0	// ET1e ==> 'dev'
// 	return dev->Ioctl(dev,5, 0);
	stx A0,(I6)+1	// ET4
	ldc 5,A0	// 5 -> 0 -> ET1f
	stx A0,(I6)	// ET1f
	ldx (I1),A0	// ET1d ==> 4 -> ET21
	mv A0,LR0
	jr
	ldc lo(F0B5),LR0	// (return address)
// jumped away
F0B5:
	ldx (I6)-2,NULL	// I6 += -2
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevSpiFlashDelete	// 3 words
	.export _DevSpiFlashDelete
_DevSpiFlashDelete:
//   return 0;
	and NULL,NULL,A0	// 0 -> 0 -> ET0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,SingleCycleCommand	// 42 words
	.export _SingleCycleCommand
_SingleCycleCommand:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx I1,(I6)+1 ; sty I2,(I6)
	mv I0,I1 ; and NULL,NULL,A1	// I0 -> 'ph'
	mv I1,I0 ; sub NULL,ONES,A0	// 0 -> 0 -> ET0
	mv I1,I2	// 1 -> 0 -> ET1
// 	ph->Ioctl(ph,1, 0);
	stx A1,(I6)+1 ; ldy (I2)+4,NULL	// ET0
	stx A0,(I6)	// ET1
	ldx (I2),A0	// ET3 ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F2B3),LR0	// (return address)
// jumped away
F2B3:
	ldx (I4)-2,NULL ; ldy (I6)-1,NULL	// I4 += -2
// 	ph->Write(ph,0, cmd, 1);
	mv I1,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET6
	stx A0,(I6)+1 ; ldy (I1)+6,NULL	// ET6
	ldx (I4)+2,A0	// unspill 'cmd' from #0
	stx A0,(I6)+1	// 'cmd'
	stx A1,(I6)	// ET0
	ldx (I1)-6,A0	// 'ph' ==> 6 -> ET9
	mv A0,LR0
	jr
	ldc lo(F2B4),LR0	// (return address)
// jumped away
F2B4:
	mv I1,I0	// 'ph' -> I0
	ldc 2,A0	// 2 -> 0 -> ETb
	ldx (I6)-2,NULL	// I6 += 1
// 	ph->Ioctl(ph,2, 0);
	stx A1,(I6)+1	// ET0
	stx A0,(I6)	// ETb
	ldx (I2),A0	// ET3 ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F2B5),LR0	// (return address)
// jumped away
F2B5:
	ldx (I6)-2,NULL	// I6 += -2
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,MultipleCycleCommand	// 49 words
	.export _MultipleCycleCommand
_MultipleCycleCommand:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx I1,(I6)+1 ; sty I2,(I6)
	mv I0,I1 ; and NULL,NULL,A1	// I0 -> 'ph'
	mv I1,I0 ; sub NULL,ONES,A0	// 0 -> 0 -> ET0
	mv I1,I2	// 1 -> 0 -> ET1
// 	ph->Ioctl(ph,1, 0);
	stx A1,(I6)+1 ; ldy (I2)+4,NULL	// ET0
	stx A0,(I6)	// ET1
	ldx (I2),A0	// ET3 ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F3B3),LR0	// (return address)
// jumped away
F3B3:
	mv I1,I0	// 0 -> 1 -> ET6
	ldx (I4)-3,NULL ; ldy (I6)-1,NULL	// I4 += -3
// 	ph->Write(ph, cmd, 0, cycles);
	ldx (I4)+1,A0 ; ldy (I1)+6,NULL	// unspill 'cycles' from #0
	stx A0,(I6)+1 ; and NULL,NULL,A0	// 'cycles'
	stx A0,(I6)+1	// ET6
	ldx (I4)+2,A0	// unspill 'cmd' from #0
	stx A0,(I6)	// 'cmd'
	ldx (I1)-6,A0	// 'ph' ==> 6 -> ET9
	mv A0,LR0
	jr
	ldc lo(F3B4),LR0	// (return address)
// jumped away
F3B4:
	ldx (I4)-4,NULL ; ldy (I6)-3,NULL	// I4 += -4
// 	if (endFrame)
	ldx (I4)+4,A0	// unspill 'endFrame' from #0
	sub A0,NULL,A0	// 'endFrame' == (0) -> (0)
	nop
	jzs F3B1	// unsigned compare
	nop
// jumped away
	mv I1,I0	// 'ph' -> I0
	ldc 2,A0	// 2 -> 0 -> ETb
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// {
// 		ph->Ioctl(ph,2, 0);
	stx A1,(I6)+1	// ET0
	stx A0,(I6)	// ETb
	ldx (I2),A0	// ET3 ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F3B7),LR0	// (return address)
// jumped away
F3B7:
	ldx (I6)-2,NULL	// I6 += -2
F3B1:
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,SpiFlashWaitStatus	// 57 words
	.export _SpiFlashWaitStatus
_SpiFlashWaitStatus:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx I2,(I6)+1 ; and NULL,NULL,A1
	mv I0,I2 ; sub NULL,ONES,A0	// I0 -> 'ph'
	mv I2,I0	// 0 -> 0 -> ET0
// ->Ioctl(ph,1, 0);
	stx A1,(I6)+1 ; ldy (I2)+4,NULL	// ET0
	stx A0,(I6)	// ET1
	ldx (I2)-4,A0	// 'ph' ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F4B3),LR0	// (return address)
// jumped away
F4B3:
	mv I2,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET6
	ldx (I6)-1,NULL ; ldy (I2)+6,NULL	// I6 += 1
// 	ph->Write(ph,0,0x05, 1);
	stx A0,(I6)+1	// ET6
	ldc 5,A0	// 5 -> 1 -> ET7
	stx A0,(I6)+1	// ET7
	stx A1,(I6)	// ET0
	ldx (I2)-6,A0	// 'ph' ==> 6 -> ETa
	mv A0,LR0
	jr
	ldc lo(F4B4),LR0	// (return address)
// jumped away
F4B4:
	and NULL,NULL,B1 ; ldx (I6)-2,NULL	// I6 += -3
	mv I2,I0 ; and NULL,NULL,B0	// 0 -> 1 -> ETc
// while (status & 1);
	sub NULL,ONES,C0	// 1 -> 1 -> ET6
F4B5:	// (loop lvl 2)
	stx B0,(I6)+1 ; ldy (I2)+5,NULL
// 	}
// 	do {
// 		status = ph->Read(ph,0,0,0);
	stx B0,(I6)+1	// ETc
	stx B1,(I6)	// ET0
	ldx (I2)-5,A0	// 'ph' ==> 5 -> ETe
	mv A0,LR0
	jr
	ldc lo(F4B8),LR0	// (return address)
// jumped away
F4B8:	// (loop lvl 2)
	ldx (I6)-2,NULL ; add A0,NULL,A1	// I6 += -3
	and A0,C0,A0 ; mv I2,I0	// 'status' and ET6 -> ET10
	nop
	jzc F4B5	// compare against zero
	nop
// jumped away
// 	ph->Ioctl(ph,2, 0);
	and NULL,NULL,A0 ; mv I2,I0	// 0 -> 0 -> ET0
	stx A0,(I6)+1 ; ldy (I2)+4,NULL	// ET0
	ldc 2,A0	// 2 -> 0 -> ET11
	stx A0,(I6)	// ET11
	ldx (I2),A0	// 'ph' ==> 4 -> ET4
	mv A0,LR0
	jr
	ldc lo(F4B9),LR0	// (return address)
// jumped away
F4B9:
	ldx (I6)-2,NULL ; add A1,NULL,A0	// I6 += -2
// 	return status;
	ldx (I6)-1,I2	// 'status' returns via A0
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,GetREMS	// 43 words
	.export _GetREMS
_GetREMS:
	ldx (I6)+1,NULL ; and NULL,NULL,A0	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc String_1,B0	// ET2
	ldc 4,A1	// 4 -> 1 -> ET1
	stx I2,(I6)+1 ; ldy (I4)+1,NULL
	mv I0,I2	// I0 -> 'ph'
	mv I2,I0	// 0 -> 1 -> ET0
// result
	stx A0,(I4)-1
// (ph, "\p\x90\x00\x00\x00", 4,0);
	stx A0,(I6)+1	// ET0
	stx A1,(I6)+1	// ET1
	call _MultipleCycleCommand
	stx B0,(I6)	// ET2
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldc 2,B0	// 2 -> 1 -> ET3
	ldy (I6)-2,NULL ; ldx (I4)+1,NULL	// I4 += 1
// 	ph->Read(ph, &result, 0, 2);
	stx B0,(I6)+1 ; ldy (I2)+5,NULL	// ET3
	stx A0,(I6)+1	// ET0
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET4
	ldx (I2)-5,A0	// 'ph' ==> 5 -> ET7
	mv A0,LR0
	jr
	ldc lo(F5B4),LR0	// (return address)
// jumped away
F5B4:
	mv I2,I0 ; and NULL,NULL,A0	// 0 -> 0 -> ET9
	ldx (I6)-2,NULL ; ldy (I2)+4,NULL	// I6 += 1
// 	ph->Ioctl(ph,2, 0);
	stx A0,(I6)+1	// ET9
	ldc 2,A0	// 2 -> 0 -> ETa
	stx A0,(I6)	// ETa
	ldx (I2),A0	// 'ph' ==> 4 -> ETc
	mv A0,LR0
	jr
	ldc lo(F5B5),LR0	// (return address)
// jumped away
F5B5:
	ldx (I4)+1,NULL ; ldy (I6)-2,NULL	// I4 += 1
// 	return result;
	ldx (I4)-1,A0	// I4 ==> 'result'
	ldx (I6)-1,I2
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,FlashUnprotect	// 33 words
	.export _FlashUnprotect
_FlashUnprotect:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 6,A1	// 6 -> 1 -> ET0
	stx I2,(I6)+1
	mv I0,I2	// I0 -> 'ph'
	mv I2,I0	// 'ph' -> I0
// 	SingleCycleCommand(ph,0x06);
	call _SingleCycleCommand
	stx A1,(I6)	// ET0
// jumped away
// 	MultipleCycleCommand(ph, "\p\x01\x02", 2,1);
	sub NULL,ONES,A0 ; mv I2,I0	// 1 -> 1 -> ET1
	stx A0,(I6)+1	// ET1
	ldc 2,A0	// 2 -> 1 -> ET2
	stx A0,(I6)+1	// ET2
	ldc String_2,A0	// ET3
	call _MultipleCycleCommand
	stx A0,(I6)	// ET3
// jumped away
	mv I2,I0	// 'ph' -> I0
// 	SpiFlashWaitStatus(ph);
	call _SpiFlashWaitStatus
	ldx (I6)-3,NULL	// I6 += -3
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldx (I6)+1,NULL	// I6 += 1
// 	SingleCycleCommand(ph,0x06);
	call _SingleCycleCommand
	stx A1,(I6)	// ET0
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,I2
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevSpiFlashIdentify	// 17 words
	.export _DevSpiFlashIdentify
_DevSpiFlashIdentify:
	ldx (I6)+1,NULL ; ldy (I0)+7,NULL	// I6 += 1
	stx LR0,(I6)+1 ; ldy (I0)+4,NULL
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
// ddev
// hw
// ph
// rems
	call _GetREMS
	ldx (I0),I0	// 'dev' ==> 'ph'
// jumped away
// (s,"SPI Flash %04x",rems);
	stx A0,(I6)+1	// 'rems'
	ldc spiflash_3,A0	// ET5
	stx A0,(I6)+1	// ET5
	ldc _s7b9e58,A0	// ET6
	call _sprintf
	stx A0,(I6)	// ET6
// jumped away
// 	return s;
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	ldc _s7b9e58,A0	// ET6
// jumped away

//_____________________________________________________________
//
	.sect code,PrintCache	// 20 words
	.export _PrintCache
_PrintCache:
	ldx (I6)+1,NULL	// I6 += 1
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; and NULL,NULL,A0	// 0 -> 'i'
	ldc _c,B0	// ET2
	sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx I0,(I6) ; sty LC,(I6)+1
	ldc 7,LC	// loop 8 iterations
	stx LS,(I6) ; sty LE,(I6)
// (i=0; i< 8; i++)
	loop LC,F8B4-1
	ldc 258,A1	// 258 -> 1 -> ET3
//loop resumes
// 	}
// {
// 		if (c.ca[i].flags)
	muluu A0,A1	// 'i' * ET3 -> P
	sub A0,ONES,A0	// 'i' - (-1) -> 'i'
//	(0 nop's needed)
// loop end
F8B4:	// loop exit
	ldy (I6),LE ; ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,IsInCache	// 40 words
	.export _IsInCache
_IsInCache:
	ldx (I6)+2,NULL ; and NULL,NULL,A0	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	ldc 8,B1	// 8 -> 1 -> ET1
	ldc 258,C0	// 258 -> 1 -> ET3
	stx C1,(I6) ; sty D0,(I6)+1
	ldc _c,C1	// ET2
	stx D1,(I6) ; sty I0,(I6)
// (i=0; i< 8; i++)
	ldx (I4)-2,NULL ; sub NULL,ONES,B0	// 0 -> 'i'
	j F9B6
	ldx (I4)+2,A1	// 1 -> 1 -> ET7
// jumped away
F9B3:	// (loop lvl 2)
// 	}
// {
// 		if ((c.ca[i].flags) && (c.ca[i].sector == sector))
	muluu A0,C0	// 'i' * ET3 -> P
	add NULL,P,D	// P -> ATd
	add C1,D0,D0	// ET2 + ET4 -> AT13
	mv D0,I0	// AT13 -> ET5
	ldx (I0)+1,D0	// ET5 ==> ET6
	sub D0,NULL,D0	// ET6 == (0) -> (0)
	ldx (I0),D0	// ET5 ==> ET9
	jzs F9B8	// unsigned compare
	sub D0,A1,D0	// ET9 == 'sector' -> AT12
// jumped away
	nop
	jzs F9B7	// unsigned compare
	nop
// jumped away
F9B8:	// (loop lvl 2)
	sub A0,ONES,A0	// 'i' - (-1) -> 'i'
F9B6:	// (loop lvl 2)
	sub A0,B1,D0	// 'i' < ET1 -> AT10
	nop
	jcc F9B3	// unsigned compare
	nop
// jumped away
// 	return 0;
	j F9B1
	and NULL,NULL,A0	// 0 -> 1 -> ET0
// jumped away
F9B7:
// 		}
// {
// 			return 1;
	add B0,NULL,A0	// ET7 returns via A0
F9B1:
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,Erase4K	// 45 words
	.export _Erase4K
_Erase4K:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 6,A0	// 6 -> 1 -> ET0
	stx B0,(I6) ; sty B1,(I6)+1
	stx I2,(I6)+1
	mv I0,I2	// I0 -> 'ph'
	mv I2,I0	// 'ph' -> I0
// (ph,0x06);
	call _SingleCycleCommand
	stx A0,(I6)	// ET0
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldc 48,A0	// 48 -> 1 -> ET1
// 	SingleCycleCommand(ph,0x30);
	call _SingleCycleCommand
	stx A0,(I6)	// I6 += 1
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldc -7,A0	// -7 -> 0 -> ET3
	ldc 8192,B0	// 8192 -> 3 -> B0
// 	FlashUnprotect(ph);
	call _FlashUnprotect
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
	ldc 0,C2	// clear guard bits
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
// 	cmd[0] = (firstBlock>>7) | (0x20 << 8);
	ashl C,A0,A ; mv I2,I0	// 'firstBlock' <- ET3 -> ET4
	or A0,B0,A0	// ET4 or ET5 -> ET6
	stx A0,(I4)+1
// 	cmd[1] = (firstBlock<<9);
	ldc 9,A0	// 9 -> 0 -> ET9
	ashl C,A0,A	// 'firstBlock' << ET9 -> ETa
	stx A0,(I4)-1 ; sub NULL,ONES,A0
// 	MultipleCycleCommand(ph, cmd, 4,1);
	stx A0,(I6)+1	// ETe
	ldc 4,A0	// 4 -> 1 -> ETf
	stx A0,(I6)+1	// ETf
	call _MultipleCycleCommand
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET8
// jumped away
	mv I2,I0	// 'ph' -> I0
// 	SpiFlashWaitStatus(ph);
	call _SpiFlashWaitStatus
	ldx (I6)-3,NULL	// I6 += -3
// jumped away
	ldx (I6)-1,I2
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,ProgramSector	// 90 words
	.export _ProgramSector
_ProgramSector:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -7,A0	// -7 -> 0 -> ET1
	stx B0,(I6) ; sty B1,(I6)+1
	stx D0,(I6) ; sty I1,(I6)+1
	ldc 4,D0	// 4 -> 1 -> ETd
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2	// I0 -> 'ph'
// (ph);
	call _FlashUnprotect
	mv I2,I0	// 'ph' -> I0
// jumped away
	ldc 0,C2	// clear guard bits
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
// 	cmd[0] = (firstBlock>>7) | (0x02 << 8);
	mv I2,I0 ; ashl C,A0,B	// 'firstBlock' <- ET1 -> ET2
	ldc 512,A0	// 512 -> 3 -> A0
	or B0,A0,A0	// ET2 or ET3 -> ET4
	stx A0,(I4)+1
// 	cmd[1] = (firstBlock<<9);
	ldc 9,A0	// 9 -> 0 -> ET7
	ashl C,A0,A	// 'firstBlock' << ET7 -> ET8
	stx A0,(I4)-1 ; and NULL,NULL,B1
// 	MultipleCycleCommand(ph, cmd, 4,0);
	stx B1,(I6)+1	// ETc
	stx D0,(I6)+1	// ETd
	call _MultipleCycleCommand
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET6
// jumped away
	mv I2,I3	// 'ph' -> ET10
	mv I2,I0	// 'ph' -> I0
	ldc 256,B0	// 256 -> 1 -> ETe
	ldy (I6)-2,NULL ; ldx (I4)-2,NULL	// I4 += -2
// 	ph->Write(ph, data, 0, 256);
	stx B0,(I6)+1 ; ldy (I3)+6,NULL	// ETe
	stx B1,(I6)+1	// ETc
	ldx (I4)+2,A1	// unspill 'data' from #-2
	stx A1,(I6)	// 'data'
	ldx (I3),A0	// ET10 ==> 6 -> ET11
	mv A0,LR0
	jr
	ldc lo(F11B5),LR0	// (return address)
// jumped away
F11B5:
	mv I2,I1 ; and NULL,NULL,C1	// 'ph' -> ET15
	ldc 2,C0	// 2 -> 0 -> ET14
	mv I2,I0	// 0 -> 0 -> ET13
	ldx (I6)-2,NULL ; ldy (I1)+4,NULL	// I6 += 1
// 	ph->Ioctl(ph,2, 0);
	stx C1,(I6)+1	// ET13
	stx C0,(I6)	// ET14
	ldx (I1),A0	// ET15 ==> 4 -> ET16
	mv A0,LR0
	jr
	ldc lo(F11B6),LR0	// (return address)
// jumped away
F11B6:
	mv I2,I0	// 'ph' -> I0
// 	SpiFlashWaitStatus(ph);
	call _SpiFlashWaitStatus
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
// 	FlashUnprotect(ph);
	call _FlashUnprotect
	mv I2,I0	// 'ph' -> I0
// jumped away
	ldx (I4)+2,NULL ; ldy (I6)+1,NULL	// I4 += 2
// 	cmd[1] |= (1 << 8);
	ldx (I4),A0	// I4 ==> 1 -> ET19
	or A0,B0,A0 ; mv I2,I0	// ET19 or ETe -> ET1a
	stx A0,(I4)-1
// 	MultipleCycleCommand(ph, cmd, 4,0);
	stx B1,(I6)+1	// ETc
	stx D0,(I6)+1	// ETd
	call _MultipleCycleCommand
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET6
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldx (I6)-2,NULL	// I6 += 1
// 	ph->Write(ph, data, 256, 256);
	stx B0,(I6)+1	// ETe
	stx B0,(I6)+1	// ETe
	stx A1,(I6)	// 'data'
	ldx (I3),A0	// ET10 ==> 6 -> ET11
	mv A0,LR0
	jr
	ldc lo(F11B10),LR0	// (return address)
// jumped away
F11B10:
	mv I2,I0	// 'ph' -> I0
	ldx (I6)-2,NULL	// I6 += 1
// 	ph->Ioctl(ph,2, 0);
	stx C1,(I6)+1	// ET13
	stx C0,(I6)	// ET14
	ldx (I1),A0	// ET15 ==> 4 -> ET16
	mv A0,LR0
	jr
	ldc lo(F11B11),LR0	// (return address)
// jumped away
F11B11:
	mv I2,I0	// 'ph' -> I0
// 	SpiFlashWaitStatus(ph);
	call _SpiFlashWaitStatus
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,Flush4K2	// 66 words
	.export _Flush4K2
_Flush4K2:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I0,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty LC,(I6)+1
	stx LS,(I6) ; sty LE,(I6)
	ldx (I4)-3,NULL ; and A1,NULL,A1	// I4 += -3
	ldx (I4)+1,D1	// unspill 'sector' from #-3
// (ph,sector);
	add D1,NULL,A0 ; ldx (I4)+2,I2	// 'sector' msw ET0
	call _Erase4K
	mv I2,I0 ; add A,NULL,C	// 'ph' -> I0
// jumped away
// 	for (j=0; j<8; j++)
	ldc 0,A0	// 0 -> 'j'
F12B7:	// (loop lvl 2)
	ldc 8,A1	// 8 -> ET2
	sub A0,A1,A1	// 'j' >= ET2 -> AT15
	ldc 7,LC	// loop 8 iterations
	jcs F12B5	// unsigned compare
	and B1,NULL,B1
// jumped away
// 	}
// {
// 		for (i=0; i< 8; i++)
	ldc 0,A1	// 0 -> 'i'
	add D1,A0,D0	// 'sector' + 'j' -> ETb
	loop LC,F12B9-1
	mv D0,B0	// ETb msw ETe
//loop resumes
// 		}
// {
// 			if (c.ca[i].flags && (c.ca[i].sector == sector+j))
	ldc 258,C0	// 258 -> ET4
	muluu A1,C0	// 'i' * ET4 -> P
	add NULL,P,C	// P -> AT17
	mv C0,C1	// AT17 lsw ET5
	ldc _c,C0	// ET3
	add C0,C1,C0	// ET3 + ET5 -> AT1a
	mv C0,I1	// AT1a -> ET6
	ldx (I1)+1,C0	// ET6 ==> ET7
	sub C0,NULL,C0	// ET7 == (0) -> (0)
	ldx (I1)-1,C0	// ET6 ==> ETa
	jzs F12B13	// unsigned compare
	sub C0,D0,C0	// ETa == ETb -> AT19
// jumped away
	nop
	jzs F12B12	// unsigned compare
	nop
// jumped away
F12B13:	// (loop lvl 3)
	sub A1,ONES,A1	// 'i' - (-1) -> 'i'
//	(0 nop's needed)
// loop end
F12B9:	// loop exit
	j F12B7
	sub A0,ONES,A0	// 'j' - (-1) -> 'j'
// jumped away
F12B12:	// (loop lvl 3)
	mv I2,I0 ; add B,NULL,C	// 'ph' -> I0
	ldx (I6)+1,NULL ; ldy (I1)+2,NULL	// I6 += 1
// 			}
// {
// 				ProgramSector(ph,sector+j,c.ca[i].data);
	call _ProgramSector
	stx I1,(I6) ; ldy (I1)-2,NULL	// ET6
// jumped away
	and NULL,NULL,C0 ; ldy (I6)-1,NULL	// I6 += -1
// 				c.ca[i].flags = 0;
	j F12B13
	stx C0,(I1)	// ET1 ==> ET6
// jumped away
F12B5:
// 	cacheIsDirty = 0;
	ldc _cacheIsDirty,I0	// ET13
	ldy (I6),LE ; and NULL,NULL,A0	// 0 -> 1 -> ET1
	stx A0,(I0)/*V*/	// ET1 ==> ET13
	ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,CacheCheck	// 69 words
	.export _CacheCheck
_CacheCheck:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	ldc 258,C1	// 258 -> 1 -> ET3
	stx D0,(I6) ; sty D1,(I6)+1
	ldc _c,D0	// ET2
	ldc 8,D1	// 8 -> 1 -> ET1
	stx I0,(I6) ; sty LC,(I6)+1
	ldc 7,LC	// loop 8 iterations
	stx LS,(I6) ; sty LE,(I6)
// (i=0; i< 8; i++)
	ldx (I4)-2,NULL ; and NULL,NULL,B0	// 0 -> 'i'
	loop LC,F13B4-1
	ldx (I4)+2,C0	// unspill 'ph' from #-2
//loop resumes
// 	}
// {
// 		if ((c.ca[i].flags) && ((c.ca[i].sector & 0x7) == 0))
	muluu B0,C1	// 'i' * ET3 -> P
	add NULL,P,A	// P -> AT14
	add D0,A0,A0	// ET2 + ET4 -> AT1d
	mv A0,I0	// AT1d -> ET5
	ldx (I0)+1,A0	// ET5 ==> ET6
	sub A0,NULL,A0 ; ldx (I0),A1	// ET6 == (0) -> (0)
	ldc 7,A0	// 7 -> ETa
	jzs F13B8	// unsigned compare
	and A1,A0,A0	// ET9 and ETa -> ETb
// jumped away
	nop
	jzc F13B8	// compare against zero
	nop
// jumped away
// 		}
// {
// 			for (j=0; j<8; j++)
	and NULL,NULL,A1 ; ldx (I4)+1,NULL	// 0 -> 'j'
	stx A1,(I4) ; muluu B0,C1	// AT21 spills to #1
	add NULL,P,A	// P -> AT1c
	j F13B13
	ldx (I4)-1,A1 ; add D0,A0,B1	// ET2 + ET4 -> ET5
// jumped away
F13B10:	// (loop lvl 3)
	mv A0,I0	// AT1e -> ET8
// 			}
// {
// 				if (!IsInCache(c.ca[i].sector + j))
	ldx (I0),A0	// ET8 ==> ET9
	add A0,A1,A0	// ET9 + 'j' -> ETc
	call _IsInCache
	stx A0,(I6)	// ETc
// jumped away
	sub A0,NULL,A0 ; ldx (I6)-1,NULL	// I6 += -1
	nop
	jzs F13B8	// unsigned compare
	sub A1,ONES,A1	// 'j' - (-1) -> 'j'
// jumped away
F13B13:	// (loop lvl 3)
	sub A1,D1,A0 ; ldx (I6)+1,NULL	// 'j' < ET1 -> AT19
	nop
	jcc F13B10	// unsigned compare
	sub B1,ONES,A0	// I6 += 1
// jumped away
	muluu B0,C1	// I6 += 1
// 			Flush4K2(ph, c.ca[i].sector);
	add NULL,P,A	// P -> AT18
	add D0,A0,A0	// ET2 + ET4 -> ET5
	sub A0,ONES,A0	// ET5 - (-1) -> AT1f
	mv A0,I0	// AT1f -> ET8
	ldx (I0),A0	// ET8 ==> ET9
	stx A0,(I6)+1	// ET9
	call _Flush4K2
	stx C0,(I6)	// 'ph'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
// 			non_continuous:
F13B8:	// (loop lvl 2)
	sub B0,ONES,B0	// 'i' - (-1) -> 'i'
//	(0 nop's needed)
// loop end
F13B4:	// loop exit
	ldy (I6),LE ; ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,BlockRead	// 51 words
	.export _BlockRead
_BlockRead:
	ldc 0,C2	// clear guard bits
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -7,A0	// -7 -> 0 -> ET1
	stx B0,(I6) ; sty B1,(I6)+1
	ldc 768,B0	// 768 -> 3 -> B0
	stx I2,(I6)+1 ; ldy (I4)+1,NULL
	mv I0,I2 ; and NULL,NULL,B1	// I0 -> 'ph'
// [0] = (firstBlock>>7) | (0x03 << 8);
	ashl C,A0,A ; mv I2,I0	// 'firstBlock' <- ET1 -> ET2
	or A0,B0,A0	// ET2 or ET3 -> ET4
	stx A0,(I4)+1
// 	cmd[1] = (firstBlock<<9);
	ldc 9,A0	// 9 -> 0 -> ET7
	ashl C,A0,A	// 'firstBlock' << ET7 -> ET8
	ldc 4,A1	// 4 -> 1 -> ETd
	stx A0,(I4)-1 ; and NULL,NULL,A0
// 	MultipleCycleCommand(ph, cmd, 4,0);
	stx A0,(I6)+1	// ETc
	stx A1,(I6)+1	// ETd
	call _MultipleCycleCommand
	stx I4,(I6) ; ldy (I4)-1,NULL	// ET6
// jumped away
	mv I2,I0	// 'ph' -> I0
	ldc 512,B0	// 512 -> 1 -> ETe
	ldy (I6)-2,NULL ; ldx (I4)-2,NULL	// I4 += -2
// 	ph->Read(ph, data, 0, 512);
	stx B0,(I6)+1 ; ldy (I2)+5,NULL	// ETe
	stx A0,(I6)+1	// ETc
	ldx (I4)+2,A0	// unspill 'data' from #0
	stx A0,(I6)	// 'data'
	ldx (I2)-5,A0	// 'ph' ==> 5 -> ET11
	mv A0,LR0
	jr
	ldc lo(F14B4),LR0	// (return address)
// jumped away
F14B4:
	mv I2,I0 ; and NULL,NULL,A0	// 0 -> 0 -> ET13
	ldx (I6)-2,NULL ; ldy (I2)+4,NULL	// I6 += 1
// 	ph->Ioctl(ph,2, 0);
	stx A0,(I6)+1	// ET13
	ldc 2,A0	// 2 -> 0 -> ET14
	stx A0,(I6)	// ET14
	ldx (I2),A0	// 'ph' ==> 4 -> ET16
	mv A0,LR0
	jr
	ldc lo(F14B5),LR0	// (return address)
// jumped away
F14B5:
	ldx (I6)-2,NULL	// I6 += -2
	ldx (I6)-1,I2
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,FFlush	// 62 words
	.export _FFlush
_FFlush:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty I0,(I6)+1
	ldc _cacheIsDirty,I0	// ET0
	stx I1,(I6) ; sty I2,(I6)+1
	stx I3,(I6) ; sty LC,(I6)+1
	stx LS,(I6) ; sty LE,(I6)
// (cacheIsDirty)
	ldx (I0),A0/*V*/ ; ldy (I4)-2,NULL	// ET0 ==> 'cacheIsDirty'
	sub A0,NULL,A0	// 'cacheIsDirty' != (0) -> (0)
	ldc _currentSectorInCache,I3
	jzc F15B3	// unsigned compare
	ldc 258,B1	// I4 += -2
// jumped away
	ldx (I4)+2,I1	// unspill 'ph' from #-2
F15B4:
	ldc _cacheIsDirty,I0	// ET0
	ldx (I6)+1,NULL	// I6 += 1
// 	CacheCheck(ph);
	call _CacheCheck
	stx I1,(I6)	// 'ph'
// jumped away
	ldx (I6)-1,NULL ; and NULL,NULL,A0	// I6 += -1
// 	cacheIsDirty = 0;
	ldy (I6),LE ; stx A0,(I0)/*V*/	// 0 -> 1 -> ET1
	ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 258,B1	// 258 -> 1 -> ET4
	ldc _currentSectorInCache,I3	// ET8
	ldx (I4)-2,NULL
F15B3:
	ldc 7,LC	// loop 8 iterations
	ldc _c,B0	// ET3
	ldx (I4)+2,I1 ; and NULL,NULL,A0
// 	}
// {
// 		for (i=0; i<8; i++)
	loop LC,F15B6-1
	sub NULL,ONES,A1	// 1 -> 1 -> ETa
//loop resumes
// 		}
// {
// 			if (c.ca[i].flags == 0)
	muluu A0,B1	// 'i' * ET4 -> P
	add NULL,P,C	// P -> AT14
	add B0,C0,C0	// ET3 + ET5 -> AT16
	mv C0,I2	// AT16 -> ET6
	ldx (I2),C0	// ET6 ==> ET7
	sub C0,NULL,C0	// ET7 != (0) -> (0)
	nop
	jzc F15B10	// unsigned compare
	nop
// jumped away
	ldx (I3),C0/*V*/ ; ldy (I6)+1,NULL	// I6 += 1
// 			}
// {
// 				c.ca[i].sector = currentSectorInCache+i;
	add C0,A0,C0 ; mv I2,I0	// 'currentSectorInCache' + 'i' -> ET9
	ldx (I0)+1,NULL ; ldy (I2)+2,NULL	// ETb += 1
	stx C0,(I0) ; and C1,NULL,C1	// ET9 ==> ETb
// 				BlockRead(ph,c.ca[i].sector,c.ca[i].data);
	stx I2,(I6) ; ldy (I2)-2,NULL	// ET6
	call _BlockRead
	mv I1,I0
// jumped away
	ldy (I6)-1,NULL ; stx A1,(I2)	// I6 += -1
// 				c.ca[i].flags = 1;
F15B10:	// (loop lvl 2)
	sub A0,ONES,A0	// 'i' - (-1) -> 'i'
//	(0 nop's needed)
// loop end
F15B6:	// loop exit
	j F15B4
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,PutCacheBlock	// 54 words
	.export _PutCacheBlock
_PutCacheBlock:
	ldc 65528,A0	// 65528 -> 1 -> ET0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty I0,(I6)+1
	ldc _currentSectorInCache,I0	// ET2
	stx I1,(I6)+1 ; sty I2,(I6)
	ldx (I4)-3,NULL	// I4 += -3
// (currentSectorInCache != (sector & ~7))
	ldx (I4)+1,B1	// unspill 'sector' from #-3
	and B1,A0,B0 ; ldx (I0),A0/*V*/	// 'sector' and ET0 -> ET1
	sub A0,B0,A1	// 'currentSectorInCache' != ET1 -> AT12
	nop
	jzc F16B3	// unsigned compare
	nop
// jumped away
	ldy (I6)-1,NULL ; ldx (I4)+2,A1
F16B4:
	ldc 7,A0	// 7 -> 1 -> ET4
	and B1,A0,B0 ; ldy (I4)-4,NULL	// I4 += -4
// 	i = sector & 7;
// 	c.ca[i].sector = sector;
	ldc 258,A0	// 258 -> 1 -> ET7
	muluu B0,A0	// 'i' * ET7 -> P
	ldc _c,A0	// ET6
	add NULL,P,C	// P -> AT14
	add A0,C0,A0	// ET6 + ET8 -> AT16
	mv A0,I0	// AT16 -> ET9
	mv I0,I2	// ET9 -> ETb
	ldc 256,A0	// 256 -> A0
	ldx (I2)+1,NULL	// ETb += 1
	stx B1,(I2)	// 'sector' ==> ETb
// 	c.ca[i].flags = 2;
	ldc 2,B1	// 2 -> 1 -> ETc
	stx B1,(I0)+2	// ETc ==> ET9
// 	memcpy(c.ca[i].data,data,256);
	call _memcpy
	ldx (I4)+4,I1	// unspill 'data' from #0
// jumped away
	ldc _cacheIsDirty,I0	// ET10
	ldy (I6)+1,NULL ; stx B1,(I0)/*V*/	// I6 += 1
// 	cacheIsDirty = 2;
// 	CacheCheck(ph);
	call _CacheCheck
	stx A1,(I6)	// 'ph'
// jumped away
	ldx (I6)-1,NULL ; sub B0,ONES,A0	// I6 += -1
// 	return i+1;
	ldy (I6),I2 ; ldx (I6)-1,I1	// 'i' - (-1) -> ET11
	ldy (I6),I0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldx (I4)-2,NULL ; ldy (I6)+1,NULL	// I4 += -2
F16B3:
// 	}
// {
// 		FFlush(ph);
	ldx (I4)+2,A1	// unspill 'ph' from #-2
	call _FFlush
	stx A1,(I6)	// 'ph'
// jumped away
// 		currentSectorInCache = sector & ~7;
	j F16B4
	ldy (I6)-1,NULL ; stx B0,(I0)/*V*/	// I6 += -1
// jumped away

//_____________________________________________________________
//
	.sect code,DevSpiFlashBlockRead	// 48 words
	.export _DevSpiFlashBlockRead
_DevSpiFlashBlockRead:
	ldx (I6)+1,NULL ; ldy (I0)+7,NULL	// I6 += 1
	stx LR0,(I6)+1 ; ldy (I0)+4,NULL
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	sty I2,(I6) ; and C,NULL,C	// 0 -> C
	stx D1,(I6)+1 ; and NULL,NULL,B1
// hw
// ph
	ldx (I0),I2 ; and D,NULL,D	// 'dev' ==> 'ph'
// ((1UL<< 6),0,0);
	call _ObtainHwLocksBIP
	ldc 64,B0	// 64 -> B0
// jumped away
	ldc 256,D0	// 256 -> 3 -> D0
	ldx (I6)+1,NULL	// I6 += 1
// 	FFlush(ph);
	call _FFlush
	stx I2,(I6)	// 'ph'
// jumped away
	ldy (I4)-4,NULL ; ldx (I6)-1,NULL	// I6 += -1
// 	while(blocks--)
	ldx (I4)+1,C0 ; and NULL,NULL,D1	// 0 -> D1
	ldx (I4)+1,B0	// unspill B0 from #0
	ldx (I4)-3,B1	// unspill B1 from #0
	j F17B8
	ldx (I4)+5,A0	// unspill AT18 from #-5
// jumped away
F17B5:	// (loop lvl 2)
// 	}
// {
// 		BlockRead(ph, firstBlock+(2*65536/512), data);
	stx A0,(I6) ; add B,D,C	// AT18
	call _BlockRead
	mv I2,I0	// AT17 + ETb -> ETc
// jumped away
	ldc 256,C0	// 256 -> ET10
	ldx (I6)-1,NULL ; sub B,ONES,B	// I6 += -1
// 		firstBlock++;
// 		data += 256;
	mv A1,C0 ; add A0,C0,A0	// 'blocks' -> AT16
F17B8:	// (loop lvl 2)
	add C0,ONES,A1 ; ldx (I6)+1,NULL	// AT16 + (-1) -> ETa
	sub C0,NULL,C0	// AT16 != (0) -> (0)
	nop	// I6 += 1
	jzc F17B5	// unsigned compare
	nop
// jumped away
// 	ReleaseHwLocksBIP((1UL<< 6),0,0);
	ldc 0,B1	// 0 -> B1
	and C,NULL,C	// 0 -> C
	ldc 64,B0	// 64 -> B0
	call _ReleaseHwLocksBIP
	and D,NULL,D	// 0 -> D
// jumped away
// 	return 0;
	and NULL,NULL,A0 ; ldy (I6),I2	// 0 -> 0 -> ET13
	ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevSpiFlashBlockWrite	// 41 words
	.export _DevSpiFlashBlockWrite
_DevSpiFlashBlockWrite:
	ldx (I6)+1,NULL ; ldy (I0)+7,NULL	// I6 += 1
	stx LR0,(I6)+1 ; ldy (I0)+4,NULL
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	ldc 256,D0	// 256 -> 3 -> D0
	stx D1,(I6) ; ldy (I4)-3,NULL
// hw
// ph
	ldx (I0),C1 ; and NULL,NULL,D1	// 'dev' ==> 'ph'
// (blocks--)
	ldx (I4)+1,B0	// 0 -> D1
	ldx (I4)-3,B1	// unspill B1 from #0
	ldx (I4)+1,A1	// unspill AT15 from #-5
	j F18B6
	ldx (I4)+4,A0	// unspill AT13 from #-4
// jumped away
F18B3:	// (loop lvl 2)
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	stx C0,(I4) ; sty C1,(I4) ; add B0,D0,C0	// C0 spills to #0
// 	}
// {
// 		PutCacheBlock(ph, firstBlock+(2*65536/512),data);
	stx A1,(I6)+1 ; ldy (I4),C1	// AT15
	stx C0,(I6)+1 ; add C0,NULL,A0	// ET8 lsw ET9
	ldx (I4)-1,C0	// unspill C0 from #0
	call _PutCacheBlock
	stx C1,(I6)	// 'ph'
// jumped away
// 		PrintCache();
	ldc 256,A0	// 256 -> ETe
	call _PrintCache
	ldx (I6)-3,NULL	// I6 += -3
// jumped away
// 		firstBlock++;
// 		data += 256;
	add A1,A0,A1 ; mv C0,A0	// AT15 + ETe -> AT15
	sub B,ONES,B	// 'blocks' -> AT13
F18B6:	// (loop lvl 2)
	add A0,ONES,C0	// AT13 + (-1) -> ET6
	sub A0,NULL,A0	// AT13 != (0) -> (0)
	nop
	jzc F18B3	// unsigned compare
	nop
// jumped away
// 	return 0;
	and NULL,NULL,A0 ; ldx (I6)-1,D1	// 0 -> 0 -> ET10
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevSpiFlashIoctl	// 54 words
	.export _DevSpiFlashIoctl
_DevSpiFlashIoctl:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 5,B0	// 5 -> 0 -> ET5
	stx I2,(I6) ; ldy (I4)-2,NULL
	mv I0,I2 ; and NULL,NULL,A1	// 'dev' -> 'hw'
// errCode
// hw
// ph
// (request)
	ldy (I2)+7,NULL ; ldx (I4)+2,A0	// 'hw' += 11
	ldx (I2)+4,NULL ; sub A0,B0,B0	// ...
	nop
	jzc F19B5	// signed compare
	nop
// jumped away
	ldc String_4,A0	// ET6
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// {
// 			dev->fs = StartFileSystem(dev, "0");
	stx A0,(I6)+1	// ET6
	call _StartFileSystem
	stx I0,(I6)	// 'dev'
// jumped away
	mv I0,I2	// 'dev' -> ET9
	ldy (I2)+7,NULL ; ldx (I6)-2,NULL	// I6 += -2
	ldx (I2)+2,NULL	// ...
	stx A0,(I2) ; sub A0,NULL,A0	// ET7 ==> ET9
// 			if (!dev->fs)
	ldc 1,A0
	jzc F19B10	// signed compare
	nop	// 1 -> 1 -> ETb
// jumped away
// 			}
// {
// 				dev->flags =(1 << 0);
	stx A0,(I0) ; or NULL,ONES,A0	// ETb ==> 'dev'
// 				return -1;
F19B1:
	ldx (I6)-1,I2
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
// 		}
// {
// 			errCode = -1;
// 			break;
	ldc -1,A1	// -1 -> 'errCode'
F19B10:
// 	return errCode;
	j F19B1
	add A1,NULL,A0	// 'errCode' returns via A0
// jumped away
F19B5:
	ldc 6,A1	// 6 -> 0 -> ETd
	sub A0,A1,A1	// 'request' != ETd -> AT17
	ldc -1,A1
	jzc F19B10	// signed compare
	nop
// jumped away
	ldx (I4)-3,NULL ; ldy (I2)+4,NULL	// I4 += -3
// 			if (arg)
	ldx (I4)+3,I0	// unspill 'arg' from #-3
	mv I0,A0	// 'arg' -> AT1c
	sub A0,NULL,A0	// AT1c == (0) -> (0)
	ldc 8,A0	// 8 -> 1 -> ETe
	jzs F19B12	// signed compare
	nop
// jumped away
// 			}
// {
// 				((DiskGeometry*)arg)->sectorsPerBlock = 8;
	stx A0,(I0)+1 ; and A1,NULL,A1	// ETe ==> 'arg'
// 				((DiskGeometry*)arg)->totalSectors = hw->totalBlocks;
	ldx (I2),A0	// 'hw' ==> 4 -> ET11
	stx A0,(I0)+1
	stx A1,(I0)-1
// 			return hw->totalBlocks;
F19B12:
	j F19B1
	ldx (I2),A0	// 'hw' ==> 4 -> ET14
// jumped away

//_____________________________________________________________
//
	.sect data_x,devSpiFlashbss_x	// 2079 words
	.export _c
_c:
	.bss 2064
_s7b9e58:
	.bss 15

//_____________________________________________________________
//
	.sect data_x,devSpiFlashinit_x	// 2 words
	.export _currentSectorInCache
_currentSectorInCache:
	.word 0
	.export _cacheIsDirty
_cacheIsDirty:
	.word 0

//_____________________________________________________________
//
	.sect data_y,devSpiFlashconst_y	// 33 words
	.export _devSpiFlashDefaults
_devSpiFlashDefaults:
	.word 0, _DevSpiFlashIdentify, _DevSpiFlashCreate, _DevSpiFlashDelete, _DevSpiFlashIoctl, 0, 0, _DevSpiFlashBlockRead
	.word _DevSpiFlashBlockWrite
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1

//_____________________________________________________________
//
	.sect data_x,devSpiFlashconst_x	// 22 words
String_1:
	.word 0x9000
	.word "\000"

	.zero 1
String_2:
	.word 0x0102

	.zero 1
spiflash_3:
	.word "SPI Flash %04x"

	.zero 1
String_4:
	.word "0"

	.zero 1

	.end
