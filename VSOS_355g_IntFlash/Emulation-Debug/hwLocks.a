
//_____________________________________________________________
//
	.sect code,InitHwLocks	// 11 words
	.export _InitHwLocks
_InitHwLocks:
	stx LR0,(I6)+1
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 80,A0	// 80 -> A0
	stx I0,(I6) ; and NULL,NULL,A1
//   memset(&hwLocks, 0, sizeof(hwLocks));
	call _memset
	ldc _hwLocks,I0	// I0
// jumped away
	ldx (I6)-1,I0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,QueueHwLock	// 56 words
	.export _QueueHwLock
_QueueHwLock:
	ldc _hwLockOffset,A0	// ET3
	stx LR0,(I6)+1 ; add A0,C0,A0
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	mv A0,I0	// AT1f -> ET4
	stx I2,(I6) ; sty I3,(I6)
	ldx (I4)+1,NULL ; ldy (I0),A0	// I4 += 1
// qp
	add A0,C1,A1 ; mv I4,I0	// ET5 + 'bit' -> ET7
	ldc _hwLocks+12,A0	// ET2
	add A0,A1,B0 ; ldx (I4)+2,NULL	// ET2 + ET7 -> ET8
// (&thisQueue, 0, sizeof(thisQueue));
	ldc 6,A0	// 6 -> A0
	call _memset
	mv B0,I2 ; and NULL,NULL,A1	// I4 += 3
// jumped away
	mv I4,I3	// I4 -> [] -> I3
//   NewList(&thisQueue.queue);
	call _NewList
	ldx (I4)-3,NULL	// I4 += -3
// jumped away
	ldc _thisTask,I0	// ET11
	ldy (I4)+6,NULL ; ldx (I0),A0/*V*/	// I4 += 6
//   thisQueue.taskP = thisTask;
	stx A0,(I4)-6
//   if (!(*qp))
	ldx (I2),A0	// 'qp' ==> ET12
	sub A0,NULL,A0	// ET12 != (0) -> (0)
	nop
	jzc F1B6	// signed compare
	nop
// jumped away
	ldc _hwLocks+6,B0	// ET15
	ldx (I4)+1,NULL ; add C0,C0,B1	// 'group' + 'group' -> ET16
	stx I4,(I2) ; and NULL,NULL,A1	// 0 -> A1
	sub NULL,ONES,A0 ; ldy (I4)-1,NULL	// I4 += 1
//   }
// {
//     *qp = &thisQueue;
//     hwLocks.queueBits[group] |= 1UL<<bit;
	add B0,B1,B0	// ET15 + ET16 -> AT20
	mv B0,I0 ; ashl A,C1,A	// AT20 -> ET17
	ldx (I0)+1,B0
	ldx (I0)-1,B1
	or B,A,A	// ET18 or ET14 -> ET19
	stx A0,(I0)+1
	stx A1,(I0)-1
F1B6:
	ldy (I4)+1,NULL ; ldx (I2),I3	// I4 += 1
	mv I4,I2	// I4 -> [] -> I2
//   AddTail(&((*qp)->queue), &(thisQueue.node));
	call _AddTail
	ldx (I3)+2,NULL ; ldy (I4)-1,NULL	// ET1a += 2
// jumped away
//   Enable();
	call _Enable
	nop
// jumped away
//   Wait((1<<0));
	call _Wait
	sub NULL,ONES,A0	// 1 -> A0
// jumped away
//   Disable();
	call _Disable
	nop
// jumped away
//   return leOk;
	and NULL,NULL,A0 ; ldy (I6),I3	// 0 -> 0 -> ETa
	ldx (I6)-1,I2
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,ObtainHwLocksBIP	// 93 words
	.export _ObtainHwLocksBIP
_ObtainHwLocksBIP:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx A1,(I6) ; sty I0,(I6)+1
	ldc _hwLocks,I0	// 'hwllb'
	stx I1,(I6) ; sty I2,(I6)+1
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6) ; ldy (I4)+1,NULL
// hwllb
// lb
// [0] = slb;
	sty B0,(I4)+1
	sty B1,(I4)+1
//   lockBits[1] = slio;
	sty C0,(I4)+1
	sty C1,(I4)+1
//   lockBits[2] = slp;
	sty D0,(I4)+1 ; and NULL,NULL,D0
	sty D1,(I4)-5
	mv I4,I2	// 0 -> 'group'
//   for (group=0; group< 3; group++)
	ldx (I4)-1,NULL	// I4 += -1
F2B6:	// (loop lvl 2)
	ldc 3,A0	// 3 -> ET7
	sub D0,A0,D1	// 'group' >= ET7 -> AT25
	nop
	jcs F2B4	// unsigned compare
	nop
// jumped away
//   }
// {
//     Disable();
	call _Disable
	nop
// jumped away
//     if (*lb & *hwllb)
	ldy (I2)+1,B0 ; ldx (I0)+1,A0
	ldy (I2)-1,B1 ; ldx (I0)-1,A1
	and B,A,A	// ET8 and ET9 -> ETa
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// ETa == (0) -> (0)
	ldc _hwLockN,A0	// ETc
	jzs F2B9	// unsigned compare
	add A0,D0,A0	// ETc + 'group' -> AT29
// jumped away
//     }
// currBitMask

	mv A0,I1 ; sub NULL,ONES,B0	// AT29 -> ETd
// ();
	call _Enable
	ldy (I1),D1 ; and NULL,NULL,B1	// ETd ==> 'n'
// jumped away
//       for (bit=0; bit<n; bit++)
	ldc 0,A1	// 0 -> 'bit'
	sub D1,A1,A0	// 'n' <= 'bit' -> AT22
	nop
	jle F2B13	// signed compare
	nop
// jumped away
	add A0,ONES,A0	// AT22 + (-1) -> AT22
	loop A0,F2B13-1
	nop
//loop resumes
//       }
// {
// 	if (*lb & currBitMask)
	ldy (I2)+1,C0
	ldy (I2)-1,C1
	and C,B,C	// ET8 and 'currBitMask' -> ET11
	ldc 0,C2	// update guard bits (cmp)
	sub C,NULL,C	// ET11 == (0) -> (0)
	nop
	jzs F2B17	// unsigned compare
	nop
// jumped away
// 	}
// {
// 	  Disable();
	call _Disable
	nop
// jumped away
// 	  if (*hwllb & currBitMask)
	ldx (I0)+1,C0
	ldx (I0)-1,C1
	and C,B,C	// ET9 and 'currBitMask' -> ET12
	ldc 0,C2	// update guard bits (cmp)
	sub C,NULL,C	// ET12 == (0) -> (0)
	ldx (I0)+1,C0
	jzs F2B20	// unsigned compare
	ldx (I0)-1,C1
// jumped away
	ldy (I6)+1,NULL ; add A1,NULL,C1
// 	  }
// {
// 	    QueueHwLock(group, bit);
	call _QueueHwLock
	mv D0,C0	// 'bit' -> C1
// jumped away
F2B21:	// (loop lvl 3)
// 	  Enable();
	call _Enable
	nop
// jumped away
F2B17:	// (loop lvl 3)
// 	currBitMask <<= 1;
	add B,B,B	// 'currBitMask' >> (-1) -> 'currBitMask'
	sub A1,ONES,A1	// 'bit' - (-1) -> 'bit'
//	(0 nop's needed)
// loop end
F2B13:	// loop exit
//       Disable();
	call _Disable
	nop
// jumped away
F2B10:	// (loop lvl 2)
//     Enable();
	call _Enable
	nop
// jumped away
//     hwllb++;
//     lb++;
	sub D0,ONES,D0 ; ldy (I2)+2,NULL	// 'group' - (-1) -> 'group'
	j F2B6
	ldx (I0)+2,NULL	// 'hwllb' += 2
// jumped away
F2B20:	// (loop lvl 3)
// 	  }
// else {
// 	    *hwllb |= currBitMask;
	or C,B,C	// ET9 or 'currBitMask' -> ET15
	stx C0,(I0)+1
	j F2B21
	stx C1,(I0)-1
// jumped away
F2B9:	// (loop lvl 2)
//     }
// else {
//       *hwllb |= *lb;
	ldy (I2)+1,A0 ; ldx (I0)+1,B0
	ldy (I2)-1,A1 ; ldx (I0)-1,B1
	or B,A,A	// ET19 or ET8 -> ET1a
	stx A0,(I0)+1
	j F2B10
	stx A1,(I0)-1
// jumped away
F2B4:
//   return leOk;
	and NULL,NULL,A0 ; ldx (I6)-1,LE	// 0 -> 0 -> ET10
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,AttemptHwLocksBIP	// 50 words
	.export _AttemptHwLocksBIP
_AttemptHwLocksBIP:
	stx LR0,(I6)+1 ; and NULL,NULL,A0
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx I0,(I6) ; sty I2,(I6)+1
	ldc _hwLocks,I0	// 'hwllb'
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6) ; ldy (I4)+1,NULL
// hwllb
// lb
// returnCode
// [0] = slb;
	sty B0,(I4)+1
	sty B1,(I4)+1
//   lockBits[1] = slio;
	sty C0,(I4)+1
	sty C1,(I4)+1
//   lockBits[2] = slp;
	sty D0,(I4)+1
	sty D1,(I4)-5
	mv I4,I2	// 0 -> 'returnCode'
//   Disable();
	call _Disable
	ldx (I4)-1,NULL	// I4 += -1
// jumped away
	ldc 2,LC	// loop 3 iterations
	loop LC,F3B5-1
	nop
//loop resumes
//   }
// {
//     if (*lb++ & *hwllb++)
	ldy (I2)+1,B0 ; ldx (I0)+1,C0
	ldy (I2)+1,B1 ; ldx (I0)+1,C1
	and B,C,B	// ETa and ETd -> ETe
	ldc 0,B2	// update guard bits (cmp)
	sub B,NULL,B	// ETe == (0) -> (0)
	nop
	jzs F3B22	// unsigned compare
	nop
// jumped away
//     }
// {
//       returnCode = leAlreadyAllocated;
	ldc 2,A0	// 2 -> 'returnCode'
F3B22:	// (loop lvl 2)
//	(1 nop's needed)
	nop
// loop end
F3B5:	// loop exit
//   if (returnCode == leOk)
	sub A0,NULL,A0	// 'returnCode' != (0) -> (0)
	nop
	jzc F3B13	// unsigned compare
	nop
// jumped away
//   }
// {
//     hwllb -= 3;
//     lb -= 3;
//     for (group=0; group< 3; group++)
	ldc 2,LC	// loop 3 iterations
	loop LC,F3B13-1
	ldx (I2)-6,NULL ; ldy (I0)-6,NULL	// 'lb' += -6
//loop resumes
//     }
// {
//       *hwllb++ |= *lb++;
	ldy (I2)+1,C0 ; ldx (I0)+1,B0
	ldy (I2)+1,C1 ; ldx (I0)-1,B1
	or B,C,B	// ETd or ETa -> ET16
	stx B0,(I0)+1
	stx B1,(I0)+1
//	(0 nop's needed)
// loop end
F3B13:	// loop exit
//   Enable();
	call _Enable
	nop
// jumped away
	ldx (I6)-1,LE
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,ReleaseHwLock	// 94 words
	.export _ReleaseHwLock
_ReleaseHwLock:
	stx LR0,(I6)+1 ; sub NULL,ONES,A0
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I3,(I6)
	and NULL,NULL,A1 ; ldx (I4)+1,NULL	// I4 += 1
// bitMask
	ashl A,C1,B	// ET0 << 'bit' -> 'bitMask'
// qp
	ldc _hwLocks+12,A1	// ET4
	ldc _hwLockOffset,A0	// ET5
	add A0,C0,A0	// ET5 + 'group' -> AT27
	mv A0,I0	// AT27 -> ET6
	ldy (I0),A0	// ET6 ==> ET7
	add A0,C1,A0	// ET7 + 'bit' -> ET9
	add A1,A0,A0	// ET4 + ET9 -> ETa
	mv A0,I0	// ETa -> 'qp'
// queueList1
	stx I0,(I4)-1	// 'qp' spills to #0
	ldx (I0),I0	// 'qp' ==> ETb
// (*hwlqb & bitMask)
	ldx (I2)+1,A0 ; ldy (I0)+2,NULL
	ldx (I2)-1,A1
	and A,B,A ; mv I0,I1	// ETe and 'bitMask' -> ETf
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; ldx (I0)-2,NULL	// ETb -> 'queueList1'
	nop	// ETb += -2
	jzs F4B4	// unsigned compare
	nop
// jumped away
//   }
// {
//     Signal((*qp)->taskP,(1<<0));
	ldx (I0)+5,NULL ; sub NULL,ONES,A0	// ETb += 5
	call _Signal
	ldx (I0),I0	// ETb ==> ET13
// jumped away
//     if (HeadNode(queueList1) == TailNode(queueList1))
	call _HeadNode
	mv I1,I3	// 'queueList1' -> I3
// jumped away
	call _TailNode
	mv I1,I3 ; add A0,NULL,A1	// A0 -> ET14
// jumped away
	sub A1,A0,A1	// ET14 == ET15 -> AT25
	nop
	jzs F4B7	// signed compare
	nop
// jumped away
//     }
// n2
	call _HeadNode
	mv I1,I3	// 'queueList1' -> I3
// jumped away
	mv A0,I0	// A0 -> ET19
	call _NextNode
	mv I0,I3	// ET19 -> I3
// jumped away
	mv I1,I3	// 'queueList1' -> I3
	mv A0,I0	// A0 -> 'n2'
	ldx (I4)+1,NULL ; ldy (I0)+2,NULL	// I4 += 1
// hwlq2
// queueList2
// (HeadNode(queueList1));
	call _HeadNode
	sty I0,(I4)-1 ; ldx (I0)-2,NULL	// I0 spills to #0
// jumped away
	mv A0,I2	// A0 -> ET1c
	mv I2,I3	// ET1c -> I3
	call _RemNode
	ldc F4B19,LR0
// jumped away
F4B16:	// (loop lvl 2)
//       }
// {
// 	RemNode(tmpNode);
	call _RemNode
	mv A0,I3	// 'tmpNode' -> I3
// jumped away
	mv A0,I2	// 'tmpNode' -> I2
	ldx (I4)+1,NULL	// I4 += 1
// 	AddTail(queueList2, tmpNode);
	call _AddTail
	ldy (I4)-1,I3	// unspill 'queueList2' from #0
// jumped away
F4B19:	// (loop lvl 2)
	call _HeadNode
	mv I1,I3	// 'queueList1' -> I3
// jumped away
	sub A0,NULL,A0	// 'tmpNode' != (0) -> (0)
	nop
	jzc F4B16	// signed compare
	nop
// jumped away
	ldx (I4)+1,NULL	// I4 += 1
//       *qp = hwlq2;
	ldx (I4)-1,I2	// unspill 'qp' from #0
	stx I0,(I2)	// 'n2' ==> 'qp'
F4B5:
//   return leOk;
	and NULL,NULL,A0 ; ldy (I6),I3	// 0 -> 0 -> ET22
	ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F4B7:
	ldx (I4)+1,NULL ; and NULL,NULL,A0	// I4 += 1
//     }
// {
//       *qp = 0;
	ldx (I4)-1,I0	// 0 -> ET16
	stx A0,(I0)	// ET16 ==> 'qp'
//       *hwlqb &= ~bitMask;
	xor B,ONES,B ; ldx (I2)+1,A0	// 'bitMask' xor (-1) -> ET17
	ldx (I2)-1,A1
	and A,B,A	// ETe and ET17 -> ET18
	stx A0,(I2)+1
	j F4B5
	stx A1,(I2)-1
// jumped away
F4B4:
//   }
// else {
//     hwLocks.lockBits[group] &= ~bitMask;
	ldc _hwLocks,A1	// ET2
	add C0,C0,A0	// 'bitMask' xor (-1) -> ET17
	add A1,A0,A0	// ET2 + ET1e -> AT28
	mv A0,I0 ; xor B,ONES,B	// AT28 -> ET1f
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	and A,B,A	// ET20 and ET17 -> ET21
	stx A0,(I0)+1
	j F4B5
	stx A1,(I0)-1
// jumped away

//_____________________________________________________________
//
	.sect code,ReleaseHwLocksBIP	// 69 words
	.export _ReleaseHwLocksBIP
_ReleaseHwLocksBIP:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx A1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	ldc _hwLocks+10,I1	// 'hwlqb'
	stx I3,(I6) ; sty LC,(I6)+1
	ldc _hwLocks+4,I3	// 'hwllb'
	ldc 2,LC	// loop 3 iterations
	stx LS,(I6) ; sty LE,(I6)
	ldx (I4)+1,NULL	// I4 += 1
// hwllb
// hwlqb
// lb
// err
// [0] = slb;
	sty B0,(I4)+1
	ldc 2,B0	// 2 -> 'group'
	sty B1,(I4)+1
//   lockBits[1] = slio;
	sty C0,(I4)+1
	sty C1,(I4)+1
//   lockBits[2] = slp;
	sty D0,(I4)+1
	sty D1,(I4)-1
	mv I4,I0	// I4 -> [] -> 'lb'
//   for (group= 3 -1; group>=0; group--)
	loop LC,F5B4-1
	ldx (I4)-5,NULL	// I4 += -5
//loop resumes
//   }
// {
//     Disable();
	call _Disable
	nop
// jumped away
//     if (*hwlqb & *lb)
	ldx (I1)+1,A0 ; ldy (I0)+1,C0
	ldx (I1)-1,A1 ; ldy (I0)-1,C1
	and A,C,A	// ETb and ETc -> ETd
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// ETd != (0) -> (0)
	nop
	jzc F5B20	// unsigned compare
	nop
// jumped away
//     }
// else {
//       *hwllb &= ~(*lb);
	ldy (I0)+1,A0 ; ldx (I3)+1,C0
	ldy (I0)-1,A1 ; ldx (I3)-1,C1
	xor A,ONES,A	// ET16 xor (-1) -> ET17
	and C,A,A	// ET18 and ET17 -> ET19
	stx A0,(I3)+1
//     Enable();
	call _Enable
	stx A1,(I3)-1
// jumped away
F5B10:	// (loop lvl 2)
//     hwllb--;
//     hwlqb--;
//     lb--;
	add B0,ONES,B0 ; ldx (I0)-2,NULL	// 'group' + (-1) -> 'group'
	ldx (I1)-2,NULL ; ldy (I3)-2,NULL	// 'hwlqb' += -2
//	(0 nop's needed)
// loop end
F5B4:	// loop exit
//   return leOk;
	and NULL,NULL,A0 ; ldy (I6),LE	// 0 -> 0 -> ET8
	ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F5B20:	// (loop lvl 2)
	j F5B14
	add B0,NULL,A1	// 'group' -> ET14
// jumped away
F5B11:	// (loop lvl 3)
//       }
// {
// 	*lb &= ~(1UL<<bit);
	sub NULL,ONES,C0 ; mv I1,I2	// 1 -> C0
	and NULL,NULL,C1 ; ldx (I6)+1,NULL	// 0 -> C1
	ashl C,A0,C	// ETf << 'bit' -> ET10
	xor C,ONES,D ; ldy (I0)+1,C0	// ET10 xor (-1) -> ET11
	ldy (I0)-1,C1
	and C,D,C	// ETc and ET11 -> ET12
	sty C0,(I0)+1 ; add A1,NULL,C0
// 	ReleaseHwLock(group, bit, hwlqb);
	call _ReleaseHwLock
	sty C1,(I0)-1 ; add A0,NULL,C1
// jumped away
F5B14:	// (loop lvl 3)
	ldy (I0)+1,D0
	call _MSBSetU32
	ldy (I0)-1,D1
// jumped away
	sub A0,NULL,A0	// 'bit' >= (0) -> (0)
	nop
	jge F5B11	// signed compare
	nop
// jumped away
	call _Enable
	ldc F5B10,LR0
// jumped away

//_____________________________________________________________
//
	.sect data_x,hwLocksbss_x	// 80 words
	.export _hwLocks
_hwLocks:
	.bss 80

//_____________________________________________________________
//
	.sect data_y,hwLocksconst_y	// 8 words
	.export _hwLockOffset
_hwLockOffset:
	.word 0, 10, 37, 68
	.export _hwLockN
_hwLockN:
	.word 10, 27, 31

	.end
