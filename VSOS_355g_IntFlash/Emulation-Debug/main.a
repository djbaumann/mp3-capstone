
//_____________________________________________________________
//
	.sect code,DefaultSysError	// 35 words
	.export _DefaultSysError
_DefaultSysError:
	ldc e_1,A0	// ET2
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6)+1 ; sty I0,(I6)
	ldc _vo_stderr,I0	// ET3
	ldy (I4)-2,NULL ; stx A0,(I6)+1	// I4 += -2
	mv I4,A1	// ET0 -> 'args'
// args = ((va_list)&(msg)));
// 	vo_fprintf(vo_stderr, "E'");
	ldx (I0),A0/*V*/ ; ldy (I4)+2,NULL	// ET3 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc _vo_fputc,A0	// ET5
	ldy (I6)-1,NULL ; ldx (I4)-2,NULL	// I4 += -2
//  PrintFmt((msg), (args), (vo_stderr), (int(*)(int, __near void *))vo_fputc);
	stx A0,(I6)+1	// ET5
	ldx (I0),A0/*V*/	// ET3 ==> 'vo_stderr'
	stx A0,(I6)+1	// 'vo_stderr'
	stx A1,(I6)+1	// 'args'
	ldx (I4)+2,A0	// I4 ==> 'msg'
	call _PrintFmt
	stx A0,(I6)	// 'msg'
// jumped away
	ldc String_2,A0	// ET7
	ldx (I6)-3,NULL	// I6 += 1
// 	vo_fprintf(vo_stderr,"'\n");
	stx A0,(I6)+1	// ET7
	ldx (I0),A0/*V*/	// ET3 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I4)-2,NULL ; ldy (I6)-2,NULL	// I4 += -2
// ;
// 	return (ioresult)msg;
	ldx (I4)+2,A0 ; ldy (I6),I0	// I4 ==> ATb
	ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DefaultSysReport	// 28 words
	.export _DefaultSysReport
_DefaultSysReport:
	ldc _vo_fputc,A0	// ET2
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx I0,(I6)+1 ; ldy (I4)-2,NULL
	ldc _vo_stderr,I0	// ET3
// args = ((va_list)&(msg)));
//  PrintFmt((msg), (args), (vo_stderr), (int(*)(int, __near void *))vo_fputc);
	stx A0,(I6)+1	// ET2
	ldx (I0),A0/*V*/	// ET3 ==> 'vo_stderr'
	stx A0,(I6)+1	// 'vo_stderr'
	mv I4,A0	// ET0 -> 'args'
	stx A0,(I6)+1	// 'args'
	ldx (I4)+2,A0	// I4 ==> 'msg'
	call _PrintFmt
	stx A0,(I6)	// 'msg'
// jumped away
	ldc String_3,A0	// ET5
	ldx (I6)-3,NULL	// I6 += 1
// 	vo_fprintf(vo_stderr,"\n");
	stx A0,(I6)+1	// ET5
	ldx (I0),A0/*V*/	// ET3 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL ; and NULL,NULL,A0	// I6 += -2
// ;
// 	return 0;
	ldx (I6)-1,I0	// 0 -> 0 -> ET7
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DevNullWrite	// 43 words
	.export _DevNullWrite
_DevNullWrite:
	ldc devnulwr_4,A0	// ET0
	ldc _vo_stderr,I0	// ET1
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6)+1
//  vo_fprintf(vo_stderr,"DevNulWr");
	stx A0,(I6)+1	// ET0
	ldx (I0),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I4)-4,NULL ; ldy (I6)-1,NULL	// I4 += -4
// 	if (bytes>1)
	ldx (I4)+4,A0 ; sub NULL,ONES,A1	// 1 -> 1 -> ET3
	sub A1,A0,A1	// ET3 <= 'bytes' -> ATd
	nop
	jcs F2B5	// unsigned compare
	nop	// I6 += 1
// jumped away
// 	}
// {
//  vo_fprintf(vo_stderr,"(%d)",bytes);
	stx A0,(I6)+1	// 'bytes'
	ldc d_5,A0	// ET4
	stx A0,(I6)+1	// ET4
	ldx (I0),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -3
F2B5:
	ldc -8,A0	// -8 -> 0 -> ET8
	ldy (I4)-2,NULL
//  vo_fprintf(vo_stderr,"  %c  ", *(char*)buf>>8);
	ldx (I4)+2,I0	// unspill 'buf' from #0
	ldx (I0),A1	// 'buf' ==> ET6
	ldc _vo_stderr,I0	// ET1
	ashl A1,A0,A0	// ET6 << ET8 -> ET9
	stx A0,(I6)+1	// ET9
	ldc c_6,A0	// ETa
	stx A0,(I6)+1	// ETa
	ldx (I0),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-3,NULL ; and NULL,NULL,A0	// I6 += -3
// 	return 0;
	ldx (I6)-1,A1	// 0 -> 1 -> ETc
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,MyDelayHook	// 14 words
	.export _MyDelayHook
_MyDelayHook:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6)+1 ; sub NULL,ONES,A0
// 	Delay(1);
	call _Delay
	stx A0,(I6)	// ET0
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,SetNextApp	// 47 words
	.export _SetNextApp
_SetNextApp:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx I0,(I6) ; sty I1,(I6)+1
	ldc _appFile,I0	// ET0
	stx I2,(I6)
// 	if (appFile)
	ldx (I0),A0/*V*/	// ET0 ==> 'appFile'
	sub A0,NULL,A0	// 'appFile' == (0) -> (0)
	nop
	jzs F4B4	// signed compare
	nop
// jumped away
// 	}
// {
//  vo_fclose(appFile);
	call _vo_fclose
	mv A0,I0	// 'appFile' -> I0
// jumped away
F4B4:
	ldc rb_7,A0	// ET2
	ldy (I6)+1,NULL ; ldx (I4)-2,NULL	// I4 += -2
// 	appFile = vo_fopen(appFileName,"rb");
	stx A0,(I6)+1	// ET2
	ldx (I4)+2,A0	// unspill 'appFileName' from #0
	call _vo_fopen
	stx A0,(I6)	// 'appFileName'
// jumped away
	ldc _appFile,I0	// ET0
	stx A0,(I0)/*V*/ ; ldy (I6)-2,NULL	// I6 += -2
	sub A0,NULL,A0	// ET3 != (0) -> (0)
// 	if (!appFile)
	ldc _appParameters,I0
	jzc F4B8	// signed compare
	and NULL,NULL,A0
// jumped away
// return -1;
	or NULL,ONES,A0	// -1 -> 0 -> ET4
F4B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,I0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc _appParameters,I0	// ET6
	ldc 0,A0	// 0 -> 0 -> ET5
F4B8:
	ldx (I0),I2/*V*/ ; ldy (I4)-3,NULL	// I4 += -3
// 	appParameters[0] = 0;
	stx A0,(I2)/*V*/	// ET5 ==> 'appParameters'
// 	if (parameters)
	ldx (I4)+3,A0	// unspill 'parameters' from #-3
	sub A0,NULL,A0	// 'parameters' == (0) -> (0)
	mv A0,I1	// 'parameters' -> I1
	jzs F4B10	// signed compare
	nop
// jumped away
// 	}
// {
// 		strcpy(appParameters, parameters);
	call _strcpy
	ldx (I0),I0/*V*/	// ET6 ==> 'appParameters'
// jumped away
F4B10:
// 	return 0;
	j F4B1
	and NULL,NULL,A0	// 0 -> 0 -> ET5
// jumped away

//_____________________________________________________________
//
	.sect code,Timer1Interrupt	// 44 words
	.export _Timer1Interrupt
_Timer1Interrupt:
	sty MR0,(I6) ; stx I7,(I6)+1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx I5,(I6) ; sty LR1,(I6)+1
	stx A0,(I6) ; sty A2,(I6)+1
	stx A1,(I6) ; sty I0,(I6)+1
	ldc 0,I0	// 0 -> ET0
	stx B2,(I6) ; sty C2,(I6)+1
	stx D2,(I6) ; add NULL,P,A
	sty A0,(I6)+1
	stx A1,(I6)
	ldc 512,MR0	// 512 -> MR0
// 	if ((*(__x volatile u_int16 *)(u_int16)(0)))
	ldx (I0),A0/*V*/	// ET0 ==> ET1
	sub A0,NULL,A0	// ET1 != (0) -> (0)
	nop
	callzc _Disable
	ldc F5B3,LR0
// jumped away
	ldx (I6)-1,A1
	ldy (I6),A0 ; ldx (I6)-1,D2
	resp A0,A1
	ldy (I6),C2 ; ldx (I6)-1,B2
	ldy (I6),I0 ; ldx (I6)-1,A1
	ldy (I6),A2 ; ldx (I6)-1,A0
	ldy (I6),LR1 ; ldx (I6)-1,I5
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0

	ldy (I6),MR0	// return from interrupt
	ldc INT_GLOB_ENA,I7
	reti
	sty I7,(I7) ; ldx (I6)-1,I7

// jumped away
F5B3:
// ;
// 	}
// {
// 		Disable();
	ldc x0notze_8,A0	// ET2
	ldc _vo_stderr,I0	// ET3
	ldx (I6)+1,NULL	// I6 += 1
//  vo_fprintf(vo_stderr,"X:0 not zero\n");
	stx A0,(I6)+1	// ET2
	ldx (I0),A0/*V*/	// ET3 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
// 		while(1)
F5B10:
	j F5B10
	nop
// jumped away

//_____________________________________________________________
//
	.sect interrupt_47,int_Timer1Interrupt	// 1 word
	.export int_Timer1Interrupt
int_Timer1Interrupt:
	jmpi _Timer1Interrupt,(I6)+1

//_____________________________________________________________
//
	.sect code,Init0	// 142 words
	.export _Init0
_Init0:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)+1
// 	Disable();
	call _Disable
	stx I2,(I6)
// jumped away
// 	SetupMainStackSize(sysTasks[0].stackSize);
	ldc _sysTasks+13,I0	// ET2
	call _SetupMainStackSize
	ldx (I0),A0	// ET2 ==> 13 -> ET3
// jumped away
// 	SetupInterruptStackSize(sysTasks[1].stackSize);
	ldc _sysTasks+28,I0	// ET6
	call _SetupInterruptStackSize
	ldx (I0),A0	// ET6 ==> 28 -> ET7
// jumped away
// 	AddIntServer(16, TimeCountAndScheduleHandler);
	ldc _TimeCountAndScheduleHandler,A0	// A0
	call _AddIntServer
	ldc 16,I0	// 16 -> I0
// jumped away
	ldc 64515,I0	// 64515 -> ETc
	ldc 65403,A1	// 65403 -> 1 -> ETb
	ldy (I0),A0/*V*/ ; ldx (I6)+1,NULL	// I6 += 1
// (*(__y volatile u_int16 *)(u_int16)(0xFC03)) &= ~((1<<(23 -16)) |(1<<(18 -16)));
	and A0,A1,A0	// ETd and ETb -> ETe
	sty A0,(I0)/*V*/	// ETe ==> ETc
// 	__InitMemAllocI((void*)0x3300,0x7FC0 - 0x3300);
	ldc 19648,A0	// 19648 -> 1 -> ETf
	stx A0,(I6)+1	// ETf
	ldc 13056,A0	// 13056 -> ET10
	call ___InitMemAllocI
	stx A0,(I6)	// ET10
// jumped away
	ldc 25568,A0	// 25568 -> 1 -> ET11
	ldx (I6)-1,NULL	// I6 += 1
// 	InitMemAlloc((void*)0x1C00,0x7FD0 - 0x1C00, (void __y*)0x0C00,0x6FE0 - 0x0C00);
	stx A0,(I6)+1	// ET11
	ldc 3072,A0	// 3072 -> ET12
	stx A0,(I6)+1	// ET12
	ldc 25552,A0	// 25552 -> 1 -> ET13
	stx A0,(I6)+1	// ET13
	ldc 7168,A0	// 7168 -> ET14
	call _InitMemAlloc
	stx A0,(I6)	// ET14
// jumped away
	ldc _XPeripIntAsm,B0	// ET16
	ldc 6,A0	// 6 -> 0 -> ET19
	ldc 10752,A1	// 10752 -> A1
	ldc 34,I0	// 34 -> I0
	and B1,NULL,B1 ; ldx (I6)-4,NULL	// I6 += -4
// 	WriteIMem((void *)(0x20+ 2), 0x2a00000e+((u_int32)((u_int16)XPeripIntAsm) << 6));
	ashl B,A0,B	// ET18 << ET19 -> ET1a
	ldc 14,A0	// 14 -> 3 -> A0
	call _WriteIMem
	add A,B,A	// ET15 + ET1a -> ET1b
// jumped away
// 	memset(0,0,16);
	ldc 16,A0	// 16 -> A0
	and NULL,NULL,A1	// 0 -> A1
	call _memset
	ldc 0,I0	// 0 -> I0
// jumped away
// 	*((u_int16*)(4)) = DevNullWrite;
	ldc 4,I0	// 4 -> ET22
	ldc _DevNullWrite,A0	// ET20
// 	}
// = GetI6()+8;
	call _GetI6
	stx A0,(I0)	// ET20 ==> ET22
// jumped away
	ldc 8,A1	// 8 -> 1 -> ET24
	add A0,A1,B0	// ET23 + ET24 -> 'i6'
// 	  n = 0x30 + 0x3d0 -i6;
	ldc 1024,A0	// 1024 -> 0 -> ET27
	sub A0,B0,B1	// ET27 - 'i6' -> 'n'
// 	  if (n > 0)
	sub B1,NULL,B1	// 'n' <= (0) -> (0)
	nop
	jle F6B13	// signed compare
	nop
// jumped away
	mv B0,I0 ; add B1,NULL,A0	// 'i6' -> ET2b
// 	  }
// {
// 	    memset((u_int16 *)i6, 0xbabe, n);
	call _memset
	ldc -17730,A1	// -17730 -> A1
// jumped away
	mv B0,I0 ; add B1,NULL,A0	// 'i6' -> ET2e
// 	    memsetY((u_int16 __y *)i6, 0xebab, n);
	call _memsetY
	ldc -5205,A1	// -5205 -> A1
// jumped away
F6B13:
// 	InitHwLocks();
	call _InitHwLocks
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
// 	console.Ioctl = CommonOkResultFunction;
	ldc _console+4,I0	// ET33
	ldc _CommonOkResultFunction,A0	// ET30
	ldc 6143,C0	// 6143 -> 1 -> ET36
	ldc 65153,I2	// 65153 -> ET38
	stx A0,(I0) ; and NULL,NULL,B1	// ET30 ==> ET33
// (*(__y volatile u_int16 *)(u_int16)(0xfe8d)) = (6144-1) >> 16;
	ldc 65165,I0	// 65165 -> ET35
	ldc 4,A0	// 4 -> 1 -> ET32
	sty B1,(I0)-1/*V*/	// ET34 ==> ET35
// (*(__y volatile u_int16 *)(u_int16)(0xfe8c)) = (6144-1);
	sty C0,(I0)/*V*/	// ET36 ==> ET37
// (*(__y volatile u_int16 *)(u_int16)(0xfe81)) |= 4;
	ldc _useQuantum,I0	// ET3f
	ldy (I2),A1/*V*/	// ET38 ==> ET39
	or A1,A0,A0	// ET39 or ET32 -> ET3a
	sty A0,(I2)/*V*/	// ET3a ==> ET38
// (*(__y volatile u_int16 *)(u_int16)(0xfe81)) &= ~(1);
	ldc 65534,A0	// 65534 -> 1 -> ET3b
	ldy (I2),A1/*V*/	// ET38 ==> ET3c
	and A1,A0,A0	// ET3c and ET3b -> ET3d
	sty A0,(I2)/*V*/	// ET3d ==> ET38
// 	useQuantum = 5;
	ldc 5,A0	// 5 -> 0 -> ET3e
	stx A0,(I0)/*V*/	// ET3e ==> ET3f
// 	SetHookFunction((u_int16)Sleep, MyDelayHook);
	ldc _Sleep,A0	// ET41
	mv A0,I0	// ET41 -> I0
	call _SetHookFunction
	ldc _MyDelayHook,A0	// A0
// jumped away
// 	SetHookFunction((u_int16)IdleHook, MyDelayHook);
	ldc _IdleHook,A0	// ET44
	mv A0,I0	// ET44 -> I0
	call _SetHookFunction
	ldc _MyDelayHook,A0	// A0
// jumped away
// 	}
// cmd
	ldc _DelayMicroSecPatch,A0	// ET48
	ldc 0,D0	// 0 -> 3 -> D0
	mv D0,A1
	ldc 6,B0	// 6 -> 0 -> ET19
	ldc 10752,D1	// 10752 -> D1
	ldc _DelayMicroSec,I0	// I0
	ashl A,B0,A	// ET49 << ET19 -> ET4a
// (DelayMicroSec, cmd);
	call _WriteIMem
	add D,A,A	// ET47 + ET4a -> 'cmd'
// jumped away
// (*(__y volatile u_int16 *)(u_int16)(0xFC01)) |=(1<<(16 -16));
	ldc 64513,I0	// 64513 -> ET4e
	ldy (I0),A0/*V*/ ; sub NULL,ONES,A1	// ET4e ==> ET4f
	or A0,A1,A0	// ET4f or ET4d -> ET50
	ldc 2,A1	// 2 -> 1 -> ET53
	sty A0,(I0)/*V*/	// ET50 ==> ET4e
// (*(__y volatile u_int16 *)(u_int16)(0xfe89)) = (6144-1) >> 16;
	ldc 65161,I0	// 65161 -> ET51
	sty B1,(I0)-1/*V*/	// ET34 ==> ET51
// (*(__y volatile u_int16 *)(u_int16)(0xfe88)) = (6144-1);
	ldc 10752,B1	// 10752 -> B1
	sty C0,(I0)/*V*/	// ET36 ==> ET52
// (*(__y volatile u_int16 *)(u_int16)(0xfe81)) |= 2;
	ldc 64512,I0	// 64512 -> ET57
	ldy (I2),A0/*V*/	// ET38 ==> ET54
	or A0,A1,A0	// ET54 or ET53 -> ET55
	sty A0,(I2)/*V*/	// ET55 ==> ET38
// (*(__y volatile u_int16 *)(u_int16)(0xFC00)) |=(1<< 15);
	ldc 32768,A0	// 32768 -> 1 -> ET56
	ldy (I0),A1/*V*/	// ET57 ==> ET58
	or A1,A0,A0	// ET58 or ET56 -> ET59
	sty A0,(I0)/*V*/ ; and A1,NULL,A1	// ET59 ==> ET57
// 	WriteIMem((void *)(0x20+ 15), 0x2a00000e+((u_int32)((u_int16)Timer1Interrupt) << 6));
	ldc _Timer1Interrupt,A0	// ET5a
	ldc 47,I0	// 47 -> I0
	ashl A,B0,A	// ET5c << ET19 -> ET5d
	ldc 14,B0	// 14 -> 3 -> B0
	call _WriteIMem
	add B,A,A	// ET15 + ET5d -> ET5e
// jumped away
// 	Enable();
	call _Enable
	nop
// jumped away
	ldx (I6)-1,I2
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,StartTask	// 63 words
	.export _StartTask
_StartTask:
	ldx (I6)+1,NULL ; and NULL,NULL,A0	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+4,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 13,B0	// 13 -> 1 -> ET8
	stx B1,(I6) ; sty C0,(I6)+1
	ldc _sysTasks,C0	// ET4
	ldc 15,B1	// 15 -> 1 -> ET5
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)
	ldc 5,D1	// 5 -> 1 -> ET3


// (j < taskId && j < 5)
	ldx (I4)-2,NULL ; sub B1,ONES,A1	// 0 -> 'j'
	ldx (I4)-1,D0	// unspill 'taskId' from #0
	j F7B6
	ldx (I4)+3,C1
// jumped away
F7B7:	// (loop lvl 2)
	sub A0,D1,A0	// 'j' >= ET3 -> AT1f
	nop
	jcs F7B4	// unsigned compare
	add A0,D1,A0	// restore value
// jumped away
	ldx (I4)+2,NULL ; muluu A0,B1	// I4 += 2
	stx D0,(I4) ; sty D1,(I4)-1	// D0 spills to #0
	sty A1,(I4) ; stx C1,(I4) ; add NULL,P,D	// AT24 spills to #1
//   }
// {
//     i += sysTasks[j].stackSize;
	add C0,D0,A1	// ET4 + ET6 -> ET7
	add A1,B0,C1 ; ldy (I4),A1	// ET7 + ET8 -> AT21
	mv C1,I0	// AT21 -> ET9
	ldx (I0),C1	// ET9 ==> ETb
	add A1,C1,A1 ; ldx (I4)+1,C1	// 'i' + ETb -> 'i'
//     j++;
	sub A0,ONES,A0 ; ldx (I4),D0	// 'j' - (-1) -> 'j'
	ldy (I4)-2,D1	// unspill D1 from #0
F7B6:	// (loop lvl 2)
	sub A0,D0,A0	// 'j' < 'taskId' -> AT1e
	nop
	jcc F7B7	// unsigned compare
	add A0,D0,A0	// restore value
// jumped away
F7B4:
	ldc ___curStack,I0	// ET11
	stx A1,(I0)/*V*/ ; ldy (I6)+1,NULL	// I6 += 1
//   __curStack = (void *)i;
//   return CreateTask(&(sysTasks[j].task), sysTasks[j].name, func,
// 		    sysTasks[j].priority, sysTasks[j].stackSize);
	ldc 15,A1	// 15 -> 1 -> ET5
	muluu A0,A1	// 'j' * ET5 -> P
	ldc _sysTasks,A0	// ET4
	ldc 13,A1	// 13 -> 1 -> ET8
	add NULL,P,B	// P -> AT1d
	add A0,B0,A0	// ET4 + ET6 -> ET7
	add A0,A1,A1	// ET7 + ET8 -> AT22
	mv A1,I0	// AT22 -> ET9
	ldx (I0)+1,A1	// ET9 ==> ETa
	stx A1,(I6)+1	// ETa
	ldx (I0)-2,A1	// ET9 ==> ET14
	stx A1,(I6)+1	// ET14
	stx C1,(I6)+1	// 'func'
	ldx (I0),A1	// ET9 ==> ET18
	stx A1,(I6)+1	// ET18
	call _CreateTask
	stx A0,(I6)	// ET7
// jumped away
	ldx (I6)-5,NULL	// I6 += -5
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,PrintTasks	// 87 words
	.export _PrintTasks
_PrintTasks:
	ldc 5,A0	// 5 -> 0 -> ET2
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 16,A1	// 16 -> 'i'
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)+1
	ldc _vo_stderr,I0	// ET4
	stx I2,(I6) ; sty LC,(I6)+1
	stx LS,(I6)+1 ; sty LE,(I6)


// (vo_stderr, "\nVSOS running with %d tasks:\n",5);
	stx A0,(I6)+1	// ET2
	ldc vsosrunn_9,A0	// ET3
	stx A0,(I6)+1	// ET3
	ldx (I0),A0/*V*/	// ET4 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc 15,B1	// 15 -> 1 -> ET8
	ldc _sysTasks,C1	// ET7
	ldc _vo_stderr,I0	// ET4
	ldc 4,LC	// loop 5 iterations
// 	for(j=0; j < 5; j++)
	loop LC,F8B5-1
	ldx (I6)-3,NULL ; and NULL,NULL,B0	// I6 += -3
//loop resumes
// 	}

	ldc 13,A0	// 13 -> ETb
	muluu B0,B1	// 'j' * ET8 -> P
	add NULL,P,D	// P -> AT26
	add C1,D0,C0	// ET7 + ET9 -> ETa
	add C0,A0,A0	// ETa + ETb -> AT2b
	mv A0,I2 ; and NULL,NULL,D0	// AT2b -> ETc
	ldx (I2),A0	// ETc ==> 'k'

// (m=i+k-1; (m>i)&&((*(__x volatile u_int16 *)(u_int16)(m))==0xbabe); m--)
	j F8B11
	add A1,A0,C0	// 'i' + 'k' -> ETf
// jumped away
F8B23:	// (loop lvl 3)
	ldx (I4)-1,NULL ; sub D0,ONES,D0
// 		}
// {
// 			n++;
F8B11:	// (loop lvl 3)
	add C0,ONES,C0 ; ldx (I4)+1,NULL	// unspill AT2e from #1
	sub A1,C0,D1 ; mv C0,I2	// 'i' <= 'm' -> AT29
	ldc 47806,D1	// 47806 -> ET15
	jcs F8B9	// unsigned compare
	nop	// I4 += 1
// jumped away
	stx A0,(I4)	// AT2e spills to #1
	ldx (I2),A0/*V*/	// ET12 ==> ET13
	sub A0,D1,D1 ; ldx (I4),A0	// ET13 == ET15 -> AT2a
	nop
	jzs F8B23	// unsigned compare
	nop	// I4 += 1
// jumped away
F8B9:	// (loop lvl 2)
	ldy (I6)+1,NULL ; ldx (I4)-1,NULL
	stx D0,(I6)+1 ; muluu B0,B1	// I6 += 1
//  vo_fprintf(vo_stderr, "Task %5s Stack:%04x-%04x (%3dw), free:%d\n", sysTasks[j].name, i, i+k-1, k, n);
	add NULL,P,D ; stx A0,(I6)+1	// 'n'
	add A1,A0,A0	// 'k'
	add A0,ONES,A0	// ETf + (-1) -> ET11
	stx A0,(I6)+1 ; add C1,D0,C0	// ET11
	ldc 12,A0	// 12 -> ET1a
	stx A1,(I6)+1 ; add C0,A0,A0	// 'i'
	mv A0,I2	// AT2c -> ET1b
	ldx (I2),A0	// ET1b ==> ET1c
	stx A0,(I6)+1	// ET1c
	ldc task5ss_10,A0	// ET1d
	stx A0,(I6)+1	// ET1d
	ldx (I0),A0/*V*/	// ET4 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc 13,A0	// 13 -> ETb
	add C0,A0,A0 ; ldy (I6)-7,NULL	// I6 += -7
	mv A0,I2	// AT2d -> ETc
// 		i += sysTasks[j].stackSize;
	ldx (I2),A0	// ETc ==> ETe
	add A1,A0,A1	// 'i' + ETe -> 'i'
	sub B0,ONES,B0	// 'j' - (-1) -> 'j'
//	(0 nop's needed)
// loop end
F8B5:	// loop exit
	ldc String_3,A0	// ET22
	ldc _vo_stderr,I0	// ET4
	ldx (I6)+1,NULL	// I6 += 1
//  vo_fprintf(vo_stderr, "\n");
	stx A0,(I6)+1	// ET22
	ldx (I0),A0/*V*/	// ET4 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
	ldy (I6),LE ; ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I2
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,PrintInt	// 83 words
	.export _PrintInt
_PrintInt:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc interrupts_11,A0	// ET0
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I0,(I6) ; sty I2,(I6)+1
	ldc _vo_stderr,I0	// ET1
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6)+1
// (vo_stderr, "Interrupts: ");
	stx A0,(I6)+1	// ET0
	ldx (I0),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc 64515,I0	// 64515 -> ET3
	ldc _vo_stderr,I2	// ET1
	ldc 31,LC	// loop 32 iterations
	ldy (I0)-1,A0/*V*/ ; and B0,NULL,B0
	and A1,NULL,A1 ; ldx (I6)-2,NULL
// 	h = ((u_int32)(*(__y volatile u_int16 *)(u_int16)(0xFC03)) << 16) |(*(__y volatile u_int16 *)(u_int16)(0xFC02));
	ldy (I0),A0/*V*/ ; add A0,NULL,B1	// ET5 <<< ET7
	ldc 64513,I0	// 64513 -> ETc
	ldy (I0)-1,A0/*V*/ ; or B,A,D	// ET7 or ETa -> 'h'
// 	l = ((u_int32)(*(__y volatile u_int16 *)(u_int16)(0xFC01)) << 16) |(*(__y volatile u_int16 *)(u_int16)(0xFC00));
	add A0,NULL,B1 ; ldy (I0),A0/*V*/	// ETe <<< ETf
// 	for (i=0; i<32; i++)
	loop LC,F9B5-1
	or B,A,C	// ETf or ET12 -> 'l'
//loop resumes
// 	}
// pri
	ldc 0,C2	// clear guard bits
	sub NULL,ONES,A0	// 1 -> ET17
	ldc 0,D2	// clear guard bits
	and C0,A0,A1	// ET16 and ET17 -> ET18
	and D0,A0,A0	// ET19 and ET17 -> ET1a
	lsr D,D	// 'h' << (-1) -> 'h'
	lsr C,C	// 'l' << (-1) -> 'l'
	add A0,A0,A0	// ET1a >> (-1) -> ET1c
	or A1,A0,B1	// ET18 or ET1c -> 'pri'
// >>= 1;
// 		h >>= 1;
// 		if (pri)
	sub B1,NULL,B1	// 'pri' == (0) -> (0)
	ldc 32,A0	// 32 -> ET15
	jzs F9B9	// signed compare
	add A0,B0,A0	// ET15 + 'i' -> ET22
// jumped away
// vo_fprintf(vo_stderr, " INT%d_%s:%d->%u", i, intName[i], pri, (u_int16)(ReadFromProgramRam(0x20+i)>>6L));
	call _ReadFromProgramRam
	mv A0,I0	// ET22 -> I0
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	stx B0,(I4) ; sty B1,(I4) ; add A,NULL,B	// B0 spills to #0
	ldc 0,B2	// clear guard bits
	ldc -6,A0	// -6 -> ET25
	ashl B,A0,A ; ldy (I4),B1	// ET23 <- ET25 -> ET26
	stx A0,(I6)+1	// ET27
	ldc _intName89efd0,A0	// ET28
	ldx (I4)-1,B0	// unspill B0 from #0
	stx B1,(I6)+1 ; add A0,B0,A0	// 'pri'
	mv A0,I0	// AT33 -> ET29
	ldx (I0),A0	// ET29 ==> ET2a
	stx A0,(I6)+1	// ET2a
	ldc intds_12,A0	// ET2b
	stx B0,(I6)+1	// 'i'
	stx A0,(I6)+1	// ET2b
	ldx (I2),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-6,NULL	// I6 += -6
F9B9:	// (loop lvl 2)
	sub B0,ONES,B0	// 'i' - (-1) -> 'i'
//	(0 nop's needed)
// loop end
F9B5:	// loop exit
	ldc String_3,A0	// ET2f
	ldc _vo_stderr,I0	// ET1
	ldx (I6)+1,NULL	// I6 += 1
//  vo_fprintf(vo_stderr, "\n");
	stx A0,(I6)+1	// ET2f
	ldx (I0),A0/*V*/	// ET1 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
	ldx (I6)-1,LE
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,LoadDrivers	// 251 words
	.export _LoadDrivers
_LoadDrivers:
	ldc r_13,A0	// ET1
	ldc 53,I7
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)*,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	stx I3,(I6)+1 ; ldy (I4)-2,NULL


	stx A0,(I6)+1 ; and NULL,NULL,B1	// ET1
	ldx (I4)+2,A0	// unspill 'filename' from #0
	call _vo_fopen
	stx A0,(I6)	// 'filename'
// jumped away
	mv A0,B0	// A0 -> 'f'
	ldc 0,A0	// 0 -> 'currentConfiguration'
	ldx (I4)+2,NULL ; ldy (I6)-2,NULL	// I4 += 2
// currentConfiguration
// (initialConfiguration != -1)
	stx A0,(I4)-5	// 'currentConfiguration' spills to #0
	ldx (I4)+3,A0	// unspill 'initialConfiguration' from #-3
	sub A0,ONES,C1	// 'initialConfiguration' != (-1) -> AT41
	nop
	jzc F10B4	// signed compare
	nop
// jumped away
	ldc rb_7,A0	// ET6
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// fp
	stx A0,(I6)+1	// ET6
	ldc smodetxt_14,A0	// ET7
	call _vo_fopen
	stx A0,(I6)	// ET7
// jumped away
	ldx (I6)-1,NULL ; sub A0,NULL,C1	// I6 += -2
// (fp)
	nop
	jzs F10B9	// signed compare
	nop	// I6 += 1
// jumped away
// 		}
// 		{
// 			neededConfiguration = vo_fgetc(fp) - '0';
	call _vo_fgetc
	stx C1,(I6)	// 'fp'
// jumped away
	ldc _neededConfiguration89f2a0,I0	// ET5
	add A0,NULL,A1 ; ldy (I6)-1,NULL	// I6 += -1
	ldc 48,A0	// 48 -> 0 -> ETa
	sub A1,A0,A0	// ET9 - ETa -> ETb
	stx A0,(I0)/*V*/	// ETb ==> ET5
//  vo_fclose(fp);
	call _vo_fclose
	mv C1,I0	// 'fp' -> I0
// jumped away
F10B6:
//     if (neededConfiguration != 8 && neededConfiguration != 9)
	ldc _neededConfiguration89f2a0,I0	// ET5
	ldc 8,A1	// 8 -> 1 -> ET10
	ldx (I0),A0/*V*/	// ET5 ==> 'neededConfiguration'
	sub A0,A1,C1	// 'neededConfiguration' == ET10 -> AT42
	nop
	jzs F10B15	// unsigned compare
	nop	// 9 -> 1 -> ET11
// jumped away
	sub A1,ONES,A1
	sub A0,A1,C1	// 'neededConfiguration' == ET11 -> AT45
	nop
	jzs F10B15	// unsigned compare
	nop
// jumped away
//     }
//     {
//         GpioSetPin(0x08, 0);
	ldc 8,C0	// 8 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
F10B15:
// 	if (f)
	sub B0,NULL,B0	// 'f' == (0) -> (0)
	ldc _neededConfiguration89f2a0,I0	// ET5
	jzs F10B19	// signed compare
	nop
// jumped away
	ldy (I6)+1,NULL ; ldx (I0),A0/*V*/	// I6 += 1
// 	}
// {
//  vo_fprintf(vo_stderr,"Load drivers, config %d...\n",neededConfiguration);
	ldc _vo_stderr,I0	// ET13
	stx A0,(I6)+1	// 'neededConfiguration'
	ldc loaddrive_16,A0	// ET12
	stx A0,(I6)+1	// ET12
	ldx (I0),A0/*V*/	// ET13 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc _vo_stderr,I2	// ET13
	ldc 65227,I1	// 65227 -> ET38
	ldc 13,C1	// 13 -> 0 -> ET1e
	ldc 10,C0	// 10 -> 0 -> ET1d
	ldc _neededConfiguration89f2a0,I3	// ET5
	ldy (I4)+3,NULL ; ldx (I6)-3,NULL	// I6 += -3
// 		while (vo_fgets(s,sizeof(s),f))
	mv I4,A1 ; or NULL,ONES,A0	// I4 -> [] -> ET16
	ldx (I4)-2,NULL ; and NULL,NULL,D0	// I4 += -2
	j F10B24
	sty A0,(I4)-1	// ET3 spills to #0
// jumped away
F10B38:	// (loop lvl 2)
	ldc 91,A0	// 91 -> ET26
	ldx (I4)+3,NULL	// I4 += 3
// 			if (s[0]=='[')
	ldx (I4)+1,D1	// I4 ==> ET25
	sub D1,A0,A0	// ET25 == ET26 -> AT4d
	ldc 48,A0	// 48 -> ETa
	jzs F10B43	// signed compare
	nop	// I4 += 4
// jumped away
	ldc 32,A0	// 32 -> A0
	ldx (I4)-1,NULL
	mv I4,I0	// I4 -> [] -> I0
// 			}
// else {
// 				paramStr = strchr(s,' ');
	call _strchr
	ldx (I4)-3,NULL	// I4 += -3
// jumped away
	mv I0,A0	// 'paramStr' -> AT55
// 				if (paramStr)
	sub A0,NULL,A0	// AT55 != (0) -> (0)
	nop
	jzc F10B47	// signed compare
	nop
// jumped away
// 				}
// else {
// 					paramStr = "";
	ldc String_17,I0	// 'paramStr'
F10B49:	// (loop lvl 2)
	ldy (I4)+2,NULL ; ldx (I3),D1/*V*/	// I4 += 2
// 				if ((neededConfiguration == currentConfiguration)
// 				&& s[0] && s[0] != '#')
	ldx (I4)-2,A0	// unspill 'currentConfiguration' from #0
	sub D1,A0,A0	// 'neededConfiguration' != 'currentConfiguration' -> AT51
	nop
	jzc F10B24	// unsigned compare
	nop
// jumped away
	ldx (I4)+3,NULL	// I4 += 3
	ldx (I4)-3,A0	// I4 ==> ET25
	sub A0,NULL,A0	// ET25 == (0) -> (0)
	nop
	jzs F10B24	// signed compare
	nop
// jumped away
	ldc 35,D1	// 35 -> ET30
	sub A0,D1,A0	// ET25 == ET30 -> AT52
	ldc drivers_18,A0	// ET31
	jzs F10B24	// signed compare
	nop
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
// 				}
// {
//  vo_fprintf(vo_stderr,"Driver: %s... ",s);
	stx A1,(I6)+1	// ET16
	stx A0,(I6)+1	// ET31
	ldx (I2),A0/*V*/	// ET13 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += 1
// 					if (LoadLibraryP(s,paramStr))
	stx I0,(I6)+1	// 'paramStr'
	call _LoadLibraryP
	stx A1,(I6)	// ET16
// jumped away
	ldx (I6)-2,NULL ; sub A0,NULL,A0	// I6 += -2
	ldc 4096,A0
	jzc F10B55	// signed compare
	nop
// jumped away
	ldc notloade_19,A0	// ET3c
	ldx (I6)+1,NULL	// I6 += 1
// 					}
// else {
//  vo_fprintf(vo_stderr," not loaded");
	stx A0,(I6)+1	// ET3c
	ldx (I2),A0/*V*/	// ET13 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F10B57:	// (loop lvl 2)
	ldc String_3,A0	// ET3e
	ldx (I6)+1,NULL	// I6 += 1
//  vo_fprintf(vo_stderr,"\n");
	stx A0,(I6)+1	// ET3e
	ldx (I2),A0/*V*/	// ET13 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F10B24:	// (loop lvl 2)
	ldc 50,A0	// 50 -> ET15
	ldx (I6)+1,NULL	// I6 += 1
	stx B0,(I6)+1	// 'f'
	stx A0,(I6)+1	// ET15
	call _vo_fgets
	stx A1,(I6)	// ET16
// jumped away
	ldx (I6)-3,NULL ; sub A0,NULL,A0	// I6 += -3
	nop
	jzs F10B22	// signed compare
	nop
// jumped away
	ldx (I4)+3,NULL	// I4 += 3
	mv I4,I0	// I4 -> [] -> I0
// 		}

	call _strlen
	ldx (I4)-1,NULL	// I4 += -3
// jumped away
	add A0,NULL,D1 ; mv I4,A0	// A0 -> ET1a
	ldx (I4)-1,NULL ; add A0,D1,A0	// I4 += -1
	mv A0,I0	// ET1b -> 'p'
// (*p != '\n' && *p != '\r')
	stx I0,(I4)-1	// 'p' spills to #0
	ldx (I0),A0	// 'p' ==> ET1c
	sub A0,C0,D1	// ET1c != ET1d -> AT48
	nop
	jzs F10B40	// signed compare
	nop
// jumped away
	sub A0,C1,A0 ; ldx (I6)+1,NULL	// ET1c != ET1e -> AT49
	nop
	jzc F10B33	// signed compare
	nop
// jumped away
	j F10B40
	ldx (I6)-1,NULL
// jumped away
F10B35:	// (loop lvl 3)
	ldc 10,C0	// 10 -> 0 -> ET1d
	sub A0,C0,D1	// 'c' == ET1d -> AT4b
	nop
	jzs F10B40	// signed compare
	nop
// jumped away
	ldc 13,C1	// 13 -> 0 -> ET1e
	sub A0,C1,A0	// 'c' == ET1e -> AT4a
	nop
	jzs F10B40	// signed compare
	nop
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
F10B33:	// (loop lvl 3)
	call _vo_fgetc
	stx B0,(I6)	// 'f'
// jumped away
	ldc -1,D1	// -1 -> 0 -> ET3
	ldx (I4)+1,NULL ; ldy (I6)-1,NULL	// I4 += 1
	sty D1,(I4)-1 ; sub A0,ONES,D1	// ET3 spills to #0
	nop
	jzc F10B35	// signed compare
	nop
// jumped away
	j F10B40
	nop
// jumped away
F10B41:	// (loop lvl 3)
	ldx (I4)-1,I0	// unspill 'p' from #0
	ldx (I0),A0	// 'p' ==> ET1c
	call _isspace
	mv A0,I0	// ET1c -> I0
// jumped away
	sub A0,NULL,A0	// ET21 == (0) -> (0)
	nop
	jzs F10B38	// signed compare
	nop
// jumped away
	ldx (I4)+1,NULL	// I4 += 1
// 			}
// {
// 				*p-- = '\0';
	ldx (I4),I0	// unspill 'p' from #0
	stx D0,(I0)-1	// ET22 ==> 'p'
	stx I0,(I4)-1	// 'p' spills to #0
F10B40:	// (loop lvl 3)
	ldx (I4)+3,NULL	// I4 += 3
	ldx (I4)-2,A0	// I4 ==> ET20
	sub A0,NULL,A0	// ET20 != (0) -> (0)
	nop
	jzc F10B41	// signed compare
	nop	// I4 += 1
// jumped away
	j F10B38
	ldx (I4)-1,NULL
// jumped away
F10B22:
//  vo_fclose(f);
	call _vo_fclose
	mv B0,I0	// 'f' -> I0
// jumped away
F10B19:
// 	return n;
	add B1,NULL,A0 ; ldx (I6)-1,I3	// 'n' returns via A0
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 4096,A0	// 4096 -> ET37
F10B55:	// (loop lvl 2)
	ldx (I6)+1,NULL ; ldy (I1),D1/*V*/	// I6 += 1
// 					}
// {
// 						n++;
	sub B1,ONES,B1 ; stx I0,(I6)+1	// 'n' - (-1) -> 'n'
// (*(__y volatile u_int16 *)(u_int16)(0xfecb)) |=(1<<12);
	or D1,A0,A0	// ET39 or ET37 -> ET3a
	sty A0,(I1)/*V*/ ; and NULL,NULL,A0	// ET3a ==> ET38
// 						RunLibraryFunction(s,0,(int)paramStr);
	stx A0,(I6)+1	// ET0
	call _RunLibraryFunction
	stx A1,(I6)	// ET16
// jumped away
	j F10B57
	ldx (I6)-3,NULL	// I6 += -3
// jumped away
F10B47:	// (loop lvl 2)
// 				}
// {
// 					*paramStr=0;
// 					paramStr++;
	j F10B49
	stx D0,(I0)+1	// ET22 ==> 'paramStr'
// jumped away
F10B43:	// (loop lvl 2)
// 			}
// {
// 				currentConfiguration = s[1]-'0';
	ldx (I4)-2,D1	// I4 ==> 1 -> ET28
	sub D1,A0,D1	// ET28 - ETa -> 'currentConfiguration'
	j F10B24
	stx D1,(I4)-2	// 'currentConfiguration' spills to #0
// jumped away
F10B9:
	ldc errormo_15,A0	// ETe
// 		}
// 		else
// 		{
//  vo_printf("Error : mode file does not exist! \n");
	call _vo_printf
	stx A0,(I6)	// ETe
// jumped away
	j F10B6
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F10B4:
// 	}
// 	{
// 		neededConfiguration = initialConfiguration;
	ldc _neededConfiguration89f2a0,I0	// ET5
	j F10B6
	stx A0,(I0)/*V*/	// 'initialConfiguration' ==> ET5
// jumped away

//_____________________________________________________________
//
	.sect code,main	// 366 words
	.export _main
_main:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 65520,A1	// 65520 -> 1 -> ET0
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I0,(I6) ; sty I1,(I6)+1
	ldc 64574,I0	// 64574 -> ET1
	stx I2,(I6) ; sty I3,(I6)
// *(__y volatile u_int16 *)(u_int16)(0xFC3E)) &= ~((3<< 0)|(3<< 2));
	ldy (I0),A0/*V*/	// ET1 ==> ET2
	and A0,A1,A0	// ET2 and ET0 -> ET3
// 	TransientAddKernelSymbols();
	call _TransientAddKernelSymbols
	sty A0,(I0)/*V*/	// ET3 ==> ET1
// jumped away
	ldc _vo_stderr,I0	// ET5
	ldc _consoleFile,A0	// ET4
	ldc 64512,I2	// 64512 -> ET9
	stx A0,(I0)/*V*/ ; ldy (I6)+1,NULL	// I6 += 1
// 	vo_stdout = vo_stdin = vo_stderr = &consoleFile;
	ldc _vo_stdin,I0	// ET6
	stx A0,(I0)/*V*/ ; and NULL,NULL,D0	// ET4 ==> ET6
	ldx (I0),A0/*V*/	// ET6 ==> 'vo_stdin'
	ldc _vo_stdout,I0	// ET7
	stx A0,(I0)/*V*/	// 'vo_stdin' ==> ET7
// (*(__y volatile u_int16 *)(u_int16)(0xFC00)) =(1<< 13);
	ldc 8192,A0	// 8192 -> 1 -> ET8
	sty A0,(I2)+2/*V*/	// ET8 ==> ET9
// (*(__y volatile u_int16 *)(u_int16)(0xFC02)) = 0;
	ldc hello_20,A0	// ETe
	stx A0,(I6)+1 ; sty D0,(I2)/*V*/	// 0 -> 1 -> ETa
	ldc 64513,I2	// 64513 -> ETc
	ldx (I0),A0/*V*/	// ETa ==> ETb
// (*(__y volatile u_int16 *)(u_int16)(0xFC01)) = 0;
	sty D0,(I2)+2/*V*/ ; stx A0,(I6)	// ETa ==> ETc
// (*(__y volatile u_int16 *)(u_int16)(0xFC03)) = 0;
//  vo_fprintf(vo_stdout,"\nHello.\n");
	call _vo_fprintf
	sty D0,(I2)/*V*/	// ETa ==> ETd
// jumped away
// 	ApplyGFixes();
	call _ApplyGFixes
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
// 	appParameters[0]=0;
	ldc _appParameters,I0	// ET11
	ldc maintask_21,A0	// ET13
	ldx (I0),I0/*V*/ ; and NULL,NULL,A1	// ET11 ==> 'appParameters'
	stx A1,(I0)/*V*/	// ET10 ==> 'appParameters'
// 	loadedLibs=0;
	ldc _loadedLibs,I0	// ET12
	stx D0,(I0)/*V*/	// ETa ==> ET12
// 	thisTask->tc_Node.name = "MainTask";
	ldc _thisTask,I0	// ET15
	ldx (I0),I0/*V*/	// ET15 ==> 'thisTask'
	ldx (I0)+2,NULL	// ET16 += 2
// 	Disable();
	call _Disable
	stx A0,(I0)/*V*/	// ET13 ==> ET16
// jumped away
// (*(__y volatile u_int16 *)(u_int16)(0xfecb)) |=(1<<12);
	ldc 65227,I0	// 65227 -> ET18
	ldc 4096,A0	// 4096 -> 1 -> ET17
	ldc 10,C1	// 10 -> C1
	ldy (I0),B0/*V*/ ; ldx (I6)+1,NULL	// ET18 ==> ET19
	or B0,A0,A0	// ET19 or ET17 -> ET1a
// 	Init0();
	ldc 100,B0	// 100 -> B0
	call _Init0
	sty A0,(I0)/*V*/	// ET1a ==> ET18
// jumped away
// 	CreateCyclic(256, 10,1000 /10);
	call _CreateCyclic
	ldc 256,C0	// 256 -> C0
// jumped away
// 	InitBoard();
	call _InitBoard
	nop
// jumped away
// 	kernelDebugLevel = 0;
	ldc _kernelDebugLevel,I0	// ET1f
	ldc 12288,C0	// 12288 -> C0
	ldc 11520,B0	// 11520 -> B0
	stx A1,(I0)/*V*/ ; and NULL,NULL,B1	// 0 -> B1
// 	InitClockSpeed(12288, 11520);
	call _InitClockSpeed
	ldy (I6)+1,NULL	// ET10 ==> ET1f
// jumped away
// 	SetClockSpeedLimit(93000000);
	ldc 4416,C0	// 4416 -> C0
	ldc 1419,C1	// 1419 -> C1
	call _SetClockSpeedLimit
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
// 	SetClockSpeed(12288000);
	ldc 32768,C0	// 32768 -> C0
	ldc 187,C1	// 187 -> C1
	call _SetClockSpeed
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
// 	Enable();
	call _Enable
	nop
// jumped away
// 	Enable();
	call _Enable
	nop
// jumped away
// 	Enable();
	call _Enable
	nop
// jumped away
// 	StartOS3();
	call _StartOS3
	nop
// jumped away
// 	SetClockSpeed(0x40000000UL);
	ldc 16384,C1	// 16384 -> C1
	call _SetClockSpeed
	ldx (I6)+1,NULL ; and NULL,NULL,C0	// 0 -> C0
// jumped away
// 	SetRate(48000);
	ldc -17536,C0	// -17536 -> C0
	call _SetRate
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
// 	stdaudioout = &audioout;
	ldc _stdaudioout,I0	// ET2b
	ldc _audioout,I2	// ET2a
	ldc 5,C0	// 5 -> C0
	ldc 0,I1	// 0 -> I1
// 	ioctl(stdaudioout,5,0);
	call _ioctl
	stx I2,(I0)/*V*/ ; ldy (I6)+1,NULL	// ET2a ==> ET2b
// jumped away
// 	AddCyclic(&systemUiMessageCyclicNode,1000 /10, 0);
	ldc _systemUiMessageCyclicNode,I2	// I2
	ldc 0,C1	// 0 -> C1
	ldc 100,C0	// 100 -> C0
	call _AddCyclic
	and B,NULL,B	// 0 -> B
// jumped away
// 	if ((GpioReadPinDelay((0x00),15,0)))
	ldc 15,B0	// 15 -> B0
	ldc 0,B1	// 0 -> B1
	and NULL,NULL,C0 ; ldx (I6)+1,NULL	// 0 -> C0
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0 ; ldx (I6)+1,NULL	// ET33 == (0) -> (0)
	ldc 15,B0
	jzs F11B22	// unsigned compare
	add B0,B0,C0
// jumped away
// 	}
// 	{
// 		if ((GpioReadPinDelay((0x01),15,0)))
	ldc 0,B1	// 0 -> B1
	sub NULL,ONES,C0	// 1 -> C0
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0	// ET35 == (0) -> (0)
	ldc _vo_pdevices+20,I0
	jzs F11B25	// unsigned compare
	ldc 9,A0	// 9 -> 0 -> ET36
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// 		{
// 			LoadDrivers("S:CONFIG.TXT",9);
	stx A0,(I6)+1	// ET36
	ldc sconfigt_22,A0	// ET37
	call _LoadDrivers
	stx A0,(I6)	// ET37
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
// 		VoMassStorage((vo_pdevices[('U')-'A']) ? 'U' : 'S');
F11B25:
	ldx (I0),A0 ; ldy (I6)+1,NULL	// ET3d ==> 20 -> ET3e
	sub A0,NULL,A0	// ET3e != (0) -> (0)
	ldc 85,A1	// 85 -> AT3a
	jzc F11B29	// signed compare
	nop
// jumped away
	ldc 83,A1	// 83 -> AT3a
F11B29:
	call _VoMassStorage
	stx A1,(I6)	// AT3a
// jumped away
	ldc 15,B0	// 15 -> B0
// 	if ((GpioReadPinDelay((0x1E),15,0)))
	add B0,B0,C0
F11B22:
	ldc 0,B1	// 0 -> B1
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0	// ET42 == (0) -> (0)
	nop
	jzs F11B32	// unsigned compare
	nop
// jumped away
// 	}
// 	{
// 		if ((GpioReadPinDelay((0x1D),15,0)))
	ldc 29,C0	// 29 -> C0
	ldc 15,B0	// 15 -> B0
	and NULL,NULL,B1 ; ldx (I6)+1,NULL	// 0 -> B1
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0	// ET44 != (0) -> (0)
	nop
	jzc F11B35	// unsigned compare
	nop
// jumped away
// 		else if ((GpioReadPinDelay((0x23),15,0)))
	ldc 35,C0	// 35 -> C0
	ldc 15,B0	// 15 -> B0
	and NULL,NULL,B1 ; ldx (I6)+1,NULL	// 0 -> B1
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0	// ET48 != (0) -> (0)
	nop
	jzc F11B40	// unsigned compare
	nop
// jumped away
// 		else if ((GpioReadPinDelay((0x1B),15,0)))
	ldc 27,C0	// 27 -> C0
	ldc 15,B0	// 15 -> B0
	and NULL,NULL,B1 ; ldx (I6)+1,NULL	// 0 -> B1
	call _GpioReadPinDelay
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	sub A0,NULL,A0 ; ldx (I6)+1,NULL	// ET4d != (0) -> (0)
	ldc 9,A0	// 9 -> 0 -> ET36
	jzc F11B46	// unsigned compare
	nop	// I6 += 1
// jumped away
	or NULL,ONES,A0	// I6 += 1
//         }
//         else
//         {
//             i = LoadDrivers("S:CONFIG.TXT",-1);
	stx A0,(I6)+1	// ET56
	ldc sconfigt_22,A0	// ET37
	call _LoadDrivers
	stx A0,(I6)	// ET37
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F11B33:
	ldc _vo_stderr,I2	// ET5
	ldx (I6)+1,NULL	// I6 += 1
//  vo_fprintf(vo_stderr, "\n%d driver(s) loaded.\n",i);
	stx A0,(I6)+1	// 'i'
	ldc ddriver_25,A0	// ET5b
	stx A0,(I6)+1	// ET5b
	ldx (I2),A0/*V*/	// ET5 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
// 	PrintTasks();
	call _PrintTasks
	ldx (I6)-2,NULL	// I6 += -3
// jumped away
// 	PrintInt();
	call _PrintInt
	ldc loadsin_26,A0	// ET5e
// jumped away
//  vo_fprintf(vo_stderr,"\nLoad S:INIT.AP3...");
	stx A0,(I6)+1	// ET5e
	ldx (I2),A0/*V*/	// ET5 ==> 'vo_stderr'
	call _vo_fprintf
	stx A0,(I6)	// 'vo_stderr'
// jumped away
	ldc rb_7,A0	// ET60
	ldx (I6)-1,NULL	// I6 += 1
// 	appFile = vo_fopen("S:INIT.AP3","rb");
	stx A0,(I6)+1	// ET60
	ldc sinitap3_27,A0	// ET61
	call _vo_fopen
	stx A0,(I6)	// ET61
// jumped away
	ldc _appFile,I0	// ET63
	ldc 65153,I2	// 65153 -> ET65
	stx A0,(I0)/*V*/ ; ldy (I2),A1/*V*/	// I6 += -2
// (*(__y volatile u_int16 *)(u_int16)(0xfe81)) &= ~(1);
	ldc 65534,A0	// 65534 -> 1 -> ET64
	and A1,A0,A0 ; ldx (I6)-2,NULL	// ET66 and ET64 -> ET67
	sty A0,(I2)/*V*/ ; ldx (I0),A0/*V*/	// ET67 ==> ET65
// 	if (!appFile)
	sub A0,NULL,A0	// 'appFile' == (0) -> (0)
	ldc sinitap_28,A0
	jzs F11B62	// signed compare
	nop
// jumped away
	ldc _appFile,I2	// ET63
	ldc _console+4,I3	// ET7e
	ldc 38528,C0	// 38528 -> 3 -> C0
	ldc 152,C1	// 152 -> C1
	ldc _appParameters,I1	// ET11
	j F11B78
	ldc 2,D0	// 2 -> 1 -> ET14
// jumped away
F11B79:	// (loop lvl 2)
	ldx (I0)+1,A0/*V*/ ; ldy (I6)+1,NULL
	ldx (I0)-1,A1/*V*/ ; ldy (I4)+1,NULL
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// ET78 != (0) -> (0)
	ldc 500,A0
	jzc F11B76	// unsigned compare
	nop
// jumped away
	stx I1,(I4) ; and NULL,NULL,A0	// AT95 spills to #1
// 	}
// {
// 		console.Ioctl(&console,1, appFile->Identify(appFile,0,0));
	stx A0,(I6)+1	// ETa
	stx A0,(I6)	// ET10
	ldx (I2),I0/*V*/	// ET63 ==> 'appFile'
	mv I0,I1	// I0 -> ET79
	ldx (I1)+1,NULL	// ET79 += 1
	ldx (I1),A0/*V*/	// ET79 ==> 1 -> ET7a
	mv A0,LR0
	ldx (I4)-1,I1	// unspill AT95 from #1
	jr
	ldc lo(F11B80),LR0	// (return address)
// jumped away
F11B80:	// (loop lvl 2)
	ldc _console,I0	// I0
	ldx (I6)-1,NULL	// I6 += 1
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET7b
	stx A0,(I6)	// ET6d
	ldx (I3),A0	// ET7e ==> 4 -> ET7f
	mv A0,LR0
	jr
	ldc lo(F11B81),LR0	// (return address)
// jumped away
F11B81:	// (loop lvl 2)
	ldy (I6)-1,NULL ; ldx (I1),A0/*V*/	// I6 += 1
// 		result = RunAppFile3(appParameters);
	call _RunAppFile3
	stx A0,(I6)	// 'appParameters'
// jumped away
	ldx (I6)-1,NULL ; add A0,NULL,D1	// I6 += -1

	and A,NULL,A ; ldx (I6),B0/*V*/ ; ldy (I6),B1/*V*/

// 		__asm {
// 			and a,null,a; ldx (i6),b0; ldy (i6),b1
// 		}
// 		if (result != 0)
	sub D1,NULL,D1	// 'result' == (0) -> (0)
	ldc appexit_30,A0	// ET82
	jzs F11B78	// signed compare
	nop
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// {
//  vo_printf("\nApp exit, result: %d.\n",result);
	stx D1,(I6)+1	// 'result'
	call _vo_printf
	stx A0,(I6)	// ET82
// jumped away
	ldx (I6)-1,NULL	// I6 += 1
// 			DelayL(10000000);
	stx C0,(I6)+1	// C0
	call _DelayL
	stx C1,(I6)	// C1
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F11B78:	// (loop lvl 2)
	ldx (I2),I0/*V*/	// ET63 ==> 'appFile'
	ldx (I0)+3,A0/*V*/	// 'appFile' ==> ET75
	and A0,D0,A0	// ET75 and ET14 -> ET76
	ldc 500,A0	// 500 -> 1 -> ET85
	jzc F11B79	// compare against zero
	nop	// ET77 += 3
// jumped away
	ldx (I0)-3,NULL ; ldy (I6)+1,NULL
	ldx (I4)+1,NULL
F11B76:
// 	Delay(500);
	call _Delay
	ldy (I4)-1,NULL ; stx A0,(I6)
// jumped away
	ldc restart_31,A0	// ET86
//  vo_printf("Restart.\n");
	call _vo_printf
	stx A0,(I6)	// I6 += 1
// jumped away
// 	Disable();
	call _Disable
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
// (*(__y volatile u_int16 *)(u_int16)(0xFC03)) = 0;
	ldc 64515,I0	// 64515 -> ETd
	and NULL,NULL,A0	// 0 -> 1 -> ETa
	sty A0,(I0)-1/*V*/	// ETa ==> ETd
// (*(__y volatile u_int16 *)(u_int16)(0xFC02)) = 0;
	sty A0,(I0)/*V*/	// ETa ==> ETb
// (*(__y volatile u_int16 *)(u_int16)(0xFC01)) = 0;
	ldc 64513,I0	// 64513 -> ETc
	sty A0,(I0)-1/*V*/	// ETa ==> ETc
// (*(__y volatile u_int16 *)(u_int16)(0xFC00)) =(1<< 13);
	ldc 8192,A0	// 8192 -> 1 -> ET8
	sty A0,(I0)/*V*/	// ET8 ==> ET9
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc sinitap_28,A0	// ET68
F11B62:
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// {
//  vo_printf("\nS:INIT.AP3 not found.\n");
	call _vo_printf
	stx A0,(I6)	// ET68
// jumped away
	ldc nothingto_29,A0	// ET6a
//  vo_printf("Nothing to do.");
	call _vo_printf
	stx A0,(I6)	// I6 += 1
// jumped away
	ldc 64515,I0	// 64515 -> ETd
	and NULL,NULL,A0 ; ldx (I6)-1,NULL	// I6 += -1
// (*(__y volatile u_int16 *)(u_int16)(0xFC03)) = 0;
	sty A0,(I0)-1/*V*/	// ETa ==> ETd
// (*(__y volatile u_int16 *)(u_int16)(0xFC02)) = 0;
	sty A0,(I0)/*V*/	// ETa ==> ETb
// (*(__y volatile u_int16 *)(u_int16)(0xFC01)) = 0;
	ldc 64513,I0	// 64513 -> ETc
	sty A0,(I0)-1/*V*/	// ETa ==> ETc
// (*(__y volatile u_int16 *)(u_int16)(0xFC00)) =(1<< 13);
	ldc 8192,A0	// 8192 -> 1 -> ET8
// 		Enable();
	call _Enable
	sty A0,(I0)/*V*/	// ET8 ==> ET9
// jumped away
// 		Enable();
	call _Enable
	nop
// jumped away
	ldc 83,A0	// 83 -> 0 -> ET3f
	ldx (I6)+1,NULL	// I6 += 1
// 		VoMassStorage('S');
	call _VoMassStorage
	stx A0,(I6)	// ET3f
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
// 		while(1)
F11B72:
// 		}
// {
// 			if ((*(__y volatile u_int16 *)(u_int16)(0xFE01)) == 0x03)
	ldc 65025,I0	// 65025 -> ET6e
	ldc 3,A0	// 3 -> 1 -> ET71
	ldy (I0),A1/*V*/	// ET6e ==> ET6f
	sub A1,A0,A1	// ET6f == ET71 -> AT91
	ldc 65056,I0	// 65056 -> ET72
	jzc F11B72	// unsigned compare
	sub NULL,ONES,A0	// 1 -> 1 -> ET34
// jumped away
// 			}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFE20)) = 1;
	sty A0,(I0)+1/*V*/	// ET34 ==> ET72
// (*(__y volatile u_int16 *)(u_int16)(0xFE21)) = 0x4ea9;
	ldc 20137,A0	// 20137 -> 1 -> ET73
	j F11B72
	sty A0,(I0)/*V*/	// ET73 ==> ET74
// jumped away
F11B46:
// 		}
// 		{
// 			LoadDrivers("S:CONFIG.TXT",9);
	stx A0,(I6)+1	// ET36
	ldc sconfigt_22,A0	// ET37
	call _LoadDrivers
	stx A0,(I6)	// ET37
// jumped away
	ldc settingfl_24,A0	// ET4f
	ldx (I6)-1,NULL	// I6 += 1
//  vo_printf("Setting flash drive as mass storage device on PC \n");
	call _vo_printf
	stx A0,(I6)	// ET4f
// jumped away
	ldc _vo_pdevices+5,I0	// ET53
	ldx (I0),A0	// I6 += -1
// 			VoMassStorage((vo_pdevices[('F')-'A']) ? 'F' : 'S');
	sub A0,NULL,A0	// ET54 != (0) -> (0)
	ldc 70,A1	// 70 -> AT52
	jzc F11B53	// signed compare
	nop
// jumped away
	ldc 83,A1	// 83 -> AT52
F11B53:
	call _VoMassStorage
	stx A1,(I6)	// AT52
// jumped away
	j F11B33
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F11B40:
	ldc settingin_23,A0	// ET49
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// 		{
//  vo_printf("Setting internal SPI Flash as mass storage device on PC \n");
	call _vo_printf
	stx A0,(I6)	// ET49
// jumped away
	ldc 83,A0	// 83 -> 0 -> ET3f
// 			VoMassStorage('S');
	call _VoMassStorage
	stx A0,(I6)	// I6 += 1
// jumped away
	j F11B33
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F11B35:
	ldx (I6)+1,NULL ; and NULL,NULL,A0	// I6 += 1
// 		}
// 		{
// 			i = LoadDrivers("S:CONFIG.TXT",0);
	stx A0,(I6)+1	// ET10
	ldc sconfigt_22,A0	// ET37
	call _LoadDrivers
	stx A0,(I6)	// ET37
// jumped away
	j F11B33
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
F11B32:
	ldx (I6)+1,NULL ; or NULL,ONES,A0	// I6 += 1
// 	}
// 	else
// 	{
// 		i = LoadDrivers("S:CONFIG.TXT",-1);
	stx A0,(I6)+1	// ET56
	ldc sconfigt_22,A0	// ET37
	call _LoadDrivers
	stx A0,(I6)	// ET37
// jumped away
	j F11B33
	ldx (I6)-2,NULL	// I6 += -2
// jumped away

//_____________________________________________________________
//
	.sect data_x,maininit_x	// 79 words
	.export _appIXYStart
_appIXYStart:
	.word 13056, 7168, 3072
	.export _sysTasks
_sysTasks:
	.word 0
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.word String_32, 512, 5, 0
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.word String_33, 64, 0, 0
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.word String_34, 2, 1, 0
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.word String_35, 2, 1, 0
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.zero 1
	.word String_36, 380, 10
_neededConfiguration89f2a0:
	.word 0

//_____________________________________________________________
//
	.sect data_x,mainconst_x	// 710 words
e_1:
	.word "E'"

	.zero 1
String_2:
	.word "'\n"

	.zero 1
String_3:
	.word "\n"

	.zero 1
devnulwr_4:
	.word "DevNulWr"

	.zero 1
d_5:
	.word "(%d)"

	.zero 1
c_6:
	.word "  %c  "

	.zero 1
rb_7:
	.word "rb"

	.zero 1
x0notze_8:
	.word "X:0 not zero\n"

	.zero 1
vsosrunn_9:
	.word "\nVSOS running with %d tasks:\n"

	.zero 1
task5ss_10:
	.word "Task %5s Stack:%04x-%04x (%3dw), free:%d\n"

	.zero 1
_intName89efd0:
	.word String_37, String_38, String_39, String_40, String_41, String_42, String_43, String_44
	.word String_45, String_46, String_47, String_48, String_49, String_50, String_51, String_52
	.word String_53, String_54, String_55, String_56, String_57, String_58, String_59, String_60
	.word String_61, String_62, String_63, String_64, String_65, String_66, String_67, String_68
interrupts_11:
	.word "Interrupts: "

	.zero 1
intds_12:
	.word " INT%d_%s:%d->%u"

	.zero 1
r_13:
	.word "r"

	.zero 1
smodetxt_14:
	.word "S:mode.txt"

	.zero 1
errormo_15:
	.word "Error : mode file does not exist! \n"

	.zero 1
loaddrive_16:
	.word "Load drivers, config %d...\n"

	.zero 1
String_17:

	.zero 1
drivers_18:
	.word "Driver: %s... "

	.zero 1
notloade_19:
	.word " not loaded"

	.zero 1
hello_20:
	.word "\nHello.\n"

	.zero 1
maintask_21:
	.word "MainTask"

	.zero 1
sconfigt_22:
	.word "S:CONFIG.TXT"

	.zero 1
settingin_23:
	.word "Setting internal SPI Flash as mass storage device on PC \n"

	.zero 1
settingfl_24:
	.word "Setting flash drive as mass storage device on PC \n"

	.zero 1
ddriver_25:
	.word "\n%d driver(s) loaded.\n"

	.zero 1
loadsin_26:
	.word "\nLoad S:INIT.AP3..."

	.zero 1
sinitap3_27:
	.word "S:INIT.AP3"

	.zero 1
sinitap_28:
	.word "\nS:INIT.AP3 not found.\n"

	.zero 1
nothingto_29:
	.word "Nothing to do."

	.zero 1
appexit_30:
	.word "\nApp exit, result: %d.\n"

	.zero 1
restart_31:
	.word "Restart.\n"

	.zero 1
String_32:
	.word "I/O"

	.zero 1
String_33:
	.word "Int"

	.zero 1
String_34:
	.word "Net"

	.zero 1
String_35:
	.word "UI"

	.zero 1
String_36:
	.word "DECOD"

	.zero 1
String_37:
	.word "DAC"

	.zero 1
String_38:
	.word "USB"

	.zero 1
String_39:
	.word "XPERIP"

	.zero 1
String_40:
	.word "SP0"

	.zero 1
String_41:
	.word "SP1"

	.zero 1
String_42:
	.word "MAC1"

	.zero 1
String_43:
	.word "MAC0"

	.zero 1
String_44:
	.word "GP0"

	.zero 1
String_45:
	.word "GP1"

	.zero 1
String_46:
	.word "GP2"

	.zero 1
String_47:
	.word "MAC2"

	.zero 1
String_48:
	.word "I2S"

	.zero 1
String_49:
	.word "TX"

	.zero 1
String_50:
	.word "RX"

	.zero 1
String_51:
	.word "TI0"

	.zero 1
String_52:
	.word "TI1"

	.zero 1
String_53:
	.word "TI2"

	.zero 1
String_54:
	.word "FM"

	.zero 1
String_55:
	.word "SRC"

	.zero 1
String_56:
	.word "DAO"

	.zero 1
String_57:
	.word "RTC"

	.zero 1
String_58:
	.word "RDS"

	.zero 1
String_59:
	.word "SPDIFR"

	.zero 1
String_60:
	.word "SPDIFT"

	.zero 1
String_61:
	.word "POS"

	.zero 1
String_62:
	.word "REG"

	.zero 1
String_63:
	.word "PWM"

	.zero 1
String_64:
	.word "SAR"

	.zero 1
String_65:
	.word "ERR"

	.zero 1
String_66:
	.word "ERR"

	.zero 1
String_67:
	.word "ERR"

	.zero 1
String_68:
	.word "ERR"

	.zero 1

	.end
