
//_____________________________________________________________
//
	.sect code,OkResultFunction	// 3 words
	.export _OkResultFunction
_OkResultFunction:
// 	return 0;
	and NULL,NULL,A0	// 0 -> 1 -> ET0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,UsbMapCreate	// 2 words
	.export _UsbMapCreate
_UsbMapCreate:
//   return &usbMapper;
	jr
	ldc _usbMapper,A0	// ET0
// jumped away

//_____________________________________________________________
//
	.sect code,UsbMapRead	// 32 words
	.export _UsbMapRead
_UsbMapRead:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	ldc _usbDisk,I0	// ET0
	stx I2,(I6)+1 ; ldy (I4)-6,NULL
	ldx (I4)+1,A0	// unspill 'data' from #-6
// err
	stx A0,(I6)+1	// 'data'
	ldx (I4)+1,A1	// unspill 'blocks' from #-5
	stx A1,(I6)+1	// 'blocks'
	ldx (I4)+1,B0	// unspill B0 from #0
	ldx (I4)+3,B1	// unspill B1 from #0
	stx B0,(I6)+1	// B0
	stx B1,(I6)	// B1
	ldx (I0),I0/*V*/	// ET0 ==> 'usbDisk'
	mv I0,I2	// I0 -> ET2
	ldx (I2)+7,NULL	// ET2 += 7
	ldx (I2),A0/*V*/	// ET2 ==> 7 -> ET3
	mv A0,LR0
	jr
	ldc lo(F2B3),LR0	// (return address)
// jumped away
F2B3:
	ldx (I6)-4,NULL ; add A1,NULL,A0	// I6 += -4
// blocks;
	ldx (I6)-1,I2	// 'blocks' returns via A0
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,UsbMapWrite	// 50 words
	.export _UsbMapWrite
_UsbMapWrite:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I0,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty LC,(I6)+1
	stx LS,(I6) ; sty LE,(I6)
// bl
// (bl < blocks)
	ldx (I4)-4,NULL ; and NULL,NULL,A1	// 0 -> 'bl'
	ldx (I4)+1,D0	// unspill D0 from #0
	ldx (I4)-3,D1	// unspill D1 from #0
	ldx (I4)+1,B0	// unspill AT14 from #-6
	ldx (I4)+5,B1	// unspill 'blocks' from #-5
	sub B1,A1,A0	// 'blocks' <= 'bl' -> ATe
	ldc 256,C0	// 256 -> 0 -> ET7
	jle F3B4	// signed compare
	ldc _usbDisk,I2	// ET2
// jumped away
	add A0,ONES,A0	// ATe + (-1) -> ATe
	loop A0,F3B4-1
	nop
//loop resumes
	ldx (I6)+1,NULL	// I6 += 1
//   }
// {
//     usbDisk->BlockWrite(usbDisk, firstBlock, blocks, data);
	stx B0,(I6)+1	// AT14
	stx B1,(I6)+1	// 'blocks'
	stx D0,(I6)+1	// D0
	stx D1,(I6)	// D1
	ldx (I2),I0/*V*/	// ET2 ==> 'usbDisk'
	mv I0,I1	// I0 -> ET4
	ldx (I1)+7,NULL	// ET4 += 8
	ldx (I1)+1,NULL	// ...
	ldx (I1),A0/*V*/	// ET4 ==> 8 -> ET5
	mv A0,LR0
	jr
	ldc lo(F3B7),LR0	// (return address)
// jumped away
F3B7:	// (loop lvl 2)
	sub D,ONES,D ; ldx (I6)-4,NULL	// I6 += -4
	sub A1,ONES,A1	// 'bl' - (-1) -> 'bl'
//     data += 256;
//     firstBlock++;
//     bl++;
	add B0,C0,B0	// AT14 + ET7 -> AT14
//	(0 nop's needed)
// loop end
F3B4:	// loop exit
//   return bl;
	add A1,NULL,A0 ; ldy (I6),LE	// 'bl' returns via A0
	ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,I0
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,UsbMapFlush	// 28 words
	.export _UsbMapFlush
_UsbMapFlush:
	ldx (I6)+1,NULL ; and NULL,NULL,A0	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	ldc _usbDisk,I0	// ET3
	stx I2,(I6)+1 ; and NULL,NULL,A1
// 	usbDisk->BlockRead(usbDisk, 0, 0,0);
	stx A1,(I6)+1 ; and B,NULL,B	// ET0
	stx A0,(I6)+1	// ET1
	stx B0,(I6)+1	// B0
	stx B1,(I6)	// B1
	ldx (I0),I0/*V*/	// ET3 ==> 'usbDisk'
	mv I0,I2	// I0 -> ET5
	ldx (I2)+7,NULL	// ET5 += 7
	ldx (I2),A0/*V*/	// ET5 ==> 7 -> ET6
	mv A0,LR0
	jr
	ldc lo(F4B3),LR0	// (return address)
// jumped away
F4B3:
	ldx (I6)-4,NULL ; add A1,NULL,A0	// I6 += -4
// 	return 0;
	ldx (I6)-1,I2	// ET0 returns via A0
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,MyInitUSBDescriptors	// 36 words
	.export _MyInitUSBDescriptors
_MyInitUSBDescriptors:
	ldx (I6)+1,NULL	// I6 += 1
	stx A0,(I6) ; sty A1,(I6)+1
	stx I0,(I6) ; sty I1,(I6)+1
	ldc _usb,I0	// ET0
	stx I2,(I6)
// 	if (usb)
	ldx (I0),A0/*V*/	// ET0 ==> 'usb'
	sub A0,NULL,A0	// 'usb' == (0) -> (0)
	ldc 2,A1	// 2 -> 0 -> ET2
	jzs F5B1	// signed compare
	nop
// jumped away
// 	}
// {
// 	  usb->descriptorTable[2] = myLanguageStr;
	add A0,A1,A0	// 'usb' + ET2 -> AT15
	mv A0,I2	// AT15 -> ET3
	ldc _myLanguageStr,A0	// ET1
	stx A0,(I2)+1	// ET1 ==> ET3
// 	  usb->descriptorTable[3] = myVendorNameStr;
	ldc _myVendorNameStr,A0	// ET4
	stx A0,(I2)+1	// ET4 ==> ET3
// 	  usb->descriptorTable[4]  = myModelNameStr;
	ldc _myModelNameStr,A0	// ET7
	stx A0,(I2)+1	// ET7 ==> ET3
// 	  usb->descriptorTable[5] = mySerialNumberStr;
	ldc _mySerialNumberStr,A0	// ETa
	stx A0,(I2)-4	// ETa ==> ET3
// 	  usb->descriptorTable[0] = myDeviceDescriptor_MassStorage;
	ldc _myDeviceDescriptor_MassStorage,A0	// ETd
	ldx (I0),I1/*V*/	// ET0 ==> 'usb'
	stx A0,(I1)/*V*/	// ETd ==> 'usb'
// 	  usb->descriptorTable[1] = myConfigurationDescriptor_MassStorage;
	ldc _myConfigurationDescriptor_MassStorage,A0	// ETe
	stx A0,(I2)	// ETe ==> ET3
// 	  usb->configurationDescriptorSize = 32;
	ldc 32,A0	// 32 -> 1 -> ET11
	ldx (I0),I0/*V*/	// ET0 ==> 'usb'
	ldx (I0)+7,NULL	// ET13 += 16
	ldx (I0)+7,NULL	// ...
	ldx (I0)+2,NULL	// ...
	stx A0,(I0)/*V*/	// ET11 ==> ET13
F5B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,I0
	ldy (I6),A1 ; ldx (I6)-1,A0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,PowerSetVoltages2	// 36 words
	.export _PowerSetVoltages2
_PowerSetVoltages2:
	ldx (I6)+2,NULL	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 31,A0	// 31 -> 1 -> ET1
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; ldy (I4)-2,NULL
	ldx (I4)+2,I0	// unspill 'volt' from #-2
// = (volt[voltCorePlayer] & 31) |
//         ((volt[voltIoPlayer] & 31) << 5) |
//         ((volt[voltAnaPlayer] & 31) << 10);
	ldx (I0)+1,A1	// 'volt' ==> ET0
	and A1,A0,B0 ; ldx (I0)+1,A1	// ET0 and ET1 -> ET2
	and A1,A0,B1	// ET5 and ET1 -> ET6
	ldc 5,A1	// 5 -> 0 -> ET7
	ashl B1,A1,A1	// ET6 << ET7 -> ET8
	or B0,A1,A1 ; ldx (I0),B0	// ET2 or ET8 -> ET9
	ldc 65232,I0	// 65232 -> ET11
	and B0,A0,B0	// ETc and ET1 -> ETd
	ldc 10,A0	// 10 -> 0 -> ETe
	ashl B0,A0,A0	// ETd << ETe -> ETf
	or A1,A0,B0 ; ldy (I0),A1/*V*/	// ET9 or ETf -> 'v'
// (*(__y volatile u_int16 *)(u_int16)(0xFED0)) = ((*(__y volatile u_int16 *)(u_int16)(0xFED0)) & 0x8000U) | v;
	ldc 32768,A0	// 32768 -> 1 -> ET14
	and A1,A0,A0	// ET12 and ET14 -> ET15
	ldc 8,A1	// 8 -> 1 -> ET17
	or A0,B0,A0	// ET15 or 'v' -> ET16
	sty A0,(I0)-2/*V*/	// ET16 ==> ET11
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) |=(1<<3);
	ldy (I0),A0/*V*/	// ET18 ==> ET19
	or A0,A1,A0	// ET19 or ET17 -> ET1a
	ldc 65527,A1	// 65527 -> 1 -> ET1b
	sty A0,(I0)/*V*/	// ET1a ==> ET18
// (*(__y volatile u_int16 *)(u_int16)(0xFECE)) &= ~(1<<3);
	ldy (I0),A0/*V*/	// ET18 ==> ET1c
	and A0,A1,A0	// ET1c and ET1b -> ET1d
	sty A0,(I0)/*V*/ ; ldx (I6)-1,I0	// ET1d ==> ET18
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,VoMassStorage	// 175 words
	.export _VoMassStorage
_VoMassStorage:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 65,A1	// 65 -> 0 -> ET6
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	ldc _usbDisk,I2	// ET1
	stx I3,(I6)+1 ; ldy (I4)-2,NULL
// hw
// = vo_pdevices[deviceLetterUppercase-'A'];
	ldx (I4)+2,A0 ; and NULL,NULL,D1	// unspill 'deviceLetterUppercase' from #0
	sub A0,A1,A1	// 'deviceLetterUppercase' - ET6 -> ET7
	ldc _vo_pdevices,A0	// ET4
	add A0,A1,A0	// ET4 + ET7 -> AT61
	mv A0,I0	// AT61 -> ET8
	ldc _USB,A0	// ETa
	ldx (I0),I1	// ET8 ==> ET9
	ldc _usb,I0	// ETb
	stx I1,(I2)/*V*/	// ET9 ==> ET1
//   usb = &USB;
	stx A0,(I0)/*V*/ ; and NULL,NULL,A0	// ETa ==> ETb

// ("USB publishing disk: %s.\n",usbDisk->Identify(usbDisk,0,0));
	mv I1,I0 ; sub NULL,ONES,B1	// 0 -> 1 -> ETc
	stx D1,(I6)+1 ; ldy (I1)+1,NULL	// ETc
	stx A0,(I6)	// ETd
	ldx (I1),A0	// 1 -> 1 -> ETe
	mv A0,LR0
	jr
	ldc lo(F7B3),LR0	// (return address)
// jumped away
F7B3:
	ldx (I6)-1,NULL	// I6 += 1
	stx A0,(I6)+1	// ET11
	ldc usbpublis_1,A0	// ET12
	call _vo_printf
	stx A0,(I6)	// ET12
// jumped away
	ldc 6,C0	// 6 -> C0
	ldy (I6)-1,NULL ; ldx (I2),I2/*V*/	// I6 += -2
// 	ioctl(usbDisk,6,&geometry);
	call _ioctl
	ldc _geometry,I1	// I1
// jumped away
// 	usbMapper.blocks = geometry.totalSectors;
	ldc _geometry+1,I0	// ET17
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc _usbMapper+2,I0	// ET1b
	stx A0,(I0)+1
//  vo_printf("Size %0.1f MB.\n",((float)(usbMapper.blocks))/2048);
	call uint_to_df
	stx A1,(I0)-1
// jumped away
	ldc 12,D0	//  -> D0
	and NULL,NULL,C0	//  -> C0
	call df_div
	ldc 16384,C1	//  -> C1
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
	stx A0,(I6)+1	// A0
	ldc size01f_2,A0	// ET1f
	stx A1,(I6)+1	// A1
	stx B0,(I6)+1	// B0
	call _vo_printf
	stx A0,(I6)	// ET1f
// jumped away
	ldc scsistart_3,A0	// ET21
	ldx (I6)-3,NULL	// I6 += 1
//  vo_printf("SCSI START\n");
	call _vo_printf
	stx A0,(I6)	// ET21
// jumped away
//   MyScsiReset();
	call _MyScsiReset
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
//   ScsiIdle = 0;
	ldc 16384,C1	// 16384 -> C1
	ldc 65228,I2	// 65228 -> ET24
	ldc _ScsiIdle,I0	// ET23
	stx D1,(I0)/*V*/ ; ldy (I2),B0/*V*/ ; and NULL,NULL,C0	// ETc ==> ET23
//   }
// =(*(__y volatile u_int16 *)(u_int16)(0xfecc));
	ldc 65227,I0	// 65227 -> ET26
//     cf1 =(*(__y volatile u_int16 *)(u_int16)(0xfecb));
//     SetClockSpeed(0x40000000UL);
	call _SetClockSpeed
	ldy (I0),A1/*V*/ ; ldx (I6)+1,NULL	// ET26 ==> 'cf1'
// jumped away
	ldc _v7ed548,A0	// ET2a
	ldx (I6)+1,NULL ; sty B0,(I2)/*V*/	// I6 += 1
// (*(__y volatile u_int16 *)(u_int16)(0xfecc)) = cf0;
// (*(__y volatile u_int16 *)(u_int16)(0xfecb)) = cf1;
//   }
// (v);
	call _PowerSetVoltages2
	sty A1,(I0)/*V*/ ; stx A0,(I6)	// 'cf1' ==> ET26
// jumped away
//   MyInitUSB(1);
	call _MyInitUSB
	stx B1,(I6)	// I6 += 1
// jumped away
	ldc 239,B1	// 239 -> 0 -> ET4f
	ldc 3,B0	// 3 -> 0 -> ET4e
	ldc 20,C0	// 20 -> 1 -> ET46
	ldc 64658,I1	// 64658 -> ET48
	ldc 65057,I3	// 65057 -> ET45
	ldc 64736,I2	// 64736 -> ET32
	ldc 32770,A0	// 32770 -> 1 -> ET2b
	ldc 65233,I0	// 65233 -> ET2c
	sty A0,(I0)/*V*/ ; add B0,ONES,C1
	ldc 65532,A0	// 65532 -> 1 -> ET2d
	ldc 64562,I0	// 64562 -> ET2e
	ldy (I0),A1/*V*/ ; add B0,NULL,D0
// (*(__y volatile u_int16 *)(u_int16)(0xFED1))   = 0x8002;
// (*(__y volatile u_int16 *)(u_int16)(0xFC32))  &= ~3;
	sub NULL,ONES,D1 ; ldx (I6)-1,NULL	// ET2e ==> ET2f
	and A1,A0,A0	// ET2f and ET2d -> ET30
	ldc 16,A1	// 16 -> 1 -> ET35
	sty A0,(I0)/*V*/	// ET30 ==> ET2e
// (*(__y volatile u_int16 *)(u_int16)(0xFCE0))   |=  3;
	ldy (I2),A0/*V*/	// ET32 ==> ET33
	or A0,B0,A0	// ET33 or ET31 -> ET34
	sty A0,(I2)/*V*/	// ET34 ==> ET32
// (*(__y volatile u_int16 *)(u_int16)(0xFC32))  |=0x10;
	ldc 65227,I2	// 65227 -> ET26
	ldy (I0),A0/*V*/	// ET2e ==> ET36
	or A0,A1,A0	// ET36 or ET35 -> ET37
	sty A0,(I0)+1/*V*/	// ET37 ==> ET2e
// (*(__y volatile u_int16 *)(u_int16)(0xFC33))      |= 0x80;
	ldc 128,A0	// 128 -> 1 -> ET38
	ldy (I0),A1/*V*/	// ET39 ==> ET3a
	or A1,A0,A0	// ET3a or ET38 -> ET3b
	ldc 20137,A1	// 20137 -> 1 -> ET44
	sty A0,(I0)/*V*/	// ET3b ==> ET39
//   while(1)
	j F7B18
	ldc 65025,I0	// 65025 -> ET40
// jumped away
F7B23:	// (loop lvl 2)
// 	}

	ldy (I0),A0/*V*/	// ET40 ==> 'c'
// ((c == 3) || (c == 239))
	sub A0,B0,A0	// 'c' == ET4e -> AT5c
	nop
	jzs F7B27	// signed compare
	add A0,B0,A0	// restore value
// jumped away
	sub A0,B1,A0	// 'c' == ET4f -> AT5f
	nop
	jzs F7B27	// signed compare
	nop
// jumped away
F7B18:	// (loop lvl 2)
	ldx (I4)+1,NULL ; ldy (I2),A0/*V*/	// I4 += 1
	stx A1,(I4)	// AT62 spills to #1
//   }
// *(__y volatile u_int16 *)(u_int16)(0xfecb)) |=(1<<12);
	ldc 4096,A1	// 4096 -> ET3d
	or A0,A1,A0 ; ldx (I4)-1,A1	// ET3e or ET3d -> ET3f
// 	MyUSBHandler();
	call _MyUSBHandler
	sty A0,(I2)/*V*/	// ET3f ==> ET26
// jumped away
// 	if ((*(__y volatile u_int16 *)(u_int16)(0xFE01)) == 0x03)
	ldy (I0),A0/*V*/ ; ldx (I4)+1,NULL	// ET40 ==> ET41
	sub A0,D0,A0	// ET41 != ET31 -> AT5a
	nop
	jzc F7B21	// unsigned compare
	nop
// jumped away
	stx I0,(I4)
// 	}
// {
// (*(__y volatile u_int16 *)(u_int16)(0xFE20)) = 1;
	ldc 65056,I0	// 65056 -> ET43
	sty D1,(I0)/*V*/ ; ldx (I4),I0	// ETe ==> ET43
// (*(__y volatile u_int16 *)(u_int16)(0xFE21)) = 0x4ea9;
	sty A1,(I3)/*V*/	// ET44 ==> ET45
F7B21:	// (loop lvl 2)
	stx I0,(I4)	// AT64 spills to #1
//     if (ScsiIdle == 20  && ScsiState() == SCSI_READY_FOR_COMMAND &&
// 	((*(__y volatile u_int16 *)(u_int16)(0xFC90 + 0x02)) &(1<<1)))
	ldc _ScsiIdle,I0	// ET23
	ldx (I0),A0/*V*/	// ET23 ==> 'ScsiIdle'
	ldx (I4)-1,I0 ; sub A0,C0,A0	// unspill AT64 from #1
	nop
	jzc F7B23	// unsigned compare
	nop
// jumped away
	call _ScsiState
	nop
// jumped away
	sub A0,NULL,A0	// ET47 != (0) -> (0)
	nop
	jzc F7B23	// signed compare
	nop
// jumped away
	ldy (I1),A0/*V*/	// ET48 ==> ET49
	and A0,C1,A0	// ET49 and ET1a -> ET4b
	ldc 32768,A0	// 32768 -> 1 -> ET52
	jzs F7B23	// compare against zero
	nop
// jumped away
// (*(__y volatile u_int16 *)(u_int16)(0xFC80)) = 0x8000U;
	ldc 64640,I0	// 64640 -> ET53
	sty A0,(I0)/*V*/ ; ldx (I6)-1,I3	// ET52 ==> ET53
// (*(__y volatile u_int16 *)(u_int16)(0xfed2)) &= ~(1<<10);
	ldc 64511,A0	// 64511 -> 1 -> ET54
	ldc 65234,I0	// 65234 -> ET55
	ldy (I0),A1/*V*/	// ET55 ==> ET56
	and A1,A0,A0	// ET56 and ET54 -> ET57
	sty A0,(I0)/*V*/	// ET57 ==> ET55
//   return 123;
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	ldc 123,A0	// 123 -> 0 -> ET58
// jumped away
F7B27:
	ldc ctrlcres_4,A0	// ET50
	ldx (I6)+1,NULL	// I6 += 1
// 		}
// {
//  vo_printf("Ctrl-C Reset\n");
	call _vo_printf
	stx A0,(I6)	// ET50
// jumped away
	ldc 65056,I0	// 65056 -> ET43
	sub NULL,ONES,A0 ; ldx (I6)-1,NULL	// I6 += -1
// (*(__y volatile u_int16 *)(u_int16)(0xFE20)) = 1;
	sty A0,(I0)+1/*V*/	// ETe ==> ET43
// (*(__y volatile u_int16 *)(u_int16)(0xFE21)) = 0x4ea9;
	ldc 20137,A0	// 20137 -> 1 -> ET44
	sty A0,(I0)/*V*/	// ET44 ==> ET45
// 			while (1)
F7B34:
	j F7B34
	nop
// jumped away

//_____________________________________________________________
//
	.sect data_x,mscinit_x	// 30 words
	.export _usbMapper
_usbMapper:
	.word 268, 256, lo(1986560), hi(1986560), 0, _UsbMapCreate, _OkResultFunction, _UsbMapRead
	.word _UsbMapWrite, 0, _UsbMapFlush, 0
	.export _usb
_usb:
	.word 0
	.export _mySerialNumberStr
_mySerialNumberStr:
	.word 6659, 12288, 12288, 12288, 12288, 12288, 12288, 12288
	.word 12288, 12288, 12288, 12288, 12544
_v7ed548:
	.word 31, 25, 31
_phase7ed5d8:
	.word 0

//_____________________________________________________________
//
	.sect data_x,mscbss_x	// 261 words
	.export _geometry
_geometry:
	.bss 3
	.export _usbDisk
_usbDisk:
	.bss 1
	.export _ScsiIdle
_ScsiIdle:
	.bss 1
_dataa7ed8a8:
	.bss 256

//_____________________________________________________________
//
	.sect data_x,mscconst_x	// 109 words
	.export _myDeviceDescriptor_MassStorage
_myDeviceDescriptor_MassStorage:
	.word 4609, 4097, 0, 64, 64281, 750, 0, 258
	.word 769
	.export _myConfigurationDescriptor_MassStorage
_myConfigurationDescriptor_MassStorage:
	.word 2306, 8192, 257, 128, 32777, 1024, 2, 2054
	.word 20480, 1797, 33282, 16384, 7, 1283, 576, 0
	.export _myLanguageStr
_myLanguageStr:
	.word 1027, 2308
	.export _myVendorNameStr
_myVendorNameStr:
	.word 2563, 22016, 27648, 29440, 26880
	.export _myModelNameStr
_myModelNameStr:
	.word 4611, 22016, 21248, 12544, 12288, 12288, 13568, 18176
	.word 12544
usbpublis_1:
	.word "USB publishing disk: %s.\n"

	.zero 1
size01f_2:
	.word "Size %0.1f MB.\n"

	.zero 1
scsistart_3:
	.word "SCSI START\n"

	.zero 1
ctrlcres_4:
	.word "Ctrl-C Reset\n"

	.zero 1

	.end
