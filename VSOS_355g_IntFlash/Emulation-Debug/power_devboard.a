
//_____________________________________________________________
//
	.sect code,DelayL	// 24 words
	.export _DelayL
_DelayL:
	ldx (I6)+2,NULL	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6)
	j F0B6
	ldc 0,I0	// 0 -> ET4
// jumped away
F0B3:	// (loop lvl 2)
// #pragma msg 92 on
// 	}
// {
// #pragma msg 92 off
// (*(__y volatile u_int16 *)(u_int16)(0));
	ldy (I0),I7/*V*/
F0B6:	// (loop lvl 2)
	ldx (I4)-3,NULL	// I4 += -3
	ldx (I4)+1,A0
	ldx (I4)-1,A1
	add A,ONES,B	// AT7 + (-1) -> ET2
	ldc 0,A2	// update guard bits (cmp)
	stx B0,(I4)+1 ; sub A,NULL,A
	stx B1,(I4)+2
	jzc F0B3	// unsigned compare
	nop
// jumped away
	ldx (I6)-1,I0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,WritePCL	// 67 words
	.export _WritePCL
_WritePCL:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	ldc 65280,B0	// 65280 -> 1 -> ET5
	stx C0,(I6) ; sty I0,(I6)+1
	ldc 64672,I0	// 64672 -> ET2
	stx I1,(I6)+1 ; sty I2,(I6)
	ldc _powerControlLatchState,I1	// ET4
	ldc 64560,I2	// 64560 -> ET0
	ldx (I4)-2,NULL ; ldy (I2),A1/*V*/	// I4 += -2
// modeSave
// ddrSave
	ldy (I0),A0/*V*/ ; ldx (I4)+2,B1	// ET2 ==> 'ddrSave'
// = value;
	stx B1,(I1)/*V*/ ; ldy (I2),C0/*V*/	// 'value' ==> ET4
// (*(__y volatile u_int16 *)(u_int16)(0xFC30)) &= ~(0x00FF);
	and C0,B0,B0	// ET6 and ET5 -> ET7
	sty B0,(I2)/*V*/	// ET7 ==> ET0
// (*(__y volatile u_int16 *)(u_int16)(0xFCA0)) |= 0x00FF;
	ldc 64710,I2	// 64710 -> ET10
	ldc 255,B0	// 255 -> 1 -> ET8
	ldy (I0),C0/*V*/	// ET2 ==> ET9
	or C0,B0,C0	// ET9 or ET8 -> ETa
	sty C0,(I0)+7/*V*/	// ETa ==> ET2
// (*(__y volatile u_int16 *)(u_int16)(0xFCA7)) = 0x00FF;
	ldc 32769,C0	// 32769 -> 1 -> ETf
	sty B0,(I0)/*V*/ ; and B0,B1,B0	// ET8 ==> ETb
// (*(__y volatile u_int16 *)(u_int16)(0xFCA6)) = 0x00FF & value;
	ldc 64678,I0	// 64678 -> ETd
	sty B0,(I0)/*V*/ ; and NULL,NULL,B1	// ETc ==> ETd
// 	DelayL(10);
	ldc 10,B0	// 10 -> 3 -> B0
	stx B0,(I6)+1	// 0 -> B1
	ldc 32769,B0	// 32769 -> 1 -> ETf
	call _DelayL
	stx B1,(I6)	// B1
// jumped away
	sty B0,(I2)/*V*/ ; ldx (I6)-1,NULL	// I6 += -2


// {{(*(__y volatile u_int16 *)(u_int16)(0xFCC6))=(1 << 15) | (1 << 0);
// (*(__y volatile u_int16 *)(u_int16)(0xFCA6))=(1 << 11);
	ldc 2048,B0	// 2048 -> 1 -> ET11
	sty B0,(I0)/*V*/	// ET11 ==> ETd
// ; if (!(0 &1))

// {(*(__y volatile u_int16 *)(u_int16)(0xFCC7)) = (1 << 15);
	ldc 32768,B0	// 32768 -> 1 -> ET13
	ldc 64711,I0	// 64711 -> ET14
	sty B0,(I0)/*V*/	// ET13 ==> ET14
// if (!(0 &2))

// {(*(__y volatile u_int16 *)(u_int16)(0xFCA7)) = (1 << 11);
	ldc 2048,B0	// 2048 -> 1 -> ET11
	ldc 64679,I0	// 64679 -> ETb
	sty B0,(I0)/*V*/ ; sub NULL,ONES,B0	// ET11 ==> ETb
// if (!(0 &4))

// {(*(__y volatile u_int16 *)(u_int16)(0xFCC7)) = (1 << 0);
	ldc 64711,I0	// 64711 -> ET14
	sty B0,(I0)-1/*V*/ ; and NULL,NULL,B1	// ET15 ==> ET14
	ldc 10,B0	// 10 -> 3 -> B0
// ;
// 	DelayL(10);
	stx B0,(I6)+1	// 0 -> B1
	call _DelayL
	stx B1,(I6)	// B1
// jumped away
	ldx (I6)-1,NULL ; sty C0,(I0)/*V*/	// I6 += 1

// {(*(__y volatile u_int16 *)(u_int16)(0xFCC6))=(1 << 15) | (1 << 0);
// (*(__y volatile u_int16 *)(u_int16)(0xFCA6))=(1 << 11);
	ldc 2048,C0	// 2048 -> 1 -> ET11
	ldc 64678,I0	// 64678 -> ETd
	sty C0,(I0)+1/*V*/ ; stx B0,(I6)+1	// ET11 ==> ETd
// ;
// 	DelayL(10);
	ldc 255,B0	// 255 -> 1 -> ET8
	call _DelayL
	stx B1,(I6)	// B1
// jumped away
	sty B0,(I0)/*V*/ ; ldx (I6)-2,NULL	// I6 += -2
// (*(__y volatile u_int16 *)(u_int16)(0xFCA7)) = 0x00FF;
// (*(__y volatile u_int16 *)(u_int16)(0xFC30)) = modeSave;
	ldc 64560,I0	// 64560 -> ET0
	sty A1,(I0)/*V*/	// 'modeSave' ==> ET0
// (*(__y volatile u_int16 *)(u_int16)(0xFCA0)) = ddrSave;
	ldc 64672,I0	// 64672 -> ET2
	sty A0,(I0)/*V*/	// 'ddrSave' ==> ET2
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,DefaultSetPower	// 27 words
	.export _DefaultSetPower
_DefaultSetPower:
	ldx (I6)+1,NULL ; sub C1,NULL,C1	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx I0,(I6)
// 	if (onoff)
	jzs F2B4	// unsigned compare
	ldc _powerControlLatchState,I0
// jumped away
// 	}
// {
// 		powerControlLatchState |= mask;
	ldx (I0),A0/*V*/	// ET0 ==> 'powerControlLatchState'
	or A0,C0,A0	// 'powerControlLatchState' or 'mask' -> ET1
F2B5:
	stx A0,(I0)/*V*/ ; ldy (I6)+1,NULL	// ET1 ==> ET0
	ldc _powerControlLatchState,I0	// ET0
	ldx (I0),A0/*V*/	// I6 += 1
// 	WritePCL(powerControlLatchState);
	call _WritePCL
	stx A0,(I6)	// 'powerControlLatchState'
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,I0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
// 	}
// else {
// 		powerControlLatchState &= ~mask;
	ldc _powerControlLatchState,I0	// ET0
F2B4:
	xor C0,ONES,A1 ; ldx (I0),A0/*V*/	// 'mask' xor (-1) -> ET2
	j F2B5
	and A0,A1,A0	// 'powerControlLatchState' and ET2 -> ET3
// jumped away

//_____________________________________________________________
//
	.sect code,ResetSdCard	// 48 words
	.export _ResetSdCard
_ResetSdCard:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx C0,(I6)+1 ; sty C1,(I6)
	and NULL,NULL,C1	// 0 -> C1
// 	GpioSetPin(0x26, 0);
	call _GpioSetPin
	ldc 38,C0	// 38 -> C0
// jumped away
// 	GpioSetPin(0x2a, 0);
	ldc 42,C0	// 42 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
// 	GpioSetPin(0x25, 0);
	ldc 37,C0	// 37 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
// 	GpioSetPin(0x29, 0);
	ldc 41,C0	// 41 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
// 	GpioSetPin(0x27, 0);
	ldc 39,C0	// 39 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away
// 	GpioSetPin(0x28, 0);
	ldc 40,C0	// 40 -> C0
	call _GpioSetPin
	ldx (I6)+1,NULL ; and NULL,NULL,C1	// 0 -> C1
// jumped away

// {SetPower(((1 << 0)),0);
	sub NULL,ONES,C0	// 1 -> C0
	call _SetPower
	and NULL,NULL,C1	// 0 -> C1
// jumped away
	ldc 34464,A0	// 34464 -> 3 -> A0
	ldx (I6)+1,NULL ; sub NULL,ONES,A1	// I6 += 1
// ;
// 	DelayL(100000);
	stx A0,(I6)+1	// 1 -> A1
	call _DelayL
	stx A1,(I6)	// A1
// jumped away
	sub NULL,ONES,C0 ; ldx (I6)-2,NULL	// I6 += -2

// {SetPower(((1 << 0)),1);
	call _SetPower
	sub NULL,ONES,C1	// 1 -> C1
// jumped away
	ldc 10000,A0	// 10000 -> 3 -> A0
	ldx (I6)+1,NULL ; and NULL,NULL,A1	// I6 += 1
// ;
// 	DelayL(10000);
	stx A0,(I6)+1	// 0 -> A1
	call _DelayL
	stx A1,(I6)	// A1
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,SetPWMLevel	// 13 words
	.export _SetPWMLevel
_SetPWMLevel:
	ldx (I6)+2,NULL	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty I0,(I6)
	ldc 255,A0	// 255 -> 1 -> ET0
	ldc 65236,I0	// 65236 -> ET1
	ldx (I4)-2,NULL ; sty A0,(I0)+1/*V*/	// I4 += -2
// (*(__y volatile u_int16 *)(u_int16)(0xFED4)) = 255;
// (*(__y volatile u_int16 *)(u_int16)(0xFED5)) = level;
	ldx (I4)+2,A0	// unspill 'level' from #0
	sty A0,(I0)/*V*/	// 'level' ==> ET3
	ldy (I6),I0 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,InitBoard	// 42 words
	.export _InitBoard
_InitBoard:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc 32766,A1	// 32766 -> 1 -> ET0
	stx I0,(I6)+1
	ldc 64561,I0	// 64561 -> ET1
// (*(__y volatile u_int16 *)(u_int16)(0xFC31)) &= ~((1 << 0)|(1 << 15));
	ldy (I0),A0/*V*/	// ET1 ==> ET2
	and A0,A1,A0	// ET2 and ET0 -> ET3
	ldc 32769,A1	// 32769 -> 1 -> ET4
	sty A0,(I0)/*V*/	// ET3 ==> ET1
// (*(__y volatile u_int16 *)(u_int16)(0xFCC0)) |= ((1 << 0)|(1 << 15));
	ldc 64704,I0	// 64704 -> ET5
	ldy (I0),A0/*V*/	// ET5 ==> ET6
	or A0,A1,A0	// ET6 or ET4 -> ET7
	ldc 63487,A1	// 63487 -> 1 -> ET8
	sty A0,(I0)/*V*/	// ET7 ==> ET5
// (*(__y volatile u_int16 *)(u_int16)(0xFC30)) &= ~(1 << 11);
	ldc 64560,I0	// 64560 -> ET9
	ldy (I0),A0/*V*/	// ET9 ==> ETa
	and A0,A1,A0	// ETa and ET8 -> ETb
	sty A0,(I0)/*V*/	// ETb ==> ET9
// (*(__y volatile u_int16 *)(u_int16)(0xFCA0)) |= (1 << 11);
	ldc 2048,A0	// 2048 -> 1 -> ETc
	ldc 64672,I0	// 64672 -> ETd
	ldy (I0),A1/*V*/	// ETd ==> ETe
	or A1,A0,A0	// ETe or ETc -> ETf
	sty A0,(I0)/*V*/ ; and NULL,NULL,A0	// ETf ==> ETd
// 	powerControlLatchState = 0;
	ldc _powerControlLatchState,I0	// ET11
	stx A0,(I0)/*V*/	// ET10 ==> ET11
// 	WritePCL(powerControlLatchState);
	call _WritePCL
	stx A0,(I6)	// ET10
// jumped away
	ldc 128,A0	// 128 -> 0 -> ET12
// 	SetPWMLevel(128);
	call _SetPWMLevel
	stx A0,(I6)	// I6 += 1
// jumped away
// 	ResetSdCard();
	call _ResetSdCard
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
	ldx (I6)-1,I0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect data_x,powerdevboardinit_x	// 1 word
	.export _powerControlLatchState
_powerControlLatchState:
	.word 0

	.end
