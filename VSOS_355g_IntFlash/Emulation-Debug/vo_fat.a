
//_____________________________________________________________
//
	.sect code,FatImageWriteBytes	// 161 words
	.export _FatImageWriteBytes
_FatImageWriteBytes:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc -9,A1	// -9 -> AT7
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2 ; and C1,NULL,C1	// I0 -> 'f'
	mv I2,I0	// 'f' -> ET1
	ldy (I0)+6,NULL ; ldx (I4)-4,NULL	// I4 += -4
// di
	ldx (I0)+4,I1	// ET1 ==> 6 -> 'di'
// += (byteOffset / 512);
	ldx (I4)+1,A0 ; ldy (I1)+7,NULL	// unspill 'byteOffset' from #0
	ashl A0,A1,C0 ; mv I2,I3	// 'byteOffset' << AT7 -> ET8
	ldc 511,A1	// 511 -> 1 -> ETb
	ldx (I4)+1,B0 ; ldy (I3)+7,NULL
	ldx (I4)+2,B1 ; ldy (I1)+7,NULL	// unspill B1 from #0
	add B,C,C ; ldx (I1)+3,NULL	// 'sector' + ET9 -> 'sector'
// 	byteOffset &= 511;
	ldc 0,C2	// update guard bits (cmp)
	ldx (I0)+1,A0 ; and A0,A1,B1	// 'byteOffset' and ETb -> 'byteOffset'
// 	if ((sector != f->currentSector) && (((f)->flags &(1 << 7))))
	ldx (I0)-5,A1 ; ldy (I3)+3,NULL
	ldc 0,A2	// update guard bits (cmp)
	sub C,A,A	// ...
	ldc 128,A1	// 128 -> 1 -> ET11
	jzc F0B5	// unsigned compare
	ldx (I2),A0
// jumped away
F0B4:
	ldx (I4)-7,NULL	// I4 += -7
// 	if (bytes == 0)
	ldx (I4)+7,B0	// unspill 'bytes' from #-7
	sub B0,NULL,B0	// 'bytes' != (0) -> (0)
	nop
	jzc F0B8	// unsigned compare
	and NULL,NULL,A0	// 0 -> 0 -> ET1d
// jumped away
// 	}
// {
// 		return 0;
F0B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F0B8:
	mv I2,I0	// 'f' -> ETe
	ldc 0,C2	// update guard bits (cmp)
// 	if (sector != f->currentSector)
	ldx (I0)+7,NULL	// ETe += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub C,A,A	// 'sector' == ETf -> AT34
	nop
	jzs F0B10	// unsigned compare
	nop
// jumped away
// 	}
// {
// 		f->currentSector = sector;
	stx C0,(I0)+1 ; sub B1,NULL,B1
	stx C1,(I0)-1
// 		if (byteOffset || (bytes!=512))
	jzc F0B11	// unsigned compare
	ldc 512,A0	// 512 -> 1 -> ET6
// jumped away
	sub B0,A0,A0	// 'bytes' == ET6 -> AT38
	nop
	jzs F0B10	// unsigned compare
	nop
// jumped away
F0B11:
	mv I2,I0	// 'f' -> ET1f
// 		}
// {
// 			if (f->pos < f->fileSize || (byteOffset && !((f)->flags &(1 << 7))) || sector <= di->dataStart)
	ldx (I0)+3,NULL	// ET1f += 3
	ldx (I0)+1,D0
	ldx (I0)+7,D1
	ldc 0,D2	// update guard bits (cmp)
	ldx (I0)+1,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub D,A,A	// ET20 < ET23 -> AT37
	nop
	jcc F0B14	// unsigned compare
	nop
// jumped away
	sub B1,NULL,B1 ; ldx (I2),A0	// 'byteOffset' == (0) -> (0)
	ldc 128,A1	// 128 -> 1 -> ET11
	jzs F0B17	// unsigned compare
	and A0,A1,A0	// ET10 and ET11 -> ET12
// jumped away
	nop
	jzc F0B17	// compare against zero
	nop
// jumped away
F0B14:
	ldy (I2)+7,NULL ; ldx (I6)+1,NULL	// I6 += 1
// 			}
// {
// 				f->dev->BlockRead(f->dev, sector, 1, f->sectorBuffer);
	ldx (I2)+1,NULL	// ...
	ldx (I2)-2,A0	// 'f' ==> 8 -> ET17
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET17
	stx A0,(I6)+1	// ET18
	stx C0,(I6)+1	// C0
	stx C1,(I6)	// C1
	ldx (I2)-6,I1	// 'f' ==> 6 -> ET27
	mv I1,I0	// ET27 -> I0
	ldx (I1)+7,NULL	// ET27 += 7
	ldx (I1),A0	// ET27 ==> ET28
	mv A0,LR0
	jr
	ldc lo(F0B20),LR0	// (return address)
// jumped away
F0B20:
	ldx (I6)-4,NULL	// I6 += -4
F0B10:
// 	if ((byteOffset+bytes) > 512)
	ldc 512,A0	// 512 -> 1 -> ET6
	add B1,B0,A1 ; ldx (I6)+1,NULL	// 'byteOffset' + 'bytes' -> ET2c
	sub A0,A1,A0	// ET6 <= ET2c -> AT36
	ldc sectorove_1,A0	// ET2d
	jcs F0B23	// unsigned compare
	nop	// I6 += 1
// jumped away
// 	}
// {
// 		return SysError("Sector Overwrite");
	call _SysError
	stx A0,(I6)	// ET2d
// jumped away
	j F0B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F0B23:
	mv I2,I0 ; add B1,NULL,A0	// 'f' -> ET16
	ldy (I4)-5,NULL ; ldx (I0)+7,NULL
	ldx (I4)-1,I1 ; ldy (I0)+1,NULL	// I4 += -5
// 	MemCopyPackedBigEndian(f->sectorBuffer, byteOffset, data, sourceIndex, bytes);
	ldx (I4)+6,A1 ; ldy (I6)-1,NULL	// ...
	call _MemCopyPackedBigEndian
	ldx (I0),I0	// ET16 ==> 8 -> ET17
// jumped away
// 	f->flags |=(1 << 7);
	ldc 128,A1	// 128 -> 1 -> ET11
	ldx (I2),A0	// 'f' ==> ET10
	or A0,A1,A0	// ET10 or ET11 -> ET2f
// 	return 0;
	j F0B1
	stx A0,(I2) ; and NULL,NULL,A0	// ET2f ==> 'f'
// jumped away
F0B17:
	ldx (I1)+7,NULL	// 'di' += 8
	ldx (I1)+1,NULL	// ...
	ldx (I1)+1,A0
	ldx (I1)-1,A1
	sub A,C,A	// ET25 <= 'sector' -> AT39
	ldc 256,A0	// 256 -> A0
	jcs F0B14	// unsigned compare
	nop
// jumped away
	mv I2,I0 ; and NULL,NULL,A1	// 'f' -> ET16
// 			}
// else {
// 				memset(f->sectorBuffer,0,512/2);
	ldx (I0)+7,NULL	// ET16 += 8
	ldx (I0)+1,NULL	// ...
	ldx (I0),I0	// ET16 ==> 8 -> ET17
	call _memset
	ldc F0B10,LR0
// jumped away
	ldx (I2),A0	// 'f' ==> ET10
F0B5:
	and A0,A1,A1	// ET10 and ET11 -> ET12
	ldc 65407,A1	// 65407 -> 1 -> ET13
	jzs F0B4	// compare against zero
	nop
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	stx I0,(I4)	// AT3e spills to #1
// 	}
// {
// 		f->flags &= ~((1 << 7));
	and A0,A1,A0 ; mv I2,I0	// ET10 and ET13 -> ET14
	stx A0,(I2) ; ldy (I0)+7,NULL	// ET14 ==> 'f'
// 		f->dev->BlockWrite(f->dev, f->currentSector, 1, f->sectorBuffer);
	ldx (I0)+1,NULL	// ...
	ldx (I0),A0	// ET16 ==> 8 -> ET17
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET17
	stx A0,(I6)+1	// ET18
	ldx (I3)+1,A0
	ldx (I3)-1,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I4)-1,I0	// unspill AT3e from #1
	ldx (I0),I3	// ET1 ==> 6 -> ET19
	mv I3,I0	// ET19 -> I0
	ldx (I3)+7,NULL	// ET19 += 8
	ldx (I3)+1,NULL	// ...
	ldx (I3),A0	// ET19 ==> ET1a
	mv A0,LR0
	jr
	ldc lo(F0B6),LR0	// (return address)
// jumped away
F0B6:
	j F0B4
	ldx (I6)-4,NULL	// I6 += -4
// jumped away

//_____________________________________________________________
//
	.sect code,FatFlush	// 55 words
	.export _FatFlush
_FatFlush:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty I1,(I6)+1
	ldc 128,A1	// 128 -> 1 -> ET1
	stx I2,(I6)
// 	if (((f)->flags &(1 << 7)))
	ldx (I0),A0	// 'f' ==> ET0
	and A0,A1,A1 ; mv I0,I2	// ET0 and ET1 -> ET2
	ldc 65407,A1
	jzc F1B3	// compare against zero
	nop
// jumped away
F1B4:
	ldy (I2)+7,NULL ; ldx (I6)+1,NULL	// I6 += 1
// 	f->dev->BlockRead(f->dev, 0, 0, f->sectorBuffer);
	ldx (I2)+1,NULL	// ...
	ldx (I2)-2,A0	// 'f' ==> 8 -> ET7
	stx A0,(I6)+1 ; and NULL,NULL,A0	// ET7
	stx A0,(I6)+1 ; and A,NULL,A	// ET12
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I2),I2	// 'f' ==> 6 -> ET15
	mv I2,I0	// ET15 -> I0
	ldx (I2)+7,NULL	// ET15 += 7
	ldx (I2),A0	// ET15 ==> ET16
	mv A0,LR0
	jr
	ldc lo(F1B6),LR0	// (return address)
// jumped away
F1B6:
	ldx (I6)-4,NULL	// I6 += -4
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 65407,A1	// 65407 -> 1 -> ET3
F1B3:
	and A0,A1,A0 ; ldy (I6)+1,NULL	// I6 += 1
// 	}
// {
// 		f->flags &= ~((1 << 7));
	stx A0,(I2)+7	// ET4 ==> 'f'
// 		f->dev->BlockWrite(f->dev, f->currentSector, 1, f->sectorBuffer);
	ldx (I2)+1,NULL	// ...
	ldx (I2)+2,A0	// 'f' ==> 8 -> ET7
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET7
	stx A0,(I6)+1	// ET8
	ldx (I2)+1,A0
	ldx (I2)-5,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I2)-6,I1	// 'f' ==> 6 -> ETe
	mv I1,I0	// ETe -> I0
	ldx (I1)+7,NULL	// ETe += 8
	ldx (I1)+1,NULL	// ...
	ldx (I1),A0	// ETe ==> ET10
	mv A0,LR0
	jr
	ldc lo(F1B5),LR0	// (return address)
// jumped away
F1B5:
	j F1B4
	ldx (I6)-4,NULL	// I6 += -4
// jumped away

//_____________________________________________________________
//
	.sect code,FatImageSectorRead	// 79 words
	.export _FatImageSectorRead
_FatImageSectorRead:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; ldy (I4)-3,NULL
	mv I0,I2	// I0 -> 'f'
	mv I2,I0	// 'f' -> ET1
// 	if ((sector != f->currentSector) && (((f)->flags &(1 << 7))))
	ldy (I0)+7,NULL ; ldx (I4)+1,B0	// ET1 += 10
	ldy (I0)+3,NULL ; ldx (I4)+2,B1	// ...
	ldc 0,B2	// update guard bits (cmp)
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub B,A,A	// 'sector' == ET2 -> AT17
	ldc 128,A1	// 128 -> 1 -> ET4
	jzs F2B4	// unsigned compare
	ldx (I2),A0	// 'f' ==> ET3
// jumped away
	and A0,A1,A1	// ET3 and ET4 -> ET5
	ldc 65407,A1	// 65407 -> 1 -> ET6
	jzc F2B3	// compare against zero
	nop
// jumped away
F2B4:
	mv I2,I0	// 'f' -> ET1
	ldc 0,B2	// update guard bits (cmp)
// 	if (sector != f->currentSector)
	ldx (I0)+7,NULL	// ET1 += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub B,A,A	// 'sector' == ET2 -> AT18
	nop
	jzs F2B8	// unsigned compare
	nop
// jumped away
	stx B0,(I0)+1 ; ldy (I2)+7,NULL	// I6 += 1
// 	}
// {
// 		f->currentSector = sector;
	stx B1,(I0)-1 ; ldy (I2)+1,NULL
// 		return f->dev->BlockRead(f->dev, sector, 1, f->sectorBuffer);
	ldx (I2)-2,A0 ; ldy (I6)+1,NULL	// 'f' ==> 8 -> ETa
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ETa
	stx A0,(I6)+1	// ETb
	stx B0,(I6)+1	// B0
	stx B1,(I6)	// B1
	ldx (I2),I2	// 'f' ==> 6 -> ETe
	mv I2,I0	// ETe -> I0
	ldx (I2)+7,NULL	// ETe += 7
	ldx (I2),A0	// ETe ==> ET14
	mv A0,LR0
	jr
	ldc lo(F2B9),LR0	// (return address)
// jumped away
F2B9:
	ldx (I6)-4,NULL	// I6 += -4
F2B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F2B8:
// 	return 0;
	j F2B1
	and NULL,NULL,A0	// 0 -> 0 -> ET16
// jumped away
F2B3:
	and A0,A1,A0 ; ldy (I6)+1,NULL	// I6 += 1
// 	}
// {
// 		f->flags &= ~((1 << 7));
	stx A0,(I2)+7	// ET7 ==> 'f'
// 		f->dev->BlockWrite(f->dev, f->currentSector, 1, f->sectorBuffer);
	ldx (I2)+1,NULL	// ...
	ldx (I2)-2,A0	// 'f' ==> 8 -> ETa
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ETa
	stx A0,(I6)+1	// ETb
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I2)-6,I1	// 'f' ==> 6 -> ETf
	mv I1,I0	// ETf -> I0
	ldx (I1)+7,NULL	// ETf += 8
	ldx (I1)+1,NULL	// ...
	ldx (I1),A0	// ETf ==> ET10
	mv A0,LR0
	jr
	ldc lo(F2B6),LR0	// (return address)
// jumped away
F2B6:
	j F2B4
	ldx (I6)-4,NULL	// I6 += -4
// jumped away

//_____________________________________________________________
//
	.sect code,MegaFatGetByte	// 20 words
	.export _MegaFatGetByte
_MegaFatGetByte:
	mv I2,A0	// I2 -> 'buf'
	ldx (I6)+1,NULL	// I6 += 1
	stx A1,(I6) ; sty B0,(I6)+1
	stx I0,(I6) ; lsr C0,A1

	add A0,A1,A1	// 'buf' + ET2 -> ET3
// (n & 1)
	mv A1,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET4
	and C0,A0,A0	// 'n' and ET4 -> ET5
	sub A0,NULL,A0	// ET5 != (0) -> (0)
	ldc -8,B0	// -8 -> 0 -> ET8
	jzc F3B3	// unsigned compare
	nop
// jumped away
// 	}
// else {
// 		n = *p >> 8;
	ldx (I0),A0 ; and A1,NULL,A1	// 'p' ==> ET6
	ashl A,B0,A	// ATd <- ET8 -> ATe
F3B5:
// 	return n & 0xff;
	ldc 255,A1	// 255 -> 1 -> ETa
	and A0,A1,A0 ; ldx (I6)-1,I0	// 'n' and ETa -> ETb
	ldy (I6),B0 ; ldx (I6)-1,A1
	jr
	nop
// jumped away
F3B3:
// 	}
// {
// 		n = *p;
	j F3B5
	ldx (I0),A0	// 'p' ==> 'n'
// jumped away

//_____________________________________________________________
//
	.sect code,MegaFatGetWord	// 17 words
	.export _MegaFatGetWord
_MegaFatGetWord:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx A1,(I6) ; sty B0,(I6)+1
	stx I0,(I6) ; add C0,NULL,B0
	mv I2,I0	// C0 -> 'n'
// 	return MegaFatGetByte(buf, n) | (MegaFatGetByte(buf, n+1)<<8);
	call _MegaFatGetByte
	mv I0,I2 ; add C0,NULL,C0	// 'buf' -> I2
// jumped away
	add A0,NULL,A1 ; mv I0,I2	// A0 -> ET0
	call _MegaFatGetByte
	sub B0,ONES,C0	// 'n' - (-1) -> ET2
// jumped away
	add A0,NULL,B0 ; ldx (I6)-1,I0	// A0 -> ET3
	ldc 8,A0	// 8 -> 0 -> ET4
	ashl B0,A0,A0 ; ldy (I6),B0	// ET3 << ET4 -> ET5
	or A1,A0,A0 ; ldx (I6)-1,A1	// ET0 or ET5 -> ET6
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,MegaFatGetLong	// 19 words
	.export _MegaFatGetLong
_MegaFatGetLong:
	ldx (I6)+1,NULL ; add C0,NULL,A1	// I6 += 1
	stx LR0,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	ldc 0,B1
	stx I0,(I6)
	mv I2,I0	// C0 -> 'n'
// 	return MegaFatGetWord(buf, n) | ((u_int32)MegaFatGetWord(buf, n+2)<<16);
	call _MegaFatGetWord
	mv I0,I2 ; add C0,NULL,C0	// 'buf' -> I2
// jumped away
	add A0,NULL,B0 ; mv I0,I2	// ET0 msw ET1
	ldc 2,A0	// 2 -> 1 -> ET2
	call _MegaFatGetWord
	add A1,A0,C0	// 'n' + ET2 -> ET3
// jumped away
	add A0,NULL,A1 ; ldx (I6)-1,I0	// ET5 <<< ET7
	ldc 0,A0
	or B,A,A ; ldy (I6),B1	// ET1 or ET7 -> ET8
	ldx (I6)-1,B0
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,FatCreate	// 306 words
	.export _FatCreate
_FatCreate:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2 ; and B,NULL,B	// I0 -> 'dev'
	ldc _lfnStartCluster,I0	// ET4
	mv I2,I1 ; and A,NULL,A	// 0 -> 3 -> ET3
	ldy (I1)+7,NULL ; ldx (I4)+5,NULL	// I4 += 5
// di
// bpbSector
// = 0;
	stx A0,(I0)+1/*V*/ ; ldy (I1)+7,NULL
	stx A1,(I0)-1/*V*/ ; ldy (I1)+3,NULL
// 	if (!(((dev)->flags & ((1 << 0) |(1 << 1) |(1 << 3) |(1 << 4) |(1 << 5) |(1 << 2))) == ((1 << 0) |(1 << 1) |(1 << 4) |(1 << 5))))
	ldc 63,A1	// 63 -> 1 -> ET6
	ldx (I2),A0	// 'dev' ==> ET5
	and A0,A1,A1 ; stx B0,(I4)	// ET5 and ET6 -> ET7
	ldc 51,A0	// 51 -> 1 -> ET8
	sty B1,(I4)-5 ; sub A1,A0,A0	// B0 spills to #0
	ldc -10,A0	// -10 -> 0 -> ET9
	jzs F6B4	// unsigned compare
	nop
// jumped away
// 	}
// {
// 		return -10;
F6B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F6B4:
	ldc 2,A0	// 2 -> 3 -> A0
	mv I1,I0 ; and NULL,NULL,A1	// 'di' -> ETc
	ldx (I0)+7,NULL ; ldy (I6)+1,NULL	// I4 += -3
// 	di->allocationStartCluster = 2;
	ldx (I0)+5,NULL ; ldy (I4)-3,NULL	// ...
	stx A0,(I0)+1 ; sub NULL,ONES,A0	// 0 -> A1
	stx A1,(I0)-1
	mv I2,I0	// 1 -> 1 -> ETd
// 	dev->BlockRead(dev, 0, 1, fatBuffer);
	ldx (I4)+3,C1 ; ldy (I2)+7,NULL	// unspill 'fatBuffer' from #-3
	stx C1,(I6)+1	// 'fatBuffer'
	stx A0,(I6)+1 ; and A,NULL,A	// ETd
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I2)-7,A0	// 'dev' ==> 7 -> ET10
	mv A0,LR0
	jr
	ldc lo(F6B5),LR0	// (return address)
// jumped away
F6B5:
	ldc 21930,A1	// 21930 -> 1 -> ET15
	ldc 255,A0	// 255 -> 0 -> ET12
	add C1,A0,A0 ; ldy (I6)-4,NULL	// I6 += -4
	mv A0,I0	// ATb9 -> ET13
// 	if (fatBuffer[255] != 0x55aa)
	ldx (I0),A0	// ET13 ==> 255 -> ET14
	sub A0,A1,A0	// ET14 == ET15 -> AT96
	ldc 27,A0	// 27 -> 0 -> ET17
	jzs F6B7	// unsigned compare
	nop
// jumped away
// 	}
// {
// 		return -11;
	j F6B1
	ldc -11,A0	// -11 -> 0 -> ET16
// jumped away
F6B7:
// 	if (((fatBuffer[27] != ('F'<<8)+('A'<<0)) && (fatBuffer[41] != ('F'<<8)+('A'<<0))))
	add C1,A0,A0	// 'fatBuffer' + ET17 -> ATba
	mv A0,I0	// ATba -> ET18
	ldc 17985,A0	// 17985 -> 1 -> ET1a
	ldx (I0),A1	// ET18 ==> 27 -> ET19
	sub A1,A0,C0	// ET19 == ET1a -> AT98
	ldc 41,A1	// 41 -> 0 -> ET1b
	jzs F6B9	// unsigned compare
	add C1,A1,A1	// 'fatBuffer' + ET1b -> ATbe
// jumped away
	mv A1,I0	// ATbe -> ET1c
	ldx (I0),A1	// ET1c ==> 41 -> ET1d
	sub A1,A0,A0	// ET1d == ET1a -> AT9e
	ldc 48,A0	// 48 -> 0 -> ET20
	jzs F6B9	// unsigned compare
	nop
// jumped away
	ldc -8,B0	// -8 -> 0 -> ET2b
	ldx (I4)-2,NULL ; ldy (I6)+1,NULL	// I4 += -2
// 	}
// partitionStartPtr
	ldx (I4)+3,I0 ; and D1,NULL,D1	// unspill 'name' from #0
	ldx (I0),A1	// 'name' ==> ET1f
	sub A1,A0,A1 ; stx C0,(I4)	// ET1f - ET20 -> ET21
	ldc 4,A0	// 4 -> 0 -> ET23
	ashl A1,A0,A1 ; sty C1,(I4)+4	// ET21 << ET23 -> ET24
	ldc 227,A0	// 227 -> 0 -> ET1e
	add A0,A1,A1	// ET1e + ET24 -> 'partitionStartPtr'
// = ((u_int32)(((u_int16)(fatBuffer[partitionStartPtr+1])>>8)|((fatBuffer[partitionStartPtr+1])<<8))<<16) |(((u_int16)(fatBuffer[partitionStartPtr])>>8)|((fatBuffer[partitionStartPtr])<<8));
	sub A1,ONES,A0	// 'partitionStartPtr' - (-1) -> ET27
	add C1,A0,A0	// 'fatBuffer' + ET27 -> ATbc
	mv A0,I0 ; add C1,A1,A1	// ATbc -> ET28
	ldc 8,A0	// 8 -> 0 -> ET2a
	ldx (I0),B1 ; and C1,NULL,C1	// ET28 ==> ET29
	add B1,NULL,D0 ; mv A1,I0	// ET29 msw AT99
	ashl B1,A0,B1 ; ldx (I0),A1	// ET29 << ET2a -> ET2d
	mv A1,C0 ; ashl A1,A0,A0	// ET32 msw AT9b
	ashl D,B0,D ; mv I2,I0	// AT99 <- ET2b -> AT9a
	or D0,B1,D0 ; ldy (I2)+7,NULL	// ET2c or ET2d -> ET2e
	mv D0,D1 ; ashl C,B0,B	// ET2f <<< ET30
	ldc 0,D0
	or B0,A0,A0 ; mv D0,A1	// ET33 or ET34 -> ET35
	or D,A,D	// ET30 or ET36 -> 'bpbSector'
	stx D0,(I4) ; sty D1,(I4)-4	// D0 spills to #0
// 		dev->BlockRead(dev, bpbSector, 1 , fatBuffer);
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
	stx C1,(I6)+1 ; sub NULL,ONES,A0	// 'fatBuffer'
	stx A0,(I6)+1	// ETd
	stx D0,(I6)+1	// D0
	stx D1,(I6)	// D1
	ldx (I2),A0	// 'dev' ==> 7 -> ET10
	mv A0,LR0
	jr
	ldc lo(F6B11),LR0	// (return address)
// jumped away
F6B11:
	ldx (I6)-4,NULL	// I6 += -4
F6B9:
// 	if (((fatBuffer[27] != ('F'<<8)+('A'<<0)) && (fatBuffer[41] != ('F'<<8)+('A'<<0))))
	ldc 27,A0	// 27 -> 0 -> ET17
	add C1,A0,A0	// 'fatBuffer' + ET17 -> ATbd
	mv A0,I0	// ATbd -> ET18
	ldc 17985,A0	// 17985 -> 1 -> ET1a
	ldx (I0),A1	// ET18 ==> 27 -> ET19
	sub A1,A0,C0	// ET19 == ET1a -> AT9d
	ldc 41,A1	// 41 -> 0 -> ET1b
	jzs F6B13	// unsigned compare
	nop
// jumped away
	add C1,A1,A1	// 'fatBuffer' + ET1b -> ATbf
	mv A1,I0	// ATbf -> ET1c
	ldx (I0),A1	// ET1c ==> 41 -> ET1d
	sub A1,A0,A0	// ET1d == ET1a -> ATa0
	nop
	jzs F6B13	// unsigned compare
	nop
// jumped away
// 	}
// {
// 		return -12;
	j F6B1
	ldc -12,A0	// -12 -> 0 -> ET39
// jumped away
F6B13:
	mv C1,I2	// 'fatBuffer' -> I2
// 	}
// blocksPerSector
	call _MegaFatGetWord
	ldc 11,C0	// 11 -> C0
// jumped away
	ldc 22,C0	// 22 -> C0
	mv C1,I2 ; add A0,NULL,A1	// A0 -> ET3b
	ldc -9,A0	// -9 -> AT3d
// fatSize
	call _MegaFatGetWord
	ashl A1,A0,B1	// ET3b << AT3d -> 'blocksPerSector'
// jumped away
	ldc 19,C0	// 19 -> C0
	mv C1,I2 ; muluu A0,B1	// ET40 * 'blocksPerSector' -> P
	add NULL,P,A ; ldx (I4)+4,NULL	// P -> ATa2
	and A1,NULL,A1 ; stx A0,(I4)
// totalSectors
	call _MegaFatGetWord
	sty A1,(I4)-4	// A1 spills to #0
// jumped away
	ldc 11,C0	// 11 -> C0
	mv C1,I2 ; muluu A0,B1	// ET44 * 'blocksPerSector' -> P
	add NULL,P,A ; ldx (I4)+3,NULL	// P -> ATa4
	and A1,NULL,A1 ; stx A0,(I4)
// bytesPerSector
	call _MegaFatGetWord
	sty A1,(I4)-3	// A1 spills to #0
// jumped away
	ldc 17,C0	// 17 -> C0
// ->rootEntCnt =(MegaFatGetWord(fatBuffer, 17 ));
	call _MegaFatGetWord
	mv C1,I2 ; add A0,NULL,D0	// A0 -> 'bytesPerSector'
// jumped away
	mv C1,I2	// 'fatBuffer' -> I2
	ldc 16,C0	// 16 -> C0
// 		di->numFats =(MegaFatGetByte(fatBuffer, 16));
	call _MegaFatGetByte
	stx A0,(I1)	// ET48 ==> 'di'
// jumped away
	mv I1,I0	// 'di' -> ET4b
	ldc 5,B0	// 5 -> 0 -> ET4e
	ldx (I0)+1,NULL ; ldy (I4)+2,NULL	// ET4b += 1
	stx A0,(I0)	// ET4a ==> ET4b
// 		rootDirSectors = ((di->rootEntCnt * 32) + (bytesPerSector - 1 )) / bytesPerSector;
	ldx (I1),C0	// 'di' ==> ET4c
	ashl C0,B0,C0	// ET4c << ET4e -> ET4f
	add D0,ONES,B0	// 'bytesPerSector' + (-1) -> ET50
	add C0,B0,B0	// ET4f + ET50 -> ET51
	call divide16unsigned
	add D0,NULL,A0	// 'bytesPerSector' -> A0
// jumped away
	and A1,NULL,A1 ; stx A0,(I4)
	sty A1,(I4)+2	// A1 spills to #0
// 		if (fatSize == 0)
	ldx (I4),A0 ; ldy (I4)-4,A1	// unspill A0 from #0
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; mv C1,I2	// 'fatSize' != (0) -> (0)
	nop	// 'fatBuffer' -> I2
	jzc F6B23	// unsigned compare
	nop
// jumped away
// 		}
// {
// 			fatSize =(MegaFatGetWord(fatBuffer, 36))*blocksPerSector;
	call _MegaFatGetWord
	ldc 36,C0	// 36 -> C0
// jumped away
	muluu A0,B1 ; ldx (I4)+4,NULL	// I4 += 4
	add NULL,P,A	// P -> ATad
	and A1,NULL,A1 ; stx A0,(I4)
	sty A1,(I4)-4	// A1 spills to #0
F6B23:
	ldx (I4)+3,NULL	// I4 += 3
// 		if (totalSectors == 0)
	ldx (I4),A0 ; ldy (I4)-3,A1	// unspill A0 from #0
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; mv C1,I2	// 'totalSectors' != (0) -> (0)
	nop
	jzc F6B26	// unsigned compare
	nop
// jumped away
	mv C1,I2	// 'fatBuffer' -> I2
// 		}
// {
// 			totalSectors =(MegaFatGetLong(fatBuffer, 32))*blocksPerSector;
	call _MegaFatGetLong
	ldc 32,C0	// 32 -> C0
// jumped away
	muluu B1,A1 ; mv B0,I7	// ET58 * 'blocksPerSector' -> 'totalSectors'
	add NULL,P,A ; mv A0,B0	// (32x16)
	muluu B1,B0 ; mv C1,I2
	add A0,P,A ; ldx (I4)+3,NULL
	stx A0,(I4) ; sty A1,(I4)-3	// A0 spills to #0
F6B26:
// 		di->fatSectorsPerCluster = (u_int16)((MegaFatGetByte(fatBuffer, 13)) * (bytesPerSector / 512));
	call _MegaFatGetByte
	ldc 13,C0	// 13 -> C0
// jumped away
	ldc 14,C0	// 14 -> C0
	mv I1,I0 ; add A0,NULL,A1	// A0 -> ET5c
	ldc -9,A0	// -9 -> AT5d
	ashl D0,A0,A0 ; mv C1,I2	// 'bytesPerSector' << AT5d -> ET5e
	muluu A1,A0 ; ldx (I0)+4,NULL	// ET5c * ET5e -> P
	add NULL,P,A	// P -> ATaf
// 		}
// dataSectors
	call _MegaFatGetWord
	stx A0,(I0)	// ET5f ==> ET61
// jumped away
	ldx (I4)+1,NULL ; ldy (I1)+1,NULL	// I4 += 1
	stx C0,(I4) ; sty C1,(I4)+3	// C0 spills to #0
	ldx (I1)-1,A0 ; add A0,NULL,C0	// ET63 msw ET64
	mv C0,I7 ; and C1,NULL,C1
	ldx (I4),B0 ; ldy (I4)-2,B1	// unspill B0 from #0
	muluu A0,B1 ; mv A0,C0	// ET65 * 'fatSize' -> ET67
	add NULL,P,A	// (16x32)
	muluu C0,B0 ; mv I7,C0
	add A0,P,A
	add C,A,B ; ldx (I4),A0	// ET64 + ET67 -> ET68
	ldy (I4)+1,A1	// unspill A1 from #0
	add B,A,B ; ldx (I4),A0	// ET68 + 'rootDirSectors' -> ET69
	ldy (I4)-2,A1	// unspill A1 from #0
	sub A,B,B ; ldx (I0),A0	// 'totalSectors' - ET69 -> 'dataSectors'
// ->totalClusters = dataSectors / di->fatSectorsPerCluster + 2;
	and A1,NULL,A1 ; ldx (I4),C0
	call divide32unsigned
	ldy (I4)-1,C1	// unspill C1 from #0
// jumped away
	ldx (I4)+1,NULL ; ldy (I1)+2,NULL	// I4 += 1
	stx C0,(I4) ; add A,NULL,B	// A -> ET6d
	ldc 2,A0	// 2 -> 3 -> A0
	sty C1,(I4)-1 ; and NULL,NULL,A1	// 0 -> A1
	add B,A,A	// ET6d + ETa -> ET6e
	ldc 4087,B0	// 4087 -> 3 -> B0
	stx A0,(I1)+1 ; and NULL,NULL,B1
	ldc 0,B2	// update guard bits (cmp)
	stx A1,(I1)-1
// 		}
// realFatBits
// (di->totalClusters < 4085+2)
	ldx (I1)+1,C0
	ldx (I1)-3,C1
	ldc 0,C2	// update guard bits (cmp)
	sub C,B,B	// ET71 < ET72 -> ATb4
	ldc 32,A0	// 32 -> 'realFatBits'
	jcc F6B55	// unsigned compare
	ldc 65527,B0	// 65527 -> 3 -> B0
// jumped away
	ldx (I4)+1,NULL ; ldy (I1)+2,NULL	// I4 += 1
	ldy (I4),C1 ; stx A0,(I4) ; and NULL,NULL,B1	// unspill C1 from #0
	sty A1,(I4) ; ldx (I1)+1,A0	// A1 spills to #0
// else if (di->totalClusters < 65525+2)
	ldx (I1)-3,A1
	sub A,B,B	// ET71 >= ET73 -> ATb5
	ldc 16,A0	// 16 -> 'realFatBits'
	jcs F6B51	// unsigned compare
	nop	// I4 += 1
// jumped away
	ldx (I4)-1,NULL
// 			}
// {
// 				realFatBits = 16;
F6B33:
// 			if (di->rootEntCnt == 0)
	ldx (I1),A1	// 'di' ==> ET4c
	sub A1,NULL,A1 ; mv C1,I2	// ET4c != (0) -> (0)
	mv I1,I0
	jzc F6B37	// unsigned compare
	ldc 14,C0
// jumped away
	mv C1,I2	// 'fatBuffer' -> I2
	mv I1,I0	// 'di' -> ET76
	ldc 32,A0	// 32 -> 'realFatBits'
// 			}
// {
// 				realFatBits = 32;
// 			di->fatBits = realFatBits;
F6B37:
	ldx (I0)+5,NULL	// ET76 += 5
// 		di->fatStart = bpbSector + (u_int32)(MegaFatGetWord(fatBuffer, 14)) * (bytesPerSector / 512);
	call _MegaFatGetWord
	stx A0,(I0)	// 'realFatBits' ==> ET76
// jumped away
	ldc 16,C0	// 16 -> C0
	mv I1,I3 ; add A0,NULL,A1	// A0 -> ET77
	ldc -9,A0	// -9 -> AT79
	ldx (I4)+5,NULL ; ldy (I3)+6,NULL	// I4 += 5
	ashl D0,A0,A0 ; mv C1,I2	// 'bytesPerSector' << AT79 -> ET7a
	muluu A1,A0 ; ldx (I4),A0	// ET77 * ET7a -> ET7c
	ldy (I4)-1,A1	// unspill A1 from #0
	add A,P,A	// 'bpbSector' + ET7c -> ET7d
	stx A0,(I3)+1
// 		di->rootStart = (fatSize *(MegaFatGetByte(fatBuffer, 16))) + di->fatStart;
	call _MegaFatGetByte
	stx A1,(I3)-1
// jumped away
	ldx (I4),B0 ; ldy (I4)-4,B1	// unspill B0 from #0
	muluu A0,B1 ; mv C0,I7	// 'fatSize' * ET80 -> ET82
	add NULL,P,A ; mv A0,C0	// (32x16)
	muluu C0,B0 ; ldx (I3)+1,B0
	add A0,P,A ; ldx (I3)-1,B1
	add A,B,A ; mv I1,I3	// ET82 + ET83 -> ET84
	ldx (I3)+7,NULL ; and B1,NULL,B1	// ET86 += 10
	ldx (I3)+3,NULL	// ...
	stx A0,(I3)+1
	stx A1,(I3)-1
// 		di->dataStart = (di->rootEntCnt / 16) + di->rootStart;
	ldc -4,A1	// -4 -> AT87
	ldx (I1),A0	// 'di' ==> ET4c
	ashl A0,A1,B0 ; ldx (I3)+1,A0	// ET4c << AT87 -> ET88
	ldx (I3)-3,A1
	add B,A,A	// ET89 + ET8a -> ET8b
	stx A0,(I3)+1
	stx A1,(I3)-5
// 		di->dataStart -= (u_int32)di->fatSectorsPerCluster*2;
	ldc 2,A1	// 2 lsw ET8e
	ldx (I3)+4,A0	// ET86 ==> 4 -> ET6b
	muluu A0,A1 ; ldx (I3)+1,A0	// ET6b * ET8e -> ET8f
	ldx (I3)-1,A1
	sub A,P,A	// ET90 - ET8f -> ET91
	stx A0,(I3)+1
	ldc 32,A0	// 32 -> 1 -> ET4d
	stx A1,(I3)+1
// 		if (di->fatBits == 32)
	ldx (I0),A1	// ET76 ==> 5 -> ET92
	sub A1,A0,C1	// ET92 != ET4d -> ATb7
	ldc 2,A0	// 2 -> 3 -> A0
	jzc F6B41	// unsigned compare
	nop
// jumped away
// 		}
// {
// 			di->rootStart = 2;
	and NULL,NULL,A1 ; stx A0,(I3)+1	// 0 -> A1
	stx A1,(I3)-1
F6B41:
// 	return 0;
	j F6B1
	and NULL,NULL,A0	// 0 -> 0 -> ET93
// jumped away
F6B51:
	j F6B33
	ldx (I4)-1,A0	// unspill A0 from #0
// jumped away
F6B55:
	ldc 12,A0	// 12 -> 'realFatBits'
	ldx (I4)+1,NULL	// I4 += 1
// 			}
// {
// 				realFatBits = 12;
	j F6B33
	ldy (I4)-1,C1	// unspill C1 from #0
// jumped away

//_____________________________________________________________
//
	.sect code,FatGetFragmentFromFAT	// 137 words
	.export _FatGetFragmentFromFAT
_FatGetFragmentFromFAT:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	ldx (I6)+5,NULL ; ldy (I4)+7,NULL	// ...
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	mv I0,I1 ; and A,NULL,A	// I0 -> 'f'
	stx I2,(I6) ; sty I3,(I6)+1
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6) ; ldy (I1)+6,NULL
// di
	ldx (I1)-6,I3 ; ldy (I4)+3,NULL	// 'f' ==> 6 -> 'di'
// fi
// .startByteOffset = 0;
	ldx (I3)+7,NULL	// 0 -> 3 -> ETa
	stx A0,(I4)+1 ; ldy (I3)+7,NULL
	stx A1,(I4)-3 ; ldy (I3)+3,NULL
// 	frag.sizeBytes = 0;
	stx A0,(I4)+1
	stx A1,(I4)-7
	ldx (I4)-6,NULL	// ...
// 	#pragma msg 36 off
// 	goto l55;
// 	while (1)
	ldx (I4)+1,C0	// unspill C0 from #0
	ldx (I4)+1,C1	// unspill C1 from #0
	ldx (I4)-4,I2	// unspill AT0 from #-2
	ldx (I4)+1,D0	// unspill D0 from #0
	j F7B23
	ldx (I4)+5,D1	// unspill D1 from #0
// jumped away
F7B13:	// (loop lvl 2)
	ldc 0,D2	// update guard bits (cmp)
	ldx (I4)+7,NULL	// I4 += 10
	ldx (I4)+3,NULL	// ...
// 		}
// {
// 			fatCluster = t;
// 			if (frag.startByteOffset <= filePos && filePos < frag.startByteOffset + frag.sizeBytes)
	ldx (I4)+1,B0
	ldx (I4)-7,B1
	ldc 0,B2	// update guard bits (cmp)
	sub D,B,C ; ldx (I4)-4,NULL	// ...
	nop
	jcc F7B23	// unsigned compare
	add A,NULL,C
// jumped away
	ldx (I4)+7,NULL	// I4 += 8
	ldx (I4)+1,NULL	// ...
	ldx (I4)+1,C0
	ldx (I4)-7,C1
	add B,C,B ; ldx (I4)-2,NULL	// ...
	ldc 0,B2	// update guard bits (cmp)
	sub D,B,B	// 'filePos' < ET2a -> AT38
	nop
	jcc F7B15	// unsigned compare
	nop
// jumped away
	add A,NULL,C	// AT39 -> AT3b
F7B23:	// (loop lvl 2)
	ldx (I4)+7,NULL	// I4 += 8
	ldx (I4)+1,NULL	// ...
// 			frag.startByteOffset += frag.sizeBytes;
	ldx (I4)+1,A0
	ldx (I4)+1,A1
	ldx (I4)+1,B0
	ldx (I4)-1,B1
	add B,A,A ; mv I3,I0	// ET27 + ET28 -> ET2a
	stx A0,(I4)+1 ; ldy (I0)+4,NULL
	stx A1,(I4)-3 ; and A,NULL,A
// 			frag.sizeBytes = 0;
	stx A0,(I4)+1
	stx A1,(I4)-3
// 			frag.startSector = fatCluster * di->fatSectorsPerCluster + di->dataStart;
	ldx (I0)+4,A0	// ET13 ==> 4 -> ET14
	muluu A0,C1	// AT3b * ET14 -> ET2d
	add NULL,P,B	// (32x16)
	muluu A0,C0 ; ldx (I0)+1,A0
	add B0,P,B ; ldx (I0)-1,A1
	add B,A,A	// ET2d + ET30 -> ET31
	stx A0,(I4)+1
	j F7B7
	stx A1,(I4)-7
// jumped away
F7B27:	// (loop lvl 3)
	ldc 0,A2	// update guard bits (cmp)
	ldx (I4)+1,NULL	// I4 += 1
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
// 		++fatCluster;
	sub C,ONES,C	// AT3b - (-1) -> AT3b
// 		if (t != fatCluster)
	ldc 0,C2	// update guard bits (cmp)
	sub A,C,B	// AT39 != AT3b -> AT34
	nop
	jzc F7B13	// unsigned compare
	nop
// jumped away
F7B7:	// (loop lvl 3)
	mv I1,I0	// 'f' -> I0
	ldc 9,B0	// 9 -> ET16
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// = VoFatReadClusterRecord(f, fatCluster);
	stx C0,(I6)+1	// C0
	call _VoFatReadClusterRecord
	stx C1,(I6)	// C1
// jumped away
	ldc 0,A2	// update guard bits (cmp)
	ldx (I4)+1,NULL ; ldy (I3)+4,NULL	// I4 += 1
	stx C0,(I4) ; sty C1,(I4)+7	// C0 spills to #0
// 		frag.sizeBytes += (di->fatSectorsPerCluster*512);
	ldx (I4)+1,C0 ; ldy (I6)-2,NULL	// 'di' += 4
	ldx (I3)-4,B1	// 'di' ==> 4 -> ET14
	ashl B1,B0,B0 ; ldx (I4)-1,C1	// ET14 << ET16 -> ET17
	ldc 0,B1
	add C,B,B	// ET19 + ET18 -> ET1a
	ldc 4095,C1	// 4095 -> C1
	ldc 0,C2	// update guard bits (cmp)
	ldc 65528,C0	// 65528 -> C0
	stx B0,(I4)+1 ; sub A,C,A
	stx B1,(I4)-7
	ldx (I4)-2,NULL	// ...
// 		if (t >= 0x0ffffff8UL)
	jcc F7B27	// unsigned compare
	add A,C,A	// restore value
// jumped away
// 		}
// {
// 			if (f->fileSize > f->pos+frag.sizeBytes)
	ldx (I1)+7,NULL ; ldy (I4)+6,NULL	// 'f' += 12
	ldx (I1)+5,NULL	// ...
	ldx (I1)+1,C0
	ldx (I1)-7,C1
	ldx (I1)-3,NULL	// 'f' += -9
	ldx (I1)+1,A0
	ldx (I1)+7,A1
	add A,B,B ; ldx (I1)+1,NULL	// ET21 + ET1a -> ET23
	sub B,C,C	// ET23 <= ET1e -> AT33
	ldc 4,LC
	jcs F7B12	// unsigned compare
	nop	// copy 6 words
// jumped away
	stx B0,(I1)+1
// 			}
// {
// 				f->fileSize = f->pos+frag.sizeBytes;
	stx B1,(I1)-1
F7B12:
// 			return frag;
	loop LC,MEMCOPY0-1
	ldx (I4)+1,A0
//loop resumes
	stx A0,(I2)+1
	ldx (I4)+1,A0
//	(0 nop's needed)
// loop end
	// memcopy
MEMCOPY0:
	stx A0,(I2)-5 ; ldy (I4)-7,NULL
	mv I2,A0	// AT0 returns via A0
	ldy (I4)-5,NULL ; ldx (I6)-1,LE	// ...
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F7B15:
	ldc 4,LC	// copy 6 words
	ldx (I4)+6,NULL	// I4 += 6
// 			}
// {
// 			   return frag;
	loop LC,MEMCOPY1-1
	ldx (I4)+1,A0
//loop resumes
	stx A0,(I2)+1
	ldx (I4)+1,A0
//	(0 nop's needed)
// loop end
	// memcopy
MEMCOPY1:
	j MEMCOPY0
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatClusterPos	// 77 words
	.export _VoFatClusterPos
_VoFatClusterPos:
	ldx (I6)+1,NULL ; ldy (I0)+6,NULL	// I6 += 1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A0,(I6) ; sty A1,(I6)+1
	stx B0,(I6) ; sty B1,(I6)+1
	stx I2,(I6) ; ldy (I4)-2,NULL
	ldx (I0),I0 ; add C,NULL,A	// C -> 'fatCluster'
// di
// (fatCluster >= di->totalClusters)
	ldx (I0)+7,NULL	// 'di' += 17
	ldx (I0)+7,NULL	// ...
	ldx (I0)+5,NULL	// ...
	ldx (I0)+1,B0
	ldx (I0)-3,B1
	sub C,B,B	// 'fatCluster' >= ET8 -> AT2d
	ldc 32,B1	// 32 -> 1 -> ETe
	jcs F8B3	// unsigned compare
	nop	// I4 += -2
// jumped away
	ldy (I0)+5,NULL ; ldx (I4)+2,NULL
// 	switch (di->fatBits)
	ldx (I0)-5,B0	// 'di' ==> 5 -> ETd
	sub B0,B1,B1	// ETd == ETe -> AT2e
	ldc 16,B1	// 16 -> 1 -> ET1b
	jzs F8B6	// unsigned compare
	sub B0,B1,B0	// ETd == ET1b -> AT2f
// jumped away
	ldc 255,B0
	jzs F8B8	// unsigned compare
	nop
// jumped away
	ldx (I4)-3,NULL ; ldy (I0)+6,NULL	// I4 += -3
// 		  }

	ldx (I4)+1,I2 ; add A,A,B	// 'fatCluster' + 'fatCluster' -> AT24
	add A,B,B	// 'fatCluster' + AT24 -> 't'
// offset = (u_int16)t & 0x3ff;
	ldc 0,B2	// clear guard bits
	ldc 1023,A0	// 1023 -> 1 -> ET27
	and B0,A0,A0	// ET26 and ET27 -> ET28
	stx A0,(I2)	// ET28 ==> 'offset'
// 		    *sector = (t >> 10) + di->fatStart;
	ldc -10,A0	// -10 -> 0 -> ET2a
	ashl B,A0,B ; ldx (I0)+1,A0	// 't' <- ET2a -> ET2b
	ldx (I0)-1,A1
	add B,A,A ; ldx (I4)+2,I0	// ET2b + ET19 -> ET2c
	stx A0,(I0)+1
	stx A1,(I0)-1
// 		  break;
F8B1:
	ldx (I6)-1,I2
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away
	ldc 255,B0	// 255 -> 1 -> ET1c
F8B8:
	ldc 0,A2	// clear guard bits
	ldx (I4)-3,NULL ; ldy (I0)+6,NULL	// I4 += -3
// 		  *offset = ((u_int16)fatCluster & 0xff) * 2;
	and A0,B0,B0 ; ldx (I4)+1,I2	// ETf and ET1c -> ET1d
	add B0,B0,B0	// ET1d + ET1d -> ET1e
	stx B0,(I2)	// ET1e ==> 'offset'
// 		  *sector = (fatCluster >> 8) + di->fatStart;
	ldc -8,B0	// -8 -> 0 -> ET20
	ashl A,B0,B ; ldx (I0)+1,A0	// 'fatCluster' <- ET20 -> ET21
	ldx (I0)-1,A1
	add B,A,A ; ldx (I4)+2,I0	// ET21 + ET19 -> ET22
	stx A0,(I0)+1
// 		  break;
	j F8B1
	stx A1,(I0)-1
// jumped away
F8B6:
	ldc 0,A2	// clear guard bits
	ldc 127,B0	// 127 -> 1 -> ET10
	ldx (I4)-3,NULL ; ldy (I0)+6,NULL	// I4 += -3
// 		  *offset = ((u_int16)fatCluster & 0x7F) * 4;
	and A0,B0,B0 ; ldx (I4)+1,I2	// ETf and ET10 -> ET11
	add B0,B0,B0	// ET11 + ET11 -> AT13
	add B0,B0,B0	// AT13 + AT13 -> ET14
	stx B0,(I2)	// ET14 ==> 'offset'
// 		  *sector = (fatCluster >> 7) + di->fatStart;
	ldc -7,B0	// -7 -> 0 -> ET16
	ashl A,B0,A ; ldx (I0)+1,B0	// 'fatCluster' <- ET16 -> ET17
	ldx (I0)-1,B1
	add A,B,A ; ldx (I4)+2,I0	// ET17 + ET19 -> ET1a
	stx A0,(I0)+1
// 		  break;
	j F8B1
	stx A1,(I0)-1
// jumped away
F8B3:
// 	}
// {
// 		*sector = 0;
	and A,NULL,A ; ldx (I4)-1,I0	// 0 -> 3 -> ET9
	stx A0,(I0)+1 ; and NULL,NULL,A0
	stx A1,(I0)-1
// 		*offset = 0;
	ldx (I4)+3,I0	// 0 -> 1 -> ETa
// 		return;
	j F8B1
	stx A0,(I0)	// ETa ==> 'offset'
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatReadClusterRecord	// 147 words
	.export _VoFatReadClusterRecord
_VoFatReadClusterRecord:
	ldx (I6)+1,NULL ; and NULL,NULL,A1	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+6,I4
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	mv I0,I1	// I0 -> 'f'
	mv I1,I0	// 'f' -> ET4
	stx I3,(I6)+1 ; ldy (I4)+5,NULL
// fi
// di
	ldy (I0)+6,NULL ; stx I4,(I6)+1	// ET4 += 6
	ldx (I0),I3 ; ldy (I4)-2,NULL	// ET4 ==> 6 -> 'di'
	mv I1,I0	// 'f' -> I0
// part2
// (f, fatCluster, &sector, &offset);
	stx I4,(I6)+1 ; ldy (I4)-6,NULL	// ETb
	ldx (I4)+1,C0 ; ldy (I3)+7,NULL	// unspill C0 from #0
	ldx (I4)+2,C1 ; ldy (I3)+7,NULL	// unspill C1 from #0
	call _VoFatClusterPos
	ldx (I3)+3,NULL	// 0 -> 'part2'
// jumped away
	ldx (I4)+3,NULL ; ldy (I6)-2,NULL	// I4 += 3
// 	if (!sector)
	ldx (I4)+1,B0
	ldx (I4)-4,B1
	ldc 0,B2	// update guard bits (cmp)
	sub B,NULL,B	// 'sector' == (0) -> (0)
	ldc 1022,B0	// 1022 -> 1 -> ET29
	jzs F9B4	// unsigned compare
	nop
// jumped away
	j F9B6
	ldc 32,B1	// 32 -> 1 -> ET14
// jumped away
F9B49:	// (loop lvl 2)
// 	switch (di->fatBits)
	ldx (I3)+5,NULL ; ldy (I4)+5,NULL	// 'di' += 5
	ldx (I3)-5,A0 ; ldy (I1)+7,NULL	// 'di' ==> 5 -> ET13
	sub A0,B1,C0	// ET13 == ET14 -> AT3f
	ldc 16,C0	// 16 -> ET1b
	jzs F9B11	// unsigned compare
	nop	// I4 += 5
// jumped away
	sub A0,C0,A0	// ET13 == ET1b -> AT41
	nop	// I4 += 5
	jzs F9B14	// unsigned compare
	nop
// jumped away
	ldx (I4)-5,A0 ; ldy (I1)+1,NULL
	sub A1,NULL,A1	// 'part2' != (0) -> (0)
// 		  if (part2)
	nop	// 8 -> 0 -> ET25
	jzc F9B19	// unsigned compare
	lsr C0,A1
// jumped away
	sub A0,B0,C0 ; ldx (I1)-1,NULL
// else if (offset < 1022)
	nop
	jcc F9B23	// unsigned compare
	lsr A0,C0	// 'offset' << (-1) -> ET23
// jumped away
	ldy (I4)+5,NULL ; ldx (I1)-7,NULL
// 		  }
// else {
// 		    t = MegaFatGetByte(f->sectorBuffer, offset>>1);
	ldx (I4)-5,A0	// I4 ==> 'offset'
	lsr A0,C0 ; mv I1,I0	// 'offset' << (-1) -> ET23
	ldx (I0)+7,NULL	// ET16 += 8
	ldx (I0)+1,NULL	// ...
	call _MegaFatGetByte
	ldx (I0),I2	// ET16 ==> 8 -> ET17
// jumped away
	ldx (I4)+5,NULL ; and D1,NULL,D1	// I4 += 5
	ldx (I4)-1,A0 ; add A0,NULL,D0	// ET2c msw 't'
// 		    offset -= 1022;
	sub A0,B0,A0 ; ldx (I4)+1,A1	// 'offset' - ET29 -> ET2e
	stx A0,(I4)-2
// 		    sector++;
	ldx (I4),A0
	sub A,ONES,A	// 'sector' - (-1) -> ET31
	stx A0,(I4)+1
	stx A1,(I4)-4 ; sub NULL,ONES,A1
// 		    part2 = 1;
// 		    goto again;
F9B6:	// (loop lvl 2)
	mv I1,I0	// 'f' -> ETe
	ldx (I4)+1,NULL ; ldy (I0)+7,NULL	// I4 += 1
	stx A0,(I4) ; sty A1,(I4)+2	// A0 spills to #0
// 	if (sector != f->currentSector)
	ldy (I0)+3,NULL ; ldx (I4)+1,C0	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	ldx (I4)-3,C1
	ldc 0,C2	// update guard bits (cmp)
	sub C,A,C	// 'sector' == ETf -> AT3e
	nop
	jzs F9B49	// unsigned compare
	add C,A,C ; ldy (I4)-1,A1	// restore value
// jumped away
	mv I1,I0	// 'f' -> I0
	ldx (I6)+1,NULL	// I4 += 1
	stx C0,(I6)+1	// unspill A1 from #0
// 	}
// {
// 		FatImageSectorRead(f, sector);
	call _FatImageSectorRead
	stx C1,(I6)	// C1
// jumped away
	j F9B49
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
F9B23:
// 		  }
// {
// 		    t = MegaFatGetWord(f->sectorBuffer, offset>>1);
	ldx (I1)+1,NULL	// ...
	call _MegaFatGetWord
	ldx (I1),I2	// 'f' ==> 8 -> ET17
// jumped away
	j F9B21
	and A1,NULL,A1
// jumped away
F9B19:
// 		  }
// {
// 		    t |= MegaFatGetByte(f->sectorBuffer, offset>>1)<<8;
	call _MegaFatGetByte
	ldx (I1),I2 ; lsr A0,C0	// 'offset' << (-1) -> ET23
// jumped away
	ashl A0,A1,A0	// ET24 << ET25 -> ET26
	ldc 0,A1
	or D,A,A	// 't' or ET27 -> 't'
F9B21:
	ldx (I4)+5,NULL ; sub NULL,ONES,B1	// I4 += 5
// 		  if (offset & 1)
	ldx (I4)-5,B0	// I4 ==> 'offset'
	and B0,B1,B0	// 'offset' and ET32 -> ET33
	ldc 4095,B0	// 4095 -> 3 -> B0
	jzc F9B28	// compare against zero
	and NULL,NULL,B1	// 0 -> B1
// jumped away
// 		  }
// else {
// 		    t &= 0x0FFF;
	and A,B,A	// 't' and ET37 -> 't'
F9B30:
// 		  if (t >= 0xff8)
	ldc 0,A2	// update guard bits (cmp)
	ldc 0,B1	// 0 -> B1
	ldc 0,B2	// update guard bits (cmp)
	ldc 4088,B0	// 4088 -> 3 -> B0
	sub A,B,D	// 't' < ET39 -> AT46
	ldc 4095,B1	// 4095 -> B1
	jcc F9B1	// unsigned compare
	ldc 61440,B0	// 61440 -> 3 -> B0
// jumped away
// 		  }
// {
// 		    t |= 0x0ffff000UL;
	or A,B,A	// 't' or ET3a -> 't'
F9B1:
	ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F9B28:
// 		  }
// {
// 		    t >>= 4;
	ldc 0,A2	// clear guard bits
	ldc -4,B0	// -4 -> 0 -> ET35
	j F9B30
	ashl A,B0,A	// 't' <- ET35 -> 't'
// jumped away
F9B14:
// 			t = MegaFatGetWord(f->sectorBuffer,offset);
	ldc 0,A1
	ldc 65528,B0	// 65528 -> 3 -> B0
	ldc 0,B1	// 0 -> B1
	ldy (I1)+1,NULL ; ldx (I4)-5,C0	// ...
	call _MegaFatGetWord
	ldx (I1),I2	// 'f' ==> 8 -> ET17
// jumped away
	ldc 0,B2	// update guard bits (cmp)
	ldc 0,A2	// update guard bits (cmp)
// 			if (t >= 0xfff8U)
	sub A,B,D	// 't' < ET1e -> AT43
	ldc 4095,B1	// 4095 -> B1
	jcc F9B1	// unsigned compare
	ldc 0,B0	// 0 -> 3 -> B0
// jumped away
// 			  t |= 0x0fff0000UL;
	j F9B1
	or A,B,A	// 't' or ET1f -> 't'
// jumped away
F9B11:
// 			t = MegaFatGetLong(f->sectorBuffer,offset) & 0x0fffffffUL;
	ldy (I1)+1,NULL ; ldx (I4)-5,C0	// ...
	call _MegaFatGetLong
	ldx (I1),I2	// 'f' ==> 8 -> ET17
// jumped away
	add A,NULL,B	// A -> ET18
	ldc 4095,A1	// 4095 -> A1
	ldc 65535,A0	// 65535 -> 3 -> A0
// 			break;
	j F9B1
	and B,A,A	// ET18 and ET19 -> 't'
// jumped away
F9B4:
// return 0xffffffffU;
	j F9B1
	or A,ONES,A	// 4294967295 -> 3 -> ETc
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatWriteClusterRecord	// 185 words
	.export _VoFatWriteClusterRecord
_VoFatWriteClusterRecord:
	ldc 2,A0	// 2 -> 3 -> A0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+6,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	mv I0,I1 ; and NULL,NULL,A1	// I0 -> 'f'
	stx I2,(I6) ; ldy (I4)-3,NULL
// fi
// di
	ldy (I1)+6,NULL ; ldx (I4)+1,C0	// 'f' += 6
	ldx (I1)-6,I2	// 'f' ==> 6 -> 'di'
// (fatCluster < 2)
	ldy (I2)+7,NULL ; ldx (I4)+2,C1	// 0 -> A1
	ldy (I2)+7,NULL	// ...
	ldx (I2)+3,NULL ; sub C,A,A	// ...
	nop
	jcs F10B4	// unsigned compare
	nop	// 'f' += -6
// jumped away
// return -1;
	or NULL,ONES,A0	// -1 -> 0 -> ETa
F10B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F10B4:
	mv I1,I0	// 'f' -> I0
	ldc -8,B1	// -8 -> 0 -> ETf
	ldc 8,B0	// 8 -> 0 -> ETe
	ldx (I4)+5,NULL ; ldy (I6)+1,NULL	// I4 += 5
// 	VoFatClusterPos(f, fatCluster, &sector, &offset);
	stx I4,(I6)+1 ; ldy (I4)-4,NULL	// ETb
	call _VoFatClusterPos
	stx I4,(I6)+1 ; ldy (I4)-1,NULL	// ETc
// jumped away
	ldx (I4)-5,NULL ; and D1,NULL,D1
	ldx (I4)+1,A0 ; and C1,NULL,C1
// 	v[0] =(((u_int16)((u_int16)newValue)>>8)|(((u_int16)newValue)<<8));
	ldx (I4)+7,A1 ; add A0,NULL,C0	// unspill A1 from #0
	ashl C,B1,C ; ldy (I2)+5,NULL	// AT4a <- ETf -> AT4b
	ashl A0,B0,C1 ; ldy (I6)-2,NULL	// ETd << ETe -> ET11
	ashl A1,B0,B0 ; mv I1,I0	// ET18 << ETe -> ET1a
	or C0,C1,C0	// ET10 or ET11 -> ET12
	stx C0,(I4)+1 ; add A1,NULL,D0
// 	v[1] =(((u_int16)((u_int16)(newValue >> 16))>>8)|(((u_int16)(newValue >> 16))<<8));
	ashl D,B1,D	// AT4c <- ETf -> AT4d
	ldc 32,B1	// 32 -> 1 -> ET21
	or D0,B0,B0	// ET19 or ET1a -> ET1b
	stx B0,(I4)-4
// 	switch (di->fatBits)
	ldx (I2),B0	// 'di' ==> 5 -> ET20
	sub B0,B1,B1	// ET20 != ET21 -> AT4e
	ldc 16,B1	// 16 -> 1 -> ET25
	jzc F10B8	// unsigned compare
	nop	// 0 -> 1 -> ET23
// jumped away
	ldc 4,A0	// 4 -> 1 -> ET22
	ldy (I6)+1,NULL ; ldx (I4)+3,NULL	// I4 += 3
// 		  FatImageWriteBytes(f,sector,offset,v,0,4);
	stx A0,(I6)+1 ; and NULL,NULL,A0	// ET22
	stx A0,(I6)+1	// ET23
	stx I4,(I6)+1 ; ldy (I4)+2,NULL	// ET13
	ldx (I4)-4,A0	// I4 ==> 'offset'
	stx A0,(I6)+1	// 'offset'
	ldx (I4)+1,A0
	ldx (I4)-2,A1
	stx A0,(I6)+1	// A0
	call _FatImageWriteBytes
	stx A1,(I6)	// A1
// jumped away
// 		  break;
F10B6:
// 	return 0;
	j F10B1
	ldx (I6)-6,NULL ; and NULL,NULL,A0	// I6 += -6
// jumped away
F10B8:
	sub B0,B1,B0 ; ldx (I4)+1,NULL	// ET20 != ET25 -> AT50
	ldy (I6)+1,NULL	// I4 += 1
	jzc F10B11	// unsigned compare
	add A0,NULL,A1	// 'newValue' lsw 'newVal16'
// jumped away
	ldc 2,A0	// 2 -> 1 -> ET26
	stx A0,(I6)+1 ; ldy (I4)+2,NULL
	and NULL,NULL,A0	// 0 -> 1 -> ET23
// 		  FatImageWriteBytes(f,sector,offset,v,0,2);
	stx A0,(I6)+1	// ET23
	stx I4,(I6)+1 ; ldy (I4)+2,NULL	// ET13
	ldx (I4)-4,A0	// I4 ==> 'offset'
	stx A0,(I6)+1	// 'offset'
	ldx (I4)+1,A0
	ldx (I4)-2,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	call _FatImageWriteBytes
// 		  break;
	ldc F10B6,LR0
// jumped away
F10B11:
// 		  }
// newVal16
// (f, sector);
	ldx (I4)+1,B0
	ldx (I4)-2,B1
	stx B0,(I6)+1	// B0
	call _FatImageSectorRead
	stx B1,(I6)	// B1
// jumped away
	ldx (I4)+5,NULL ; ldy (I6)-2,NULL	// I4 += 5
// 		    if (offset & 1)
	ldx (I4)-2,A0 ; sub NULL,ONES,B0	// I4 ==> 'offset'
	and A0,B0,B0	// 'offset' and ET29 -> ET2a
	nop
	jzs F10B15	// compare against zero
	nop	// I4 += 3
// jumped away
// 		    }
// {
// 		      v[0] = MegaFatGetByte(f->sectorBuffer, offset>>1);
	lsr A0,C0 ; mv I1,I0	// 'offset' << (-1) -> ET2b
	ldx (I0)+7,NULL ; ldy (I4)-3,NULL	// ET2d += 8
	ldx (I0)+1,NULL	// ...
	call _MegaFatGetByte
	ldx (I0),I2	// ET2d ==> 8 -> ET2e
// jumped away
	add A0,NULL,B0 ; ldx (I4)+3,NULL	// I4 += 3
// 		      v[0] = (v[0] & 0xf) | ((newVal16 & 0xf) << 4);
	ldc 15,A0	// 15 -> 1 -> ET0
	and B0,A0,B1	// ET2f and ET0 -> ET30
	and A1,A0,A0	// 'newVal16' and ET0 -> ET31
	ldc 4,B0	// 4 -> 0 -> ET32
	ashl A0,B0,A0	// ET31 << ET32 -> ET33
	or B1,A0,A0	// ET30 or ET33 -> ET34
	stx A0,(I4)-3
F10B16:
	ldy (I6)+1,NULL ; ldx (I4)+3,NULL	// I4 += 3
// 		    FatImageWriteBytes(f,sector,offset>>1,v,1,1);
	mv I1,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET29
	stx A0,(I6)+1	// ET29
	stx A0,(I6)+1	// ET29
	stx I4,(I6)+1 ; ldy (I4)+2,NULL	// ET13
	ldx (I4)-4,A0	// I4 ==> 'offset'
	lsr A0,A0	// 'offset' << (-1) -> ET2b
	stx A0,(I6)+1	// ET2b
	ldx (I4)+1,B0
	ldx (I4)-2,B1
	stx B0,(I6)+1	// B0
	ldc 1022,B0	// 1022 -> 1 -> ET36
	call _FatImageWriteBytes
	stx B1,(I6)	// B1
// jumped away
	ldx (I4)+5,NULL ; ldy (I6)-6,NULL	// I4 += 5
// 		    if (offset >= 1022)
	ldx (I4)-5,A0	// I4 ==> 'offset'
	sub A0,B0,B1	// 'offset' < ET36 -> AT52
	nop
	jcc F10B20	// unsigned compare
	nop
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
// 		    }
// {
// 		      sector++;
	ldx (I4)+1,C0
	ldx (I4)-1,C1
	sub C,ONES,C ; mv I1,I0	// 'sector' - (-1) -> ET39
	stx C0,(I4)+1 ; sub A0,B0,A0
	stx C1,(I4)+3
// 		      offset -= 1022;
	stx A0,(I4)-5
// 		      FatImageSectorRead(f, sector);
	stx C0,(I6)+1	// C0
	call _FatImageSectorRead
	stx C1,(I6)	// C1
// jumped away
	ldx (I6)-2,NULL	// I6 += -2
F10B21:
	ldx (I4)+5,NULL ; sub NULL,ONES,A0	// I4 += 5
// 		    if (offset & 1)
	ldx (I4),B0	// I4 ==> 'offset'
	and B0,A0,A0 ; mv A1,B0	// 'offset' and ET29 -> ET2a
	ldc -4,A0	// -4 -> 0 -> ET3d
	jzs F10B24	// compare against zero
	nop
// jumped away
	and B1,NULL,B1 ; ldx (I4)-2,NULL
// 		    }
// {
// 		      v[0] = newVal16>>4;
	ashl B,A0,A	// AT54 <- ET3d -> AT55
F10B25:
	stx A0,(I4) ; ldy (I6)+1,NULL
// 		    FatImageWriteBytes(f,sector,offset>>1,v,1,1);
	mv I1,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET29
	stx A0,(I6)+1	// ET29
	stx A0,(I6)+1	// ET29
	stx I4,(I6)+1 ; ldy (I4)+2,NULL	// ET13
	ldx (I4)-4,A0	// I4 ==> 'offset'
	lsr A0,A0	// 'offset' << (-1) -> ET2b
	stx A0,(I6)+1	// ET2b
	ldx (I4)+1,A0
	ldx (I4)-2,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	call _FatImageWriteBytes
// 		  break;
	ldc F10B6,LR0
// jumped away
F10B24:
// 		    }
// else {
// 		      v[0] = MegaFatGetByte(f->sectorBuffer, offset>>1);
	ldc 240,B0	// 240 -> 1 -> ET40
	ldx (I4)-5,A0	// I4 ==> 'offset'
	lsr A0,C0 ; mv I1,I0	// 'offset' << (-1) -> ET2b
	ldx (I0)+7,NULL	// ET2d += 8
	ldx (I0)+1,NULL	// ...
	call _MegaFatGetByte
	ldx (I0),I2	// ET2d ==> 8 -> ET2e
// jumped away
	and B1,NULL,B1 ; ldx (I4)+3,NULL
	and A0,B0,A0	// I4 += 3
// 		      v[0] = (v[0] & 0xf0) | ((newVal16 & 0xf00) >> 8);
	ldc 3840,B0	// 3840 -> 1 -> ET42
	and A1,B0,B0	// 'newVal16' and ET42 -> ET43
	ldc -8,A1	// -8 -> 0 -> ETf
	ashl B,A1,B	// AT56 <- ETf -> AT57
	j F10B25
	or A0,B0,A0	// ET41 or ET44 -> ET45
// jumped away
F10B20:
	ldc 2,B0	// 2 -> 1 -> ET26
	ldx (I4)+5,NULL	// I4 += 5
// 		    }
// else {
// 		      offset += 2;
	ldx (I4),A0	// I4 ==> 'offset'
	add A0,B0,A0	// 'offset' + ET26 -> ET3c
	j F10B21
	stx A0,(I4)-5
// jumped away
F10B15:
// 		    }
// else {
// 		      v[0] = newVal16;
	j F10B16
	stx A1,(I4)-3
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatGetFreeFragment	// 112 words
	.export _VoFatGetFreeFragment
_VoFatGetFreeFragment:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	mv I0,I1 ; and D,NULL,D	// I0 -> 'f'
	mv I1,I0	// 'f' -> ET4
	stx I3,(I6) ; ldy (I0)+6,NULL
// fi
// di
	ldx (I0),I2 ; ldy (I4)+1,NULL	// ET4 ==> 6 -> 'di'
// start
// size

	ldx (I2)+7,NULL	// 'di' += 17
	ldx (I2)+7,NULL	// ...
	ldx (I2)+3,NULL	// ...
	mv I2,I0	// 'di' -> ETb
	ldx (I0)+7,NULL	// ETb += 12
	ldx (I0)+5,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	add A,ONES,B ; mv I1,I3	// ETc + (-1) -> 'k'
// (k < di->totalClusters)
	ldx (I3)+7,NULL ; and A,NULL,A	// 0 -> 'size'
	stx A0,(I4) ; sty A1,(I4)-4	// A0 spills to #0
	ldy (I3)+7,NULL ; ldx (I4)+1,C0	// 0 -> 'start'
	j F11B6
	ldx (I4)+2,C1 ; ldy (I3)+1,NULL	// unspill C1 from #0
// jumped away
F11B3:	// (loop lvl 2)
// 	}
// {
// 		k++;
	sub B,ONES,B ; mv I1,I0	// 'k' - (-1) -> 'k'
// 		r = VoFatReadClusterRecord(f,k);
	stx B0,(I6)+1	// B0
	call _VoFatReadClusterRecord
	stx B1,(I6)	// B1
// jumped away
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; ldx (I6)-2,NULL	// I6 += -2
// 		if (r == 0)
	ldc 0,D2	// update guard bits (cmp)
	jzc F11B9	// unsigned compare
	sub D,NULL,D	// 'start' != (0) -> (0)
// jumped away
// 		}
// {
// 			if (start == 0)
	nop	// 'start' != (0) -> (0)
	jzc F11B12	// unsigned compare
	and A,NULL,A ; ldx (I4)+1,NULL	// I4 += 1
// jumped away
	add B,NULL,D ; stx A0,(I4) ; sty A1,(I4)	// 'k' -> 'start'
// 			}
// {
// 				start = k;
// 				size = 0;
F11B12:	// (loop lvl 2)
// 			size++;
	ldx (I4),A0 ; ldy (I4),A1	// unspill A0 from #0
	sub A,ONES,A	// 'size' - (-1) -> 'size'
	stx A0,(I4) ; sty A1,(I4)-1	// A0 spills to #0
	sub A,C,A	// 'size' >= 'requestedClusters' -> AT33
// 			if (size >= requestedClusters)
	nop
	jcs F11B15	// unsigned compare
	nop
// jumped away
F11B6:	// (loop lvl 2)
	ldc 0,B2	// update guard bits (cmp)
	ldx (I2)+2,NULL ; ldy (I6)+1,NULL	// 'di' += 2
	ldx (I2)+1,A0
	ldx (I2)-3,A1
	ldc 0,A2	// update guard bits (cmp)
	sub B,A,A	// 'k' < ET11 -> AT2f
	nop	// I6 += 1
	jcc F11B3	// unsigned compare
	nop
// jumped away
// 	if (start)
	ldc 0,D2	// update guard bits (cmp)
	sub D,NULL,D	// 'start' == (0) -> (0)
	ldc diskfull_2,A0
	jzs F11B19	// unsigned compare
	nop
// jumped away
	ldx (I6)-1,NULL
F11B15:
	ldx (I4)+1,NULL ; ldy (I2)+7,NULL	// I4 += 1
// 				di->allocationStartCluster = start+size;
	ldx (I4),A0 ; ldy (I4)-1,A1	// unspill A0 from #0
	add D,A,B ; mv I3,I0	// 'start' + 'size' -> ET17
	ldx (I2)+5,NULL ; ldy (I0)+2,NULL	// ...
	stx B0,(I2)+1
	stx B1,(I2)-7
// 				fi->currentFragment.startByteOffset += fi->currentFragment.sizeBytes;
	ldx (I0)+1,C0 ; ldy (I2)-2,NULL
	ldx (I0)+1,C1
	ldx (I0)+1,B0
	ldx (I0)-1,B1
	add B,C,B ; mv A0,I7	// ET1d + ET19 -> ET1e
	stx B0,(I0)+1
	stx B1,(I0)-3
// 				fi->currentFragment.startSector = start * di->fatSectorsPerCluster + di->dataStart;
	ldx (I2)+4,B0	// 'di' ==> 4 -> ET20
	muluu B0,D1 ; mv B0,A0	// 'start' * ET20 -> ET22
	add NULL,P,B ; ldx (I2)+1,C0	// (32x16)
	muluu A0,D0 ; mv I7,A0
	add B0,P,B ; ldx (I2)-5,C1
	add B,C,B ; mv C0,I7	// ET22 + ET25 -> ET26
	stx B0,(I3)+1
	stx B1,(I3)-1
// 				fi->currentFragment.sizeBytes = size * di->fatSectorsPerCluster * 512;
	ldx (I2),B0	// 'di' ==> 4 -> ET20
	muluu B0,A1 ; mv B0,C0	// 'size' * ET20 -> ET27
	add NULL,P,B	// (32x16)
	muluu C0,A0
	ldc 9,A0	// 9 -> 0 -> ET29
	add B0,P,B
	ashl B,A0,A	// ET27 << ET29 -> ET2a
	stx A0,(I0)+1
	stx A1,(I0)-1 ; add D,NULL,A
// 				return start;
F11B1:
	ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc diskfull_2,A0	// ET2c
	ldx (I6)+1,NULL	// I6 += 1
F11B19:
// 	SysError ("Disk Full");
	call _SysError
	stx A0,(I6)	// ET2c
// jumped away
// 	return 0;
	j F11B1
	ldx (I6)-1,NULL ; and A,NULL,A	// I6 += -1
// jumped away
F11B9:	// (loop lvl 2)
// 		}
// else {
// 			if (start)
	nop
	jzc F11B15	// unsigned compare
	nop
// jumped away
	j F11B6
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,WriteClusterChain	// 166 words
	.export _WriteClusterChain
_WriteClusterChain:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx D0,(I6) ; sty D1,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	mv I0,I2	// I0 -> 'f'
	stx I3,(I6) ; sty LC,(I6)+1
	stx LS,(I6) ; sty LE,(I6)
	ldy (I2)+6,NULL ; ldx (I4)-2,NULL	// I4 += -2
// di
	ldx (I2)-6,I1	// 'f' ==> 6 -> 'di'
// startCluster
	ldx (I4)+2,I0 ; ldy (I1)+7,NULL	// unspill 'frag' from #-2
	ldx (I0)+1,A0 ; ldy (I1)+7,NULL
	ldx (I0)-1,A1 ; ldy (I1)+7,NULL
	ldx (I1)+4,NULL	// 'di' += 8
	ldx (I1)+1,B0
	ldx (I1)-5,B1
	sub A,B,B ; ldx (I1)-4,D0	// ET6 - ET9 -> ETa
	call divide32unsigned
	mv D0,A0 ; and A1,NULL,A1
// jumped away
	add A,NULL,C ; ldx (I0)+2,NULL	// A -> 'startCluster'
// sizeClusters
	ldc 512,A0	// 512 lsw ET15
	ldx (I0)+1,B0 ; muluu D0,A0
	ldx (I0)-1,B1 ; add NULL,P,A
	add B,A,B	// ET12 + ET16 -> ET17
	call divide32unsigned
	add B,ONES,B	// ET17 + (-1) -> ET19
// jumped away
	ldx (I4)+1,NULL ; add A,NULL,B	// I4 += 1
// nextInChain
// (allocateMore)
	ldc 4095,A1	// 4095 -> A1
	ldc 65535,A0	// 65535 -> A0
	stx A0,(I4) ; sty A1,(I4)-4	// A0 spills to #0
	ldx (I4)+3,A0	// unspill 'allocateMore' from #-3
	sub A0,NULL,A0	// 'allocateMore' != (0) -> (0)
	nop
	jzs F12B15	// signed compare
	nop
// jumped away
// 	}
// {
// 	  nextInChain = VoFatGetFreeFragment(f, (allocateMore < 0) ? 2 : vo_fat_allocationSizeClusters);
	and NULL,NULL,D1 ; mv I2,I0	// 0 -> D1
	sub A0,NULL,A0 ; ldx (I6)+1,NULL	// 'allocateMore' < (0) -> (0)
	ldc 2,D0	// 2 -> D0
	jlt F12B8	// signed compare
	nop
// jumped away
	ldc _vo_fat_allocationSizeClusters,I0	// ET1f
	ldx (I0),D0/*V*/ ; and D1,NULL,D1	// ET1f ==> 'vo_fat_allocationSizeClusters'
	mv I2,I0	// 'f' -> I0
F12B8:
	stx D0,(I6)+1	// D0
	call _VoFatGetFreeFragment
	stx D1,(I6)	// D1
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)-2,NULL	// I4 += 1
	stx A0,(I4) ; sty A1,(I4)-1	// A0 spills to #0
// 	  if (nextInChain == 0)
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// 'nextInChain' == (0) -> (0)
	ldc 65471,A1	// 65471 -> 1 -> ET23
	jzc F12B15	// unsigned compare
	nop
// jumped away
	ldx (I2),A0 ; ldy (I4)+1,NULL	// I4 += 1
// 	  }
// {
// 	    nextInChain = 0x0fffffffu;
// 	    f->flags &= ~(1 << 6);
	and A0,A1,A0	// ET24 and ET23 -> ET25
	ldc 4095,A1	// 4095 -> A1
	stx A0,(I2)	// ET25 ==> 'f'
	ldc 65535,A0	// 65535 -> A0
	j F12B15
	stx A0,(I4) ; sty A1,(I4)-1	// A0 spills to #0
// jumped away
F12B12:	// (loop lvl 2)
	sub C,ONES,A ; ldy (I4)-1,NULL
// 	}
// {
// 		VoFatWriteClusterRecord(f, startCluster, startCluster+1);
	stx A0,(I6)+1	// A0
	stx A1,(I6)+1	// A1
	stx C0,(I6)+1	// C0
	call _VoFatWriteClusterRecord
	stx C1,(I6)	// C1
// jumped away
	ldc 127,A0	// 127 -> A0
	and NULL,NULL,A1 ; ldx (I6)-4,NULL	// I6 += -4
// 		if (!(startCluster & 127) && sizeClusters >= 128 && di->fatBits == 32)
	and C,A,A	// 'startCluster' and ET2a -> ET2b
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// ET2b != (0) -> (0)
	ldc 128,A0	// 128 -> A0
	jzc F12B18	// unsigned compare
	and NULL,NULL,A1	// 0 -> A1
// jumped away
	sub B,A,A ; ldx (I1)+5,NULL	// 'sizeClusters' >= ET2c -> AT5b
	ldc 32,A0
	jcs F12B20	// unsigned compare
	ldx (I1)-5,A1
// jumped away
F12B18:	// (loop lvl 2)
// 		}
// else {
// 			startCluster++;
	sub C,ONES,C	// 'startCluster' - (-1) -> 'startCluster'
F12B15:	// (loop lvl 2)
	add B,ONES,B ; ldx (I6)+1,NULL	// 'sizeClusters' + (-1) -> 'sizeClusters'
	ldc 0,B2	// update guard bits (cmp)
	sub B,NULL,B ; ldy (I4)+1,NULL	// 'sizeClusters' != (0) -> (0)
	mv I2,I0	// 'f' -> I0
	jzc F12B12	// unsigned compare
	nop
// jumped away
// 	VoFatWriteClusterRecord(f, startCluster, nextInChain);
	ldx (I4),A0 ; ldy (I4)-1,A1	// unspill A0 from #0
	stx A0,(I6)+1	// A0
	stx A1,(I6)+1	// A1
	stx C0,(I6)+1	// C0
	call _VoFatWriteClusterRecord
	stx C1,(I6)	// C1
// jumped away
	mv I2,I0	// 'f' -> I0
// 	FatFlush(f);
	call _FatFlush
	ldx (I6)-4,NULL	// I6 += -4
// jumped away
// 	return startCluster+1;
	sub C,ONES,A ; ldy (I6),LE	// 'startCluster' - (-1) -> ET28
	ldx (I6)-1,LS
	ldy (I6),LC ; ldx (I6)-1,I3
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),D1 ; ldx (I6)-1,D0
	ldy (I6),C1 ; ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 32,A0	// 32 -> ET30
	ldx (I1)+5,NULL	// 'di' += 5
	ldx (I1)-5,A1	// 'di' ==> 5 -> ET2f
F12B20:	// (loop lvl 2)
	sub A1,A0,A0	// ET2f == ET30 -> AT5a
	nop
	jzc F12B18	// unsigned compare
	nop
// jumped away
F12B25:	// (loop lvl 3)
	ldc 0,B2	// update guard bits (cmp)
	ldc 128,A0	// 128 -> A0
	mv I2,I0 ; and NULL,NULL,A1	// 0 -> A1
	ldc 0,A2	// update guard bits (cmp)
	sub B,A,A	// 'sizeClusters' < ET2c -> AT5c
	nop	// 'f' -> ET31
	jcc F12B23	// unsigned compare
	nop
// jumped away
// 			}

	ldc 127,LC	// loop 128 iterations
	ldx (I0)+7,NULL	// ET31 += 8
	ldx (I0)+1,NULL	// ...
// (i=0; i<128; i++)
	loop LC,F12B27-1
	ldx (I0),I0	// ET31 ==> 8 -> 'p'
//loop resumes
// 				}
// {
// 					*p++ = Swap32Mix(++startCluster);
	sub C,ONES,C ; ldx (I6)+1,NULL	// 'startCluster' - (-1) -> 'startCluster'
	call _Swap32Mix
	add C,NULL,D	// 'startCluster' -> D
// jumped away
	stx A0,(I0)+1
	stx A1,(I0)+1
//	(0 nop's needed)
// loop end
F12B27:	// loop exit
	ldy (I2)+7,NULL ; ldx (I6)+1,NULL	// I6 += 1
// 				f->dev->BlockWrite(f->dev, f->currentSector++, 1, f->sectorBuffer);
	ldx (I2)+1,NULL	// ...
	ldx (I2)+2,A0	// 'f' ==> 8 -> ET32
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET32
	stx A0,(I6)+1	// ET3b
	ldx (I2)+1,D0
	ldx (I2)-1,D1
	sub D,ONES,A	// ET3e - (-1) -> ET40
	stx A0,(I2)+1
	stx A1,(I2)-5
	stx D0,(I6)+1	// D0
	stx D1,(I6)	// D1
	ldx (I2)-6,I3	// 'f' ==> 6 -> ET41
	mv I3,I0	// ET41 -> I0
	ldx (I3)+7,NULL	// ET41 += 8
	ldx (I3)+1,NULL	// ...
	ldx (I3),A0	// ET41 ==> ET42
	mv A0,LR0
	jr
	ldc lo(F12B31),LR0	// (return address)
// jumped away
F12B31:	// (loop lvl 3)
	ldc 128,A0	// 128 -> A0
	and NULL,NULL,A1 ; ldx (I6)-4,NULL	// I6 += -4
// 				sizeClusters -= 128;
	j F12B25
	sub B,A,B	// 'sizeClusters' - ET2c -> 'sizeClusters'
// jumped away
F12B23:	// (loop lvl 2)
// 			sizeClusters++;
	ldc 65407,A0	// 65407 -> ET47
	sub B,ONES,B ; ldx (I2),A1	// 'sizeClusters' - (-1) -> 'sizeClusters'
// 			f->flags &= ~(1 << 7);
	ldy (I0)+7,NULL	// 'f' ==> ET24
	and A1,A0,A0 ; ldx (I0)+3,NULL	// ET24 and ET47 -> ET48
	stx A0,(I2) ; or A,ONES,A	// ET48 ==> 'f'
// 			f->currentSector = 0xFFFFFFFFU;
	stx A0,(I0)+1
	j F12B15
	stx A1,(I0)-1
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatFindSector	// 60 words
	.export _VoFatFindSector
_VoFatFindSector:
	ldc 128,A0	// 128 -> 1 -> ET4
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx B0,(I6) ; sty B1,(I6)+1
	stx C0,(I6) ; sty C1,(I6)+1
	stx I1,(I6)+1 ; sty I2,(I6)
// fi
// (((f)->flags &(1 << 7)))
	ldx (I0),A1	// 'f' ==> ET3
	and A1,A0,A0 ; mv I0,I2	// ET3 and ET4 -> ET5
	ldx (I2)+7,NULL ; sub A0,NULL,A0	// 'fi' += 15
	ldx (I2)+7,NULL	// ...
	jzc F13B3	// unsigned compare
	ldx (I2)+1,NULL	// ...
// jumped away
F13B4:
	ldc 0,D2	// update guard bits (cmp)
	ldy (I2)+4,NULL ; ldx (I6)-1,NULL
// 	if (pos < fi->currentFragment.startByteOffset ||
// 		pos >= fi->currentFragment.startByteOffset + fi->currentFragment.sizeBytes)
	ldx (I2)+1,A0
	ldx (I2)-5,A1
	ldc 0,A2	// update guard bits (cmp)
	sub D,A,B	// 'pos' < ET9 -> AT1a
	nop
	jcc F13B6	// unsigned compare
	nop
// jumped away
	ldx (I2)+2,NULL	// 'fi' += 2
	ldx (I2)+1,B0
	ldx (I2)-3,B1
	add A,B,A	// ET9 + ETc -> ETe
	sub D,A,A	// 'pos' >= ETe -> AT1c
	nop
	jcs F13B6	// unsigned compare
	nop
// jumped away
F13B7:
// 	return fi->currentFragment.startSector + ((pos - fi->currentFragment.startByteOffset) / 512);
	ldx (I2)+1,A0
	ldx (I2)+3,A1
	ldx (I2)+1,B0
	ldx (I2)-1,B1
	sub D,B,C ; ldy (I6),I2	// 'pos' - ET9 -> ET14
	ldc -9,B0	// -9 -> AT16
	ashl C,B0,B ; ldx (I6)-1,I1	// ET14 << AT16 -> ET17
	add A,B,A ; ldy (I6),C1	// ET13 + ET17 -> ET18
	ldx (I6)-1,C0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F13B6:
	mv I2,I1	// 'fi' -> ET10
	ldx (I6)+1,NULL ; ldy (I1)+6,NULL	// I6 += 1
// 	}
// {
// 		fi->currentFragment = FatGetFragmentFromFAT(f, fi->startCluster, pos);
	stx D0,(I6)+1	// D0
	stx D1,(I6)+1	// D1
	ldx (I1)+1,A0
	ldx (I1)-1,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)+1	// A1
	call _FatGetFragmentFromFAT
	stx I2,(I6)+1	// 'fi'
// jumped away
	j F13B7
	ldx (I6)-5,NULL	// I6 += -5
// jumped away
F13B3:
// vo_fflush(f);
	stx I0,(I6)	// 'f'
	call _vo_fflush
	ldc F13B4,LR0
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatWriteFile	// 177 words
	.export _VoFatWriteFile
_VoFatWriteFile:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+6,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2 ; and NULL,NULL,C0	// I0 -> 'f'
	mv I2,I1	// 'f' -> 'fi'
	mv I2,I0	// 'f' -> ET5
// fi
// written
// dstIdx
	ldx (I0)+3,NULL ; ldy (I1)+7,NULL	// ET5 += 3
	ldx (I0)+1,A0 ; ldy (I1)+7,NULL
	ldx (I0)-1,A1 ; ldy (I1)+5,NULL
// (f->pos < fi->currentFragment.startByteOffset ||
// 	    (f->pos < f->fileSize && f->pos >= fi->currentFragment.startByteOffset+fi->currentFragment.sizeBytes))
	ldc 0,A2	// update guard bits (cmp)
	ldx (I1)+1,B0
	ldx (I1)-5,B1
	ldc 0,B2	// update guard bits (cmp)
	sub A,B,D ; mv I2,I0	// ET6 < ETc -> AT39
	ldx (I0)+7,NULL	// ETe += 12
	jcc F14B3	// unsigned compare
	ldx (I0)+5,NULL	// ...
// jumped away
	ldx (I0)+1,D0
	ldx (I0)-1,D1
	sub A,D,D	// ET6 >= ETf -> AT3a
	nop
	jcs F14B28	// unsigned compare
	nop
// jumped away
	ldx (I1)+2,NULL	// 'fi' += 2
	ldx (I1)+1,D0
	ldx (I1)-3,D1
	add B,D,B	// ETc + ET13 -> ET14
	sub A,B,A	// ET6 >= ET14 -> AT3b
	nop
	jcs F14B3	// unsigned compare
	nop
// jumped away
F14B28:
	ldx (I4)-4,NULL	// I4 += -4
	ldx (I4)+2,C1	// unspill AT44 from #-4
	j F14B11
	ldx (I4)+2,B1	// unspill 'buf' from #-2
// jumped away
F14B15:	// (loop lvl 2)
	mv I2,I3 ; and NULL,NULL,D1	// 'f' -> ET5
	ldy (I4)-3,NULL ; ldx (I3)+3,NULL
	stx B0,(I6)+1	// A0 spills to #0
// 			FatImageWriteBytes(f, thisSec, (u_int16)(f->pos&511), buf, sourceIndex, writeAmount);
	ldx (I4)+4,D0	// unspill AT43 from #0
	stx D0,(I6)+1	// AT43
	ldc 511,D0	// 511 -> D0
	stx B1,(I6)+1	// 'buf'
	ldx (I3)+1,A0
	ldx (I3)-1,A1
	mv I2,I0 ; and A,D,D	// 0 -> D1
	stx D0,(I6)+1 ; ldy (I4),A1	// ET9
	ldx (I4)-1,A0	// unspill A0 from #0
	stx A0,(I6)+1	// A0
	call _FatImageWriteBytes
	stx A1,(I6)	// A1
// jumped away
	ldx (I4)-3,NULL ; ldy (I6)-6,NULL	// I4 += -3
// 			sourceIndex += writeAmount;
	ldx (I4),A0 ; and D1,NULL,D1	// unspill AT43 from #0
	add A0,B0,A0	// AT43 + 'writeAmount' -> AT43
	stx A0,(I4)+3 ; add B0,NULL,D0	// AT43 spills to #0
// 			byteSize -= writeAmount;
	sub C1,B0,C1 ; ldx (I3)+1,A0	// AT44 - 'writeAmount' -> AT44
// 			f->pos += writeAmount;
	ldx (I3)-1,A1	// 'writeAmount' msw ET19
	add A,D,A	// ET6 + ET19 -> ET1a
	stx A0,(I3)+1
	stx A1,(I3)-1
// 			if (f->pos > f->fileSize)
	ldx (I3)+1,A0
	ldx (I3)-1,A1
	mv I2,I3	// 'f' -> ETe
	ldx (I3)+7,NULL	// ETe += 12
	ldx (I3)+5,NULL	// ...
	ldx (I3)+1,D0
	ldx (I3)-1,D1
	sub D,A,D	// ETf <= ET6 -> AT42
	nop
	jcs F14B23	// unsigned compare
	nop
// jumped away
// 			}
// {
// 				f->fileSize = f->pos;
	stx A0,(I3)+1
	stx A1,(I3)-1
F14B23:	// (loop lvl 2)
// 			written += writeAmount;
	add C0,B0,C0	// 'written' + 'writeAmount' -> 'written'
F14B11:	// (loop lvl 2)
	sub C1,NULL,C1	// AT44 == (0) -> (0)
	ldc -9,D0	// -9 -> ET17
	jzs F14B9	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL ; ldy (I2)+3,NULL	// I4 += 2
	stx B0,(I4) ; sty B1,(I4)+1	// B0 spills to #0
// 	}
// {
// 		writeAmount = byteSize;
// 		if ((f->pos >> 9) < ((f->pos + writeAmount - 1) >> 9))
	ldx (I2)+1,A0
	ldx (I2)-4,A1
	ldc 0,A2	// clear guard bits
	stx D0,(I4) ; sty D1,(I4)+1	// D0 spills to #0
	ashl A,D0,B	// ET6 <- ET17 -> ET18
	stx B0,(I4) ; sty B1,(I4)-3	// B0 spills to #0
	stx C0,(I4) ; add C1,NULL,B0	// unspill B1 from #0
	sty C1,(I4)+1 ; add C1,NULL,C0	// C0 spills to #0
	ldc 0,C1
	ldy (I4)+1,B1 ; add A,C,D	// 'writeAmount' msw ET19
	mv A0,A1 ; add D,ONES,C	// ET6 + ET19 -> ET1a
	ldc 0,C2	// clear guard bits
	ldx (I4)+1,D0	// ET1a + (-1) -> ET1c
	ashl C,D0,D ; ldx (I4),C0	// ET1c <- ET17 -> ET1d
	ldy (I4)-3,C1	// unspill C1 from #0
	sub C,D,D	// ET18 >= ET1d -> AT3c
	ldc 511,A0	// 511 -> ET20
	jcs F14B30	// unsigned compare
	nop	// I4 += 1
// jumped away
	ldx (I4),C0 ; ldy (I4)-1,C1
	and A1,A0,A1	// ET1f and ET20 -> ET21
	sub A0,ONES,A0
// 		}
// {
// 			writeAmount = 512 - ((u_int16)f->pos & 511);
	sub A0,A1,B0	// ET1e - ET21 -> 'writeAmount'
F14B13:	// (loop lvl 2)
	mv I1,I0	// 'fi' -> ETb
	ldx (I4)+1,NULL ; ldy (I2)+3,NULL	// I4 += 1
	stx B0,(I4) ; sty B1,(I4)	// B0 spills to #0
// 		}
// fragPos
	ldx (I2)+1,A0 ; ldy (I0)+4,NULL
	ldx (I2)-4,A1
	ldx (I0)+1,D0
	ldx (I0)-1,D1
	sub A,D,D ; ldx (I1)+1,B0	// ET6 - ETc -> 'fragPos'
// thisSec
	ldc -9,A0	// -9 -> AT26
	ashl D,A0,A ; ldx (I1)-1,B1	// 'fragPos' << AT26 -> ET27
// (fragPos >= fi->currentFragment.sizeBytes)
	j F14B17
	add A,B,A ; ldx (I4),B0	// ET27 + ET29 -> 'thisSec'
// jumped away
F14B36:	// (loop lvl 3)
// 			}
// {
// 				WriteClusterChain(f, &fi->currentFragment,1);
	stx A0,(I6)+1	// ET2b
	call _WriteClusterChain
	stx I1,(I6)	// 'fi'
// jumped away
	ldc 64,A1	// 64 -> ET2e
	ldx (I2),A0 ; ldy (I6)-2,NULL	// I6 += -2
// 				if (!((f)->flags &(1 << 6)))
	and A0,A1,A1	// ET2d and ET2e -> ET2f
	ldc 64,A1	// 64 -> ET2e
	jzs F14B19	// compare against zero
	nop
// jumped away
	mv I1,I0	// 'fi' -> ETb
	ldx (I4)+1,NULL ; ldy (I2)+3,NULL	// I4 += 1
	stx B0,(I4) ; sty B1,(I4)	// B0 spills to #0
// 				fragPos = f->pos - fi->currentFragment.startByteOffset;
	ldx (I2)+1,D0 ; ldy (I0)+4,NULL
	ldx (I2)-4,D1
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	sub D,A,D	// ET6 - ETc -> 'fragPos'
// 				thisSec = (fragPos/512) + fi->currentFragment.startSector;
	ldc -9,A0	// -9 -> AT31
	ashl D,A0,B ; ldx (I1)+1,A0	// 'fragPos' << AT31 -> ET32
	ldx (I1)-1,A1
	add B,A,A ; ldx (I4),B0	// ET32 + ET29 -> 'thisSec'
F14B17:	// (loop lvl 3)
	mv D1,D1	// update guard bits (cmp)
	ldy (I4),B1 ; ldx (I1)+2,NULL	// unspill B1 from #0
	stx A0,(I4) ; sty A1,(I4)-1	// A0 spills to #0
	ldx (I1)+1,A0 ; ldy (I6)+1,NULL
	ldx (I1)-3,A1
	mv A1,A1	// update guard bits (cmp)
	sub D,A,D ; mv I2,I0	// 'fragPos' >= ET12 -> AT3f
	nop	// unspill A1 from #0
	jge F14B36	// signed compare
	sub NULL,ONES,A0	// 1 -> ET2b
// jumped away
	j F14B15
	nop
// jumped away
F14B19:
// 				}
// {
// 					f->flags |=(1 << 6);
	or A0,A1,A0	// ET2d or ET2e -> ET30
	stx A0,(I2) ; add C0,NULL,A0	// ET30 ==> 'f'
// 					return written;
F14B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldx (I4)+1,NULL	// I4 += 1
F14B30:	// (loop lvl 2)
	j F14B13
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
// jumped away
F14B9:
// 	return written;
	j F14B1
	add C0,NULL,A0	// 'written' returns via A0
// jumped away
F14B3:
	mv I2,I0	// 'f' -> ET5
// 	}
// {
// 	  VoFatFindSector(f, f->pos);
	ldx (I0)+3,NULL ; ldy (I6)+1,NULL	// ET5 += 3
	ldx (I0)+1,D0
	ldx (I0)-1,D1
	mv I2,I0	// 'f' -> I0
	call _VoFatFindSector
	ldc F14B28,LR0
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatCloseFile	// 166 words
	.export _VoFatCloseFile
_VoFatCloseFile:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc 4,A1	// 4 -> 0 -> ETa
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2	// I0 -> 'f'
	mv I2,I0	// 'f' -> 'fi'
	mv I2,I1	// 'f' -> ET4
	ldx (I4)+1,NULL ; ldy (I1)+7,NULL	// I4 += 1
// fi
// entry
	ldx (I1)+1,NULL ; ldy (I0)+7,NULL	// ...
	ldx (I1)-2,B0 ; ldy (I0)+7,NULL	// ET4 ==> 8 -> ET5
	ldy (I0)+1,NULL ; ldx (I1),I1	// ...
	sty I0,(I4)+1 ; ldx (I0)+7,NULL	// 'fi' spills to #0
	ldx (I0)+3,NULL ; ldy (I1)+7,NULL	// ...
	ldx (I0),A0 ; ldy (I1)+7,NULL	// ET7 ==> 10 -> ET8
	ashl A0,A1,A0 ; ldx (I2),A1	// ET8 << ETa -> ETb
	add B0,A0,B0 ; ldx (I1)+3,NULL	// ET5 + ETb -> ETc
// di
	ldc 64,A0	// 64 -> 1 -> ET14
// (((f)->flags &(1 << 6)))
	and A1,A0,A0 ; stx I1,(I4)-2	// ET13 and ET14 -> ET15
	mv B0,I1 ; sub A0,NULL,A0	// ETc -> 'entry'
	mv I2,I3	// 'f' -> ET17
	jzs F15B4	// unsigned compare
	nop
// jumped away
	mv I2,I0	// 'f' -> I0
// 	}
// {
// 		VoFatFindSector(f, f->fileSize);
	ldx (I3)+7,NULL ; ldy (I6)+1,NULL	// ET17 += 12
	ldx (I3)+5,NULL	// ...
	ldx (I3)+1,D0
	call _VoFatFindSector
	ldx (I3)-1,D1
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
// 		FatImageSectorRead(f,fi->directoryEntrySector);
	ldy (I4)-1,I0	// unspill 'fi' from #0
	ldx (I0)+7,NULL	// ET1a += 8
	ldx (I0)+1,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	mv I2,I0	// 'f' -> I0
	stx A0,(I6)+1	// A0
	call _FatImageSectorRead
	stx A1,(I6)	// A1
// jumped away
	ldc _currentTime+5,I0	// ET30
	ldc 8,A0	// 8 -> 0 -> ET1e
	ldc -8,A1	// -8 -> 0 -> ET1f
	ldx (I4)+1,NULL ; ldy (I6)-1,NULL	// I4 += 1
	stx I2,(I4) ; and C1,NULL,C1	// AT86 spills to #1
// 		entry->fileSizeLo =(((u_int16)((u_int16)(f->fileSize))>>8)|(((u_int16)(f->fileSize))<<8));
	ldx (I3)+1,B0
	add B0,NULL,C0 ; mv I1,I2	// ET1d msw AT7b
	ashl B0,A0,B0 ; ldx (I2)+7,NULL	// ET1d << ET1e -> ET21
	ldx (I2)+7,NULL ; ashl C,A1,C
	or C0,B0,B0	// ET20 or ET21 -> ET22
	stx B0,(I2)+1 ; and C1,NULL,C1	// ET22 ==> ET24
// 		entry->fileSizeHi =(((u_int16)((u_int16)((f->fileSize) >> 16))>>8)|(((u_int16)((f->fileSize) >> 16))<<8));
	ldx (I3)-1,B1
	mv B1,C0 ; ashl B1,A0,B0	// ET29 msw AT7d
	ashl C,A1,C	// AT7d <- ET1f -> AT7e
	or C0,B0,B0	// ET2a or ET2b -> ET2c
	stx B0,(I2)-3 ; and C1,NULL,C1	// ET2c ==> ET24
// 		entry->writeDate =(((u_int16)(((currentTime.tm_year-80)<<9) | ((currentTime.tm_mon+1) << 5) | currentTime.tm_mday)>>8)|((((currentTime.tm_year-80)<<9) | ((currentTime.tm_mon+1) << 5) | currentTime.tm_mday)<<8));
	ldc 80,B0	// 80 -> 0 -> ET32
	ldx (I0)-1,B1	// ET30 ==> 5 -> ET31
	sub B1,B0,B0	// ET31 - ET32 -> ET33
	sub A0,ONES,B1
	ashl B0,B1,C0 ; ldx (I0)-1,B0	// ET33 << ET34 -> ET35
	sub B0,ONES,B1	// ET38 - (-1) -> ET3a
	ldc 5,B0	// 5 -> 0 -> ET3b
	ashl B1,B0,B1	// ET3a << ET3b -> ET3c
	or C0,B1,C0 ; ldx (I0)-1,B1	// ET35 or ET3c -> ET3d
	or C0,B1,B1	// ET3d or ET40 -> ET41
	ashl B1,A0,B1 ; mv B1,C0	// ET41 << ET1e -> ET44
	ashl C,A1,C	// AT7f <- ET1f -> AT80
	or C0,B1,B1	// ET43 or ET44 -> ET46
	stx B1,(I2)-1 ; and C1,NULL,C1	// ET46 ==> ET24
// 		entry->writeTime =(((u_int16)((currentTime.tm_hour << 11) | (currentTime.tm_min << 5) | (currentTime.tm_sec/2))>>8)|(((currentTime.tm_hour << 11) | (currentTime.tm_min << 5) | (currentTime.tm_sec/2))<<8));
	ldc 11,B1	// 11 -> 0 -> ET4b
	ldx (I0)-1,C0	// ET30 ==> 2 -> ET4a
	ashl C0,B1,C0 ; ldx (I0)-1,B1	// ET4a << ET4b -> ET4c
	ashl B1,B0,B0	// ET4f << ET3b -> ET50
	or C0,B0,B1 ; ldx (I0),B0	// ET4c or ET50 -> ET51
	ldc -1,C0	// -1 -> AT54
	ashl B0,C0,C0	// ET52 << AT54 -> ET55
	or B1,C0,C0	// ET51 or ET55 -> ET56
	ashl C,A1,C	// AT81 <- ET1f -> AT82
	ldc -1,A1	// -1 -> AT59
	ashl B0,A1,A1	// ET52 << AT59 -> ET5a
	or B1,A1,A1	// ET51 or ET5a -> ET5b
	ashl A1,A0,A0	// ET5b << ET1e -> ET5c
	or C0,A0,A0	// ET58 or ET5c -> ET5e
	stx A0,(I2)	// ET5e ==> ET24
// 		if (f->fileSize == 0)
	ldx (I3)+1,A0
	ldx (I3)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	ldx (I4)-1,I2 ; sub A,NULL,A	// unspill AT86 from #1
	ldy (I2)+7,NULL
	jzc F15B8	// unsigned compare
	ldx (I2)+1,NULL
// jumped away
	ldy (I4)+2,NULL ; ldx (I1)+7,NULL
	ldx (I4)-2,I0 ; ldy (I1)+3,NULL	// I4 += 2
	ldx (I1)+3,A0 ; and B0,NULL,B0
// 		}
// {
// 			di->allocationStartCluster = ((u_int32)(entry->firstClusHi) << 16) | (entry->firstClusLo);
	ldy (I0)+7,NULL ; and A1,NULL,A1	// 'entry' ==> 10 -> ET63
	ldx (I1),A0 ; add A0,NULL,B1
	or B,A,A ; ldy (I0)+5,NULL	// ET65 or ET69 -> ET6a
	stx A0,(I0)+1 ; and NULL,NULL,A0
	stx A1,(I0)-1
// 			entry->firstClusHi = entry->firstClusLo = 0;
	stx A0,(I1)-3	// ET6c ==> 'entry'
	stx A0,(I1)	// ET6c ==> 'entry'
// 		f->dev->BlockWrite(f->dev, f->currentSector, 1, f->sectorBuffer);
F15B8:
	ldx (I2)+2,A0	// 'f' ==> 8 -> ET5
	stx A0,(I6)+1 ; sub NULL,ONES,A0	// ET5
	stx A0,(I6)+1	// ET4d
	ldx (I2)+1,A0
	ldx (I2)-5,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I2)-6,I1	// 'f' ==> 6 -> ET6f
	mv I1,I0	// ET6f -> I0
	ldx (I1)+7,NULL	// ET6f += 8
	ldx (I1)+1,NULL	// ...
	ldx (I1),A0	// ET6f ==> ET70
	mv A0,LR0
	jr
	ldc lo(F15B9),LR0	// (return address)
// jumped away
F15B9:
	mv I2,I0	// 'f' -> ET17
	ldy (I0)+7,NULL ; ldx (I6)-4,NULL	// I6 += -4
// 		if (f->fileSize == 0)
	ldx (I0)+5,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// ET18 != (0) -> (0)
	nop
	jzc F15B11	// unsigned compare
	and NULL,NULL,A0	// 0 -> 0 -> ET72
// jumped away
// 		}
// {
// 			return 0;
F15B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F15B11:
	mv I2,I0	// 'f' -> ET17
	ldx (I0)+7,NULL ; ldy (I4)+1,NULL	// I4 += 1
// 		  }
// bytesInCurrentFrag
	ldx (I0)+5,NULL ; ldy (I6)+1,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldy (I4)-1,I0	// unspill 'fi' from #0
	mv I0,I1	// 'fi' -> ET73
	ldx (I1)+4,NULL	// ET73 += 4
	ldx (I1)+1,B0
	ldx (I1)-3,B1
	sub A,B,A	// ET18 - ET74 -> 'bytesInCurrentFrag'
// ->currentFragment.sizeBytes = bytesInCurrentFrag;
	stx A0,(I1)+1 ; and NULL,NULL,A0
	stx A1,(I1)-1
// 		di->allocationStartCluster = WriteClusterChain(f, &fi->currentFragment,0);
	stx A0,(I6)+1	// ET72
	stx I0,(I6)	// 'fi'
	call _WriteClusterChain
	mv I2,I0	// 'f' -> I0
// jumped away
	ldx (I4)+2,NULL ; ldy (I6)-2,NULL	// I4 += 2
	ldx (I4)-2,I0	// unspill 'di' from #0
	ldx (I0)+7,NULL	// 'di' += 12
	ldx (I0)+5,NULL	// ...
	stx A0,(I0)+1
	stx A1,(I0)-1
F15B4:
// 	return 0;
	j F15B1
	and NULL,NULL,A0	// 0 -> 0 -> ET72
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatReadFile	// 137 words
	.export _VoFatReadFile
_VoFatReadFile:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2	// I0 -> 'f'
	ldx (I4)-3,NULL	// I4 += -3
// dstIdx
// (byteSize)
	ldx (I4)+1,C1	// unspill 'byteOff' from #-3
	j F16B6
	ldx (I4)+2,I3 ; add C1,NULL,C0	// 'byteOff' -> 'dstIdx'
// jumped away
F16B3:	// (loop lvl 2)
	stx C0,(I4) ; sty C1,(I4)-5	// C0 spills to #0
// 	}
// {
// 		readAmount = byteSize;
// 		if ((f->pos >> 9) < ((f->pos + readAmount - 1) >> 9))
	ldx (I2)+1,A0 ; and D1,NULL,D1
	ldx (I2)-4,A1
	ldc 0,A2	// clear guard bits
	ashl A,B0,C ; ldx (I4)+5,B1	// ET2 <- ET4 -> ET5
	mv B1,D0	// 'readAmount' msw ET6
	add A,D,D ; mv A0,A1	// ET2 + ET6 -> ET7
	add D,ONES,D	// ET7 + (-1) -> ET9
	ldc 0,D2	// clear guard bits
	ashl D,B0,D	// ET9 <- ET4 -> ETa
	sub C,D,D	// ET5 >= ETa -> AT2d
	ldc 511,A0	// 511 -> ETd
	jcs F16B25	// unsigned compare
	nop
// jumped away
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
	and A1,A0,A1	// ETc and ETd -> ETe
	sub A0,ONES,A0
// 		}
// {
// 			readAmount = 512 - ((u_int16)f->pos & 511);
	sub A0,A1,B1	// ETb - ETe -> 'readAmount'
F16B8:	// (loop lvl 2)
	mv I2,I0 ; and D1,NULL,D1	// 'f' -> ET1
	ldx (I4)+1,NULL ; ldy (I0)+3,NULL	// I4 += 1
	stx C0,(I4) ; sty C1,(I4)-1	// C0 spills to #0
// 		if (f->pos + readAmount > f->fileSize)
	ldx (I0)+1,A0 ; add B1,NULL,D0
	ldx (I0)+7,A1
	ldx (I0)+1,NULL ; add A,D,C	// 'readAmount' msw ET6
	ldx (I0)+1,D0	// ET2 + ET6 -> ET7
	ldx (I0)-1,D1
	sub D,C,D	// ET12 <= ET7 -> AT30
	nop
	jcs F16B27	// unsigned compare
	add D,C,D	// restore value
// jumped away
	ldy (I4)+1,NULL ; ldx (I2),A1	// I4 += 1
	ldx (I4),C0 ; sub D0,A0,B0	// ET12 - ET2 -> ET13
	ldc 4,A0	// 4 -> ET15
	ldy (I4)-1,C1 ; or A1,A0,A0	// unspill C0 from #0
// 		}
// {
// 			readAmount = (u_int16)(f->fileSize - f->pos);
// 			f->flags |=(1 << 2);
	stx A0,(I2) ; sub B0,NULL,B1	// ET17 ==> 'f'
// 			if ((s_int16)readAmount <= 0)
	nop
	jle F16B11	// signed compare
	nop
// jumped away
F16B10:	// (loop lvl 2)
	mv I2,I0	// 'f' -> ET1
// 		}
// sect
	ldx (I0)+3,NULL ; ldy (I6)+1,NULL	// ET1 += 3
	ldx (I0)+1,D0
	ldx (I0)-1,D1
	call _VoFatFindSector
	mv I2,I0	// 'f' -> I0
// jumped away
	add A,NULL,D ; mv I2,I0	// A -> 'sect'
// (f->currentSector != sect)
	ldc 0,D2	// update guard bits (cmp)
	ldx (I0)+7,NULL ; ldy (I4)+1,NULL	// ET1e += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub A,D,A ; mv I2,I0	// ET1f == 'sect' -> AT33
	ldc 511,A0
	jzs F16B15	// unsigned compare
	ldy (I0)+3,NULL
// jumped away
	mv I2,I0	// 'f' -> I0
	ldy (I6)+1,NULL ; ldx (I4)-1,NULL
// 			}
// {
// 				if (FatImageSectorRead(f, sect) != 0)
	stx D0,(I6)+1	// D0
	call _FatImageSectorRead
	stx D1,(I6)	// D1
// jumped away
	ldx (I6)-2,NULL ; sub A0,NULL,A0	// I6 += -2
	ldc 12,A0
	jzc F16B16	// signed compare
	nop
// jumped away
	mv I2,I0	// 'f' -> ET1e
	ldc 511,A0	// 511 -> A0
// 				f->currentSector = sect;
	ldx (I0)+7,NULL ; ldy (I4)+1,NULL	// ET1e += 10
	ldx (I0)+3,NULL	// ...
	stx D0,(I0)+1
	stx D1,(I0)-1
	mv I2,I0	// 'f' -> ET1
	ldy (I0)+3,NULL	// I4 += 1
F16B15:	// (loop lvl 2)
// 		MemCopyPackedBigEndian(buf, dstIdx, f->sectorBuffer, (u_int16)(f->pos & 511), readAmount);
	ldx (I0)+1,D0 ; and NULL,NULL,A1
	ldx (I0)+4,D1
	stx I0,(I4)-1	// 0 -> A1
	and D,A,D ; ldx (I0),I1	// ET2 and ET25 -> ET26
	mv I3,I0 ; add C0,NULL,A0	// 'buf' -> I0
	call _MemCopyPackedBigEndian
	mv D0,A1 ; add B1,NULL,B0	// 'readAmount' -> B0
// jumped away
	ldx (I4)+1,NULL ; and D1,NULL,D1	// I4 += 1
	ldx (I4)-5,I0 ; add B1,NULL,D0	// unspill ET1 from #0
	ldx (I0)-5,NULL	// ET1 += -5
// 		dstIdx += readAmount;
	add C0,B1,C0 ; ldx (I0)+1,A0	// 'dstIdx' + 'readAmount' -> 'dstIdx'
// 		f->pos += readAmount;
	ldx (I0)-1,A1	// 'readAmount' msw ET6
	add A,D,A	// ET2 + ET6 -> ET7
	stx A0,(I0)+1
	stx A1,(I0)-1
// 		byteSize -= readAmount;
	ldx (I4),A0	// unspill AT36 from #0
	sub A0,B1,A0	// AT36 - 'readAmount' -> AT36
	stx A0,(I4)+4	// AT36 spills to #0
F16B6:	// (loop lvl 2)
	ldx (I4)-4,NULL ; ldy (I2)+3,NULL	// I4 += -4
	ldx (I4)+5,A0	// unspill AT36 from #0
	sub A0,NULL,A0	// AT36 != (0) -> (0)
	ldc -9,B0	// -9 -> ET4
	jzc F16B3	// unsigned compare
	nop	// I4 += 1
// jumped away
// 	return dstIdx - byteOff;
	j F16B1
	ldx (I4)-1,NULL ; sub C0,C1,A0
// jumped away
F16B11:
// 			}
// {
// 				return dstIdx - byteOff;
	sub C0,C1,A0	// 'dstIdx' - 'byteOff' -> ET1b
F16B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 12,A0	// 12 -> 1 -> ET10
F16B16:
	ldx (I2),A1 ; ldy (I6)+1,NULL	// I6 += 1
// 				}
// {
// 					f->flags |=(1 << 3) |(1 << 2);
	or A1,A0,A0	// ET16 or ET10 -> ET21
	stx A0,(I2)	// ET21 ==> 'f'
// 					SysError("Read");
	ldc read_3,A0	// ET22
	call _SysError
	stx A0,(I6)	// ET22
// jumped away
// 					return 0;
	j F16B1
	ldx (I6)-1,NULL ; and NULL,NULL,A0	// I6 += -1
// jumped away
F16B27:	// (loop lvl 2)
	ldx (I4)+1,NULL	// I4 += 1
	j F16B10
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
// jumped away
F16B25:	// (loop lvl 2)
	j F16B8
	ldx (I4),C0 ; ldy (I4)-1,C1	// unspill C0 from #0
// jumped away

//_____________________________________________________________
//
	.sect code,FatNameFromDirEntry	// 67 words
	.export _FatNameFromDirEntry
_FatNameFromDirEntry:
	ldx (I6)+2,NULL ; and NULL,NULL,A0	// I6 += 2
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty I0,(I6)+1
	stx I1,(I6) ; sty I2,(I6)+1
	stx LC,(I6) ; sty LS,(I6)+1
	ldc 3,LC	// loop 4 iterations
	stx LE,(I6) ; ldy (I4)-3,NULL

// l = 0;
	ldx (I4)+1,I1	// 0 -> 0 -> ET0
	mv I1,I0	// 'longName' -> AT35
	stx A0,(I1)	// ET0 ==> AT35
// 	for (i=0;i<4;i++)
	loop LC,F17B4-1
	ldx (I4)+2,I2	// unspill AT31 from #-2
//loop resumes
// 	}
// {
// 		*l++ = *dirEntry >> 8;
	ldc -8,A0	// -8 -> 0 -> ET5
	ldx (I2),B0 ; and B1,NULL,B1	// AT31 ==> ET3
	ashl B,A0,A	// AT21 <- ET5 -> AT22
	stx A0,(I0)+1	// ET6 ==> AT35
// 		*l++ = *dirEntry++ & 0xff;
	ldc 255,A0	// 255 -> 1 -> ETe
	ldx (I2)+1,A1	// AT31 ==> ETd
	and A1,A0,A0	// ETd and ETe -> ETf
	stx A0,(I0)+1	// ETf ==> AT35
//	(0 nop's needed)
// loop end
F17B4:	// loop exit
// 	l--;
// 	while (*l <= ' ')
	ldc 32,A0	// 32 -> 0 -> ET17
	ldx (I0)-1,NULL	// AT35 += -1
// 	}
// {
// 		l--;
	ldx (I0)-1,A1	// AT35 ==> ET16
F17B7:	// (loop lvl 2)
	sub A1,A0,A0 ; ldx (I0)-1,A1	// ET16 <= ET17 -> AT26
	ldc 32,A0
	jle F17B7	// signed compare
	ldc 0,B1	// AT31 ==> ET18
// jumped away
	ldc -8,A0	// -8 -> 0 -> ET5
	ldx (I2),B0 ; ldy (I0)+2,NULL
// 	if (*dirEntry >> 8 != ' ')
	ashl B,A0,A	// AT23 <- ET5 -> AT24
	ldc 32,A1	// 32 -> 1 -> ET1a
	sub A0,A1,A0	// ET19 == ET1a -> AT25
	ldc 255,A1
	jzs F17B12	// unsigned compare
	ldc -8,A0
// jumped away
// 	}
// {
// 		*++l = '.';
	ldc 46,A0	// 46 -> 0 -> ET1b
	ldx (I0)+1,NULL ; and B1,NULL,B1	// AT35 += 1
	stx A0,(I0)	// ET1b ==> AT35
// 	*++l = *dirEntry >> 8;
	ldc -8,A0	// -8 -> 0 -> ET5
F17B12:
	ldx (I2),B0 ; ldy (I0)+1,NULL	// AT31 ==> ET18
	ashl B,A0,B	// AT27 <- ET5 -> AT28
	stx B0,(I0)+1 ; and B1,NULL,B1	// ET1c ==> AT35
// 	*++l = *dirEntry++ & 0xff;
	ldx (I2)+1,B0	// AT31 ==> ETd
	and B0,A1,A1	// ETd and ETe -> ET10
	stx A1,(I0)+1	// ET10 ==> AT35
// 	*++l = *dirEntry >> 8;
	ldx (I2),B0	// AT31 ==> 1 -> ET1d
	ashl B,A0,A	// AT29 <- ET5 -> AT2a
	stx A0,(I0)	// ET1e ==> AT35
// 	while (*l <= ' ')
	ldc 32,A0	// 32 -> 0 -> ET17
// 	}
// {
// 		l--;
	ldx (I0),A1	// AT35 ==> ET20
F17B13:	// (loop lvl 2)
	sub A1,A0,A1 ; ldx (I0)-1,NULL	// ET20 <= ET17 -> AT2c
	ldx (I0),A1
	jle F17B13	// signed compare
	nop
// jumped away
	ldx (I0)+2,NULL ; and NULL,NULL,A0
// ;
// 	*++l = '\0';
	stx A0,(I0)	// ET0 ==> AT35
	mv I1,A0	// 'longName' returns via A0
// 	return longName;
	ldx (I6)-1,LE
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I2 ; ldx (I6)-1,I1
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,FatOpenEntry	// 108 words
	.export _FatOpenEntry
_FatOpenEntry:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+3,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6)+1 ; sty I3,(I6)
	mv I0,I2 ; and C,NULL,C	// I0 -> 'f'
	mv I2,I0 ; and D1,NULL,D1	// 'f' -> ET1
	ldy (I0)+7,NULL ; ldx (I4)+2,NULL	// I4 += 2
// fi
	ldx (I0)+7,NULL ; and B1,NULL,B1	// ...
	ldx (I0)+1,NULL	// ...
	stx I0,(I4)-1
	mv I2,I0	// 'f' -> ET5
// ->directoryEntrySector = (f->currentSector);
	ldx (I0)+7,NULL	// ET5 += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)+7,A1
	ldx (I0)+5,NULL	// ...
	stx A0,(I0)+1
	ldc 32,A0	// 32 -> 3 -> A0
	stx A1,(I0)-1
// 	fi->directoryEntryNumber = (u_int16)((f->pos - 32) & 511) / 32;
	ldc -5,A1	// -5 -> AT12
	stx I2,(I4)+1 ; ldy (I2)+3,NULL	// 'f' spills to #1
	ldx (I2),B0
	sub B0,A0,B0 ; ldx (I4)-4,I0	// ETb - ETc -> ETd
	ldc 511,A0	// 511 -> 3 -> A0
	and B0,A0,A0 ; ldx (I0)+7,NULL	// ETd and ETe -> ETf
	ashl A0,A1,A0 ; ldx (I0)+3,NULL	// ET10 << AT12 -> ET13
	ldc -8,A1	// -8 -> 0 -> ET19
	stx A0,(I0)-4/*V*/	// ET13 ==> ET14
// 	f->pos = 0;
	ldc 8,A0	// 8 -> 0 -> ET18
	stx C0,(I2)+1
	stx C1,(I2)+7 ; and C1,NULL,C1
// 	f->fileSize = ((u_int32)(((u_int16)(de->fileSizeHi)>>8)|((de->fileSizeHi)<<8)) << 16) |(((u_int16)(de->fileSizeLo)>>8)|((de->fileSizeLo)<<8)) ;
	ldx (I4)+4,I1 ; ldy (I2)+1,NULL	// unspill 'de' from #-2
	mv I1,I3	// 'de' -> ET16
	ldx (I3)+7,NULL	// ET16 += 15
	ldx (I3)+7,NULL	// ...
	ldx (I3)+1,NULL	// ...
	ldx (I3)-1,B0	// ET16 ==> 15 -> ET17
	ashl B0,A0,B0 ; mv B0,D0	// ET17 << ET18 -> ET1b
	ashl D,A1,D	// AT48 <- ET19 -> AT49
	or D0,B0,B0	// ET1a or ET1b -> ET1c
	ldc 0,D0
	ldx (I3)-4,B0 ; add B0,NULL,D1	// ET1d <<< ET1f
	ashl B0,A0,B0 ; mv B0,C0	// ET22 << ET18 -> ET24
	ashl C,A1,C	// AT4a <- ET19 -> AT4b
	or C0,B0,B0	// ET23 or ET24 -> ET25
	or D,B,B	// ET1f or ET26 -> ET27
	stx B0,(I2)+1 ; and D1,NULL,D1
	stx B1,(I2)-1 ; and C1,NULL,C1
// 	fi->startCluster = ((u_int32)(((u_int16)(de->firstClusHi)>>8)|((de->firstClusHi)<<8)) << 16) |(((u_int16)(de->firstClusLo)>>8)|((de->firstClusLo)<<8)) ;
	ldx (I3)+3,B0	// ET16 ==> 10 -> ET2b
	ashl B0,A0,B0 ; mv B0,D0	// ET2b << ET18 -> ET2d
	ashl D,A1,D	// AT4c <- ET19 -> AT4d
	or D0,B0,B0	// ET2c or ET2d -> ET2e
	ldc 0,D0
	ldx (I3),B0 ; add B0,NULL,D1	// ET2f <<< ET30
	mv B0,C0 ; ashl B0,A0,A0	// ET33 msw AT4e
	mv D0,A1 ; ashl C,A1,C
	or C0,A0,A0	// ET34 or ET35 -> ET36
	or D,A,A	// ET30 or ET37 -> ET38
	stx A0,(I0)+1/*V*/ ; and C,NULL,C
	stx A1,(I0)-1/*V*/
// 	fi->currentFragment = FatGetFragmentFromFAT(f, fi->startCluster, 0);
	stx C0,(I6)+1	// C0
	stx C1,(I6)+1	// C1
	ldx (I4)-1,A0	// I4 ==> 'fi'
	ldx (I0)+1,B0/*V*/
	ldx (I0)-1,B1/*V*/
	stx B0,(I6)+1	// B0
	stx B1,(I6)+1	// B1
	stx A0,(I6)+1	// 'fi'
	ldx (I4)-1,I2	// unspill 'f' from #1
	call _FatGetFragmentFromFAT
	mv I2,I0	// 'f' -> I0
// jumped away
	ldc _longFileName,I0	// ET43
	ldc 255,A0	// 255 -> 1 -> ET40
	ldy (I1)+5,NULL ; ldx (I2)+5,NULL	// I6 += -5
// 	f->ungetc_buffer = de->attr&0xff;
	ldx (I1),A1 ; ldy (I6)-5,NULL	// 'de' ==> 5 -> ET3f
	and A1,A0,A0	// ET3f and ET40 -> ET41
	stx A0,(I2)	// ET41 ==> 'f'
// 	if (longFileName[0])
	ldx (I0),A0	// ET43 ==> ET44
	sub A0,NULL,A0	// ET44 == (0) -> (0)
	ldc _lfnStartCluster,I0
	jzs F18B6	// signed compare
	and A,NULL,A
// jumped away
	ldx (I4)+2,NULL	// I4 += 2
// 	}
// {
// 		lfnStartCluster = fi->startCluster;
	ldx (I4)-2,I0	// I4 ==> 'fi'
	ldx (I0)+6,NULL	// ET3a += 6
	ldx (I0)+1,A0/*V*/
	ldx (I0)-1,A1/*V*/
	ldc _lfnStartCluster,I0	// ET46
F18B6:
	stx A0,(I0)+1/*V*/ ; ldy (I6),I3
	stx A1,(I0)-1/*V*/ ; and NULL,NULL,A0
// 	return 0;
	ldx (I6)-1,I2	// 0 -> 0 -> ET47
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
// 	}
// else {
// 		lfnStartCluster = 0;
	ldc _lfnStartCluster,I0	// ET46
	j F18B6
	and A,NULL,A	// 0 -> 3 -> ET15
// jumped away

//_____________________________________________________________
//
	.sect code,FatExtendDirectory	// 95 words
	.export _FatExtendDirectory
_FatExtendDirectory:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+7,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; ldy (I4)+1,NULL
	mv I0,I2	// I0 -> 'dirfile'
	mv I2,I1	// 'dirfile' -> ET6
// newInChain
// oldFlags
	ldx (I0),A0 ; ldy (I1)+6,NULL	// 'dirfile' ==> 'oldFlags'
	stx A0,(I4)-1	// 'oldFlags' spills to #0
// fi
// di
	ldx (I1)+7,I0	// ET6 ==> 6 -> 'di'
// (fi->currentFragment.startSector < di->dataStart)
	ldx (I1)+2,NULL ; ldy (I0)+7,NULL	// ...
	ldx (I1)+1,B0 ; ldy (I0)+7,NULL
	ldx (I1)-1,B1 ; ldy (I0)+7,NULL
	mv I2,I1	// 'dirfile' -> 'fi'
	ldx (I0)+4,NULL ; ldy (I1)+7,NULL	// 'di' += 8
	ldx (I0)+1,A0 ; ldy (I1)+7,NULL
	ldx (I0)-1,A1 ; ldy (I1)+1,NULL
	sub B,A,A	// ETb >= ETe -> AT26
	ldc 2163,A0
	jcs F19B4	// unsigned compare
	nop
// jumped away
	ldc rootfull_4,A0	// ETf
	ldx (I6)+1,NULL	// I6 += 1
// 	}
// {
// 	  return SysError("Root full");
	call _SysError
	stx A0,(I6)	// ETf
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
F19B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 2163,A0	// 2163 -> 1 -> ET11
F19B4:
	ldy (I6)+1,NULL ; stx A0,(I2)	// I6 += 1
// 	dirfile->flags =(1 << 0) |(1 << 1) |(1 << 4) |(1 << 5) |(1 << 6) |(1 << 11);
// 	WriteClusterChain(dirfile, &fi->currentFragment,-1);
	mv I2,I0 ; or NULL,ONES,B0	// -1 -> 0 -> ET12
	stx B0,(I6)+1	// ET12
	call _WriteClusterChain
	stx I1,(I6)	// 'fi'
// jumped away
	mv I2,I0 ; and NULL,NULL,A0	// 0 -> 0 -> ET14
	ldx (I6)-1,NULL	// I6 += 1
// 	WriteClusterChain(dirfile, &fi->currentFragment,0);
	stx A0,(I6)+1	// ET14
	call _WriteClusterChain
	stx I1,(I6)	// 'fi'
// jumped away
	ldc 64,A1	// 64 -> 1 -> ET16
	ldx (I2),A0 ; ldy (I6)-2,NULL	// I6 += -2
// 	if (!(dirfile->flags &(1 << 6)))
	and A0,A1,A0	// ET1 and ET16 -> ET17
	ldc 4,A1	// 4 -> 0 -> ET23
	jzc F19B9	// compare against zero
	nop	// 0 -> 'i'
// jumped away
// 	}
// {
// 	  return -1;
	j F19B1
	add B0,NULL,A0	// ET12 returns via A0
// jumped away
F19B9:
// 	}
// origPos
	ldx (I2)+3,NULL ; and NULL,NULL,B0	// 'dirfile' += 3
	ldx (I2)+1,C0 ; and D,NULL,D
	ldx (I2)-4,C1
// (i=0; i<fi->currentFragment.sizeBytes; i+=4)
	j F19B13
	ldc 2,B1	// 2 -> 1 -> ET1d
// jumped away
F19B20:	// (loop lvl 2)
	ldy (I4)-1,D1 ; ldx (I6)+1,NULL	// I4 += 3
	ldx (I4),C0 ; ldy (I4)+3,C1	// unspill C0 from #0
// 	  }

	stx D0,(I4)+1 ; sub NULL,ONES,A0
	stx D1,(I4)-1
// (&t, sizeof(t), 1, dirfile);
	stx I2,(I6)+1	// 'dirfile'
	stx A0,(I6)+1	// ET20
	stx B1,(I6)+1	// ET1d
	call _vo_fwrite
	stx I4,(I6) ; ldy (I4)-5,NULL	// ET21
// jumped away
	ldx (I6)-4,NULL ; add B0,A1,B0	// I6 += -4
F19B13:	// (loop lvl 2)
	ldx (I4)+3,NULL ; ldy (I1)+2,NULL	// I4 += 3
	stx D0,(I4) ; sty D1,(I4)-1	// D0 spills to #0
	stx C0,(I4) ; sty C1,(I4)+1	// C0 spills to #0
	ldx (I1)+1,D0 ; sub NULL,ONES,A0	// 1 -> ET1b
	mulss B0,A0 ; ldx (I1)-3,D1	// 'i' sXtd ET1b -> P
	add NULL,P,C ; mv D1,D1	// P -> ET1c
// (C2 already up to date)
	sub C,D,C	// ET1c < ET1f -> AT2b
	nop
	jlt F19B20	// signed compare
	add C,D,C ; ldx (I4),D0	// restore value
// jumped away
	ldy (I4)-1,D1 ; ldx (I6)+1,NULL	// unspill D0 from #0
	ldx (I4),C0 ; ldy (I4)-2,C1	// unspill C0 from #0
//  vo_fflush(dirfile);
	call _vo_fflush
	stx I2,(I6)	// 'dirfile'
// jumped away
	mv I2,I0	// 'dirfile' -> ET19
	ldx (I0)+3,NULL ; ldy (I4)+1,NULL	// I4 += 1
// 	  dirfile->pos = origPos;
	stx C0,(I0)+1 ; ldy (I6)-1,NULL
	stx C1,(I0)-1
// 	dirfile->flags = oldFlags;
	ldx (I4)-1,A0	// unspill 'oldFlags' from #0
// 	return 0;
	j F19B1
	stx A0,(I2) ; and NULL,NULL,A0	// 'oldFlags' ==> 'dirfile'
// jumped away

//_____________________________________________________________
//
	.sect code,FatMakeEntry	// 192 words
	.export _FatMakeEntry
_FatMakeEntry:
	ldc 15,I7
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)*,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	mv I0,I1	// I0 -> 'dirfile'
	stx I2,(I6) ; sty I3,(I6)+1
	mv I1,I2	// 'dirfile' -> ET1
	stx LC,(I6) ; sty LS,(I6)+1
	stx LE,(I6)+1 ; ldy (I2)+6,NULL
// di
	ldx (I2)+2,I0 ; ldy (I4)+2,NULL	// ET1 ==> 6 -> ET2
	ldy (I0)+7,NULL ; ldx (I2)+2,C0	// ET2 += 17
	ldy (I0)+7,NULL ; ldx (I2)+1,A0	// ...
	ldy (I0)+3,NULL ; ldx (I2)+7,A1	// ...
	sty I0,(I4)-2 ; ldx (I2)+5,NULL
	mv I1,I0	// 'dirfile' -> ET12
// fi
// secbuf
// ->directoryEntrySector = (dirfile->currentSector);
	stx A0,(I2)+1 ; ldy (I0)+3,NULL
	ldc 32,A0	// 32 -> 3 -> A0
	stx A1,(I2)+1
// 	fi->directoryEntryNumber = (u_int16)((dirfile->pos - 32) & 511) / 32;
	ldx (I0)+5,B0
	sub B0,A0,B0	// ET13 - ET14 -> ET15
	ldc 511,A0	// 511 -> 3 -> A0
	and B0,A0,B0	// ET15 and ET16 -> ET17
	ldc -5,A0	// -5 -> AT1a
	ashl B0,A0,A0	// ET18 << AT1a -> ET1b
	ldc 4,B0	// 4 -> 0 -> ET1f
	stx A0,(I2)	// ET1b ==> ET1
// 	entry = (void*)&dirfile->sectorBuffer[fi->directoryEntryNumber*16];
	ldx (I0)-5,A0	// ET12 ==> 8 -> ETc
	ldx (I2),A1	// ET1 ==> 10 -> ET1d
	ashl A1,B0,A1 ; mv I1,I2	// ET1d << ET1f -> ET20
	add A0,A1,B1 ; ldx (I2)+7,NULL	// ETc + ET20 -> 'entry'
// 	dirfile->pos = 0;
	ldx (I2)+7,NULL ; and A,NULL,A	// 0 -> 3 -> ET22
	stx A0,(I0)+1 ; ldy (I2)+1,NULL
	mv I2,I3	// 'fi' -> ET10
	stx A1,(I0)+7 ; ldy (I3)+7,NULL
// 	dirfile->fileSize = 0;
	ldx (I0)+1,NULL ; ldy (I3)+1,NULL	// ...
	stx A0,(I0)+1
	stx A1,(I0)+4
// 	fi->currentFragment.sizeBytes = 0;
	stx A0,(I0)+1
	stx A1,(I0)-1 ; and A1,NULL,A1
// 	fi->startCluster = VoFatGetFreeFragment(dirfile, vo_fat_allocationSizeClusters);
	ldc _vo_fat_allocationSizeClusters,I0	// ET28
	ldx (I0),A0/*V*/	// ET28 ==> 'vo_fat_allocationSizeClusters'
	mv I1,I0
	stx A0,(I6)+1	// A0
	call _VoFatGetFreeFragment
	stx A1,(I6)	// A1
// jumped away
	mv I1,I0	// 'dirfile' -> I0
	ldy (I2)+6,NULL ; ldx (I6)-1,NULL	// I6 += 1
	stx A0,(I2)+1
	stx A1,(I2)-7
// 	FatImageSectorRead(dirfile, fi->directoryEntrySector);
	ldx (I3)+1,A0
	ldx (I3)-1,A1
	stx A0,(I6)+1	// A0
	call _FatImageSectorRead
	stx A1,(I6)	// A1
// jumped away
	ldc 16,A0	// 16 -> A0
	mv B1,I0 ; and NULL,NULL,A1	// 'entry' -> I0
// 	memset(entry, 0, 16);
	call _memset
	ldx (I6)-2,NULL	// I6 += -2
// jumped away
	ldc 13,A0	// 13 -> A0
	ldc 32,A1	// 32 -> A1
	ldx (I4)+2,NULL	// I4 += 2
	mv I4,I0	// I4 -> [] -> I0
// 	memset(name83,' ', sizeof(name83));
	call _memset
	ldx (I4)-2,NULL	// I4 += -2
// jumped away
	ldx (I4)+7,NULL ; and NULL,NULL,A0	// I4 += 14
	ldx (I4)+7,NULL ; and NULL,NULL,A1	// ...
// 	name83[sizeof(name83)-1]=0;
	stx A0,(I4)-7
	ldx (I4)-7,NULL	// ...
// 	i=0;
// j=0;
// 	while (j<11 && *name && i<12)
	ldx (I4)-2,NULL	// 0 -> 'i'
	j F20B10
	ldx (I4)+2,I3	// unspill AT8e from #-2
// jumped away
F20B12:	// (loop lvl 2)
	sub B0,NULL,B0	// ET38 == (0) -> (0)
	ldc 12,B0	// 12 -> 1 -> ET23
	jzs F20B8	// signed compare
	sub A1,B0,B0	// 'i' >= ET23 -> AT7e
// jumped away
	ldc 46,C1	// 46 -> 0 -> ET39
	jcs F20B8	// unsigned compare
	ldx (I3),B0	// AT8e ==> ET38
// jumped away
// 	}
// {
// 		if (*name == '.')
	sub B0,C1,B0	// ET38 == ET39 -> AT7c
	ldx (I3),B0	// AT8e ==> ET38
	jzs F20B13	// signed compare
	nop
// jumped away
// 		}
// else {
// 			name83[j] = toupper(*name);
	ldx (I4)+2,NULL	// I4 += 2
	call _toupper
	mv B0,I0	// ET38 -> I0
// jumped away
	mv I0,C1 ; mv I4,B0	// I0 -> ET3b
	add B0,A0,B0 ; ldy (I4)-2,NULL	// I4 += -2
	mv B0,I0	// AT89 -> ET3c
	stx C1,(I0)	// ET3b ==> ET3c
F20B15:	// (loop lvl 2)
// 		name++;
// 		i++;
	sub A1,ONES,A1 ; ldx (I3)+1,NULL	// 'i' - (-1) -> 'i'
	sub A0,ONES,A0	// 'j' - (-1) -> 'j'
// 		j++;
F20B10:	// (loop lvl 2)
	ldc 11,B0	// 11 -> 1 -> ET37
	sub A0,B0,B0	// 'j' < ET37 -> AT7d
	ldx (I3),B0	// AT8e ==> ET38
	jcc F20B12	// unsigned compare
	nop
// jumped away
F20B8:
// 	for (i=0; i<6; i++)
	ldc 5,LC	// loop 6 iterations
	ldc 8,B0	// 8 -> 0 -> ET48
	ldx (I4)+2,NULL ; and NULL,NULL,A0	// 0 -> 'i'
	mv I4,A1	// I4 -> [] -> ET32
	loop LC,F20B18-1
	ldx (I4)-2,NULL	// I4 += -2
//loop resumes
// 	}
// {
// 		entry->filename[i] = (name83[i*2]<<8) + (name83[i*2+1]);
	add A0,A0,C1	// 'i' + 'i' -> ET45
	add A1,C1,D0	// ET32 + ET45 -> AT8c
	mv D0,I0 ; sub C1,ONES,C1	// AT8c -> ET46
	ldx (I0),D0 ; add A1,C1,C1	// ET46 ==> ET47
	ashl D0,B0,D0 ; mv C1,I0	// ET47 << ET48 -> ET49
	ldx (I0),C1	// ET4b ==> ET4c
	add D0,C1,D0	// ET49 + ET4c -> ET4d
	add B1,A0,C1	// 'entry' + 'i' -> AT8a
	mv C1,I0 ; sub A0,ONES,A0	// AT8a -> ET4f
	stx D0,(I0)	// ET4d ==> ET4f
//	(0 nop's needed)
// loop end
F20B18:	// loop exit
	ldc 8,A0	// 8 -> 0 -> ET48
	ldc -8,A1	// -8 -> 0 -> ET52
	ldx (I4)+1,NULL ; ldy (I6)+1,NULL	// I4 += 1
	sty C0,(I4) ; stx I1,(I4)+1	// AT91 spills to #1
	mv I2,I1 ; and C1,NULL,C1	// 'fi' -> ET2b
// 	}
// startCluster
	ldx (I1)+6,NULL ; ldy (I4)-1,I3	// ET2b += 6
	ldx (I1)+1,D0 ; ldy (I3)+4,NULL
	ldx (I1)-1,D1 ; ashl D0,A0,B0
// ->firstClusLo =(((u_int16)((u_int16)startCluster)>>8)|(((u_int16)startCluster)<<8));
	mv A0,I7 ; add D0,NULL,C0	// ET51 msw AT80
	ashl C,A1,C	// AT80 <- ET52 -> AT81
	or C0,B0,C1 ; ldy (I4),C0	// ET53 or ET54 -> ET55
	ldc 13,B0	// 13 -> 1 -> ET30
	add B1,B0,B0	// 'entry' + ET30 -> AT8d
	mv B0,I0 ; add D1,NULL,B0	// AT8d -> ET56
	stx C1,(I0)-3 ; add D1,NULL,D0	// ET55 ==> ET56
	ldc 0,D1
// 		entry->firstClusHi =(((u_int16)((u_int16)(startCluster >> 16))>>8)|(((u_int16)(startCluster >> 16))<<8));
	ashl D,A1,D	// AT82 <- ET52 -> AT83
	ashl B0,A0,B0	// ET5b << ET48 -> ET5d
	or D0,B0,B0	// ET5c or ET5d -> ET5e
	stx B0,(I0)+4	// ET5e ==> ET56
// 	fi->currentFragment.startSector = fi->startCluster * di->fatSectorsPerCluster + di->dataStart;
	ldx (I1)+1,D0
	ldx (I1)-5,D1
	ldx (I3)+4,B0/*V*/	// ET61 ==> 4 -> ET62
	muluu B0,D1 ; mv D0,A0	// ET50 * ET62 -> ET64
	add NULL,P,D	// (32x16)
	muluu B0,A0 ; mv I7,A0
	add D0,P,D ; ldx (I3)+1,B0/*V*/
	ldx (I3)-1,B1/*V*/
	add D,B,B	// ET64 + ET66 -> ET67
	stx B0,(I2)+1 ; and D1,NULL,D1
	stx B1,(I2)-1
// 	entry->fileSizeLo =(((u_int16)((u_int16)(fi->currentFragment.sizeBytes))>>8)|(((u_int16)(fi->currentFragment.sizeBytes))<<8));
	ldx (I1)+1,B0
	ashl B0,A0,B0 ; mv B0,D0	// ET69 << ET48 -> ET6b
	ashl D,A1,D	// AT84 <- ET52 -> AT85
	or D0,B0,B0	// ET6a or ET6b -> ET6c
	stx B0,(I0)+1 ; and D1,NULL,D1	// ET6c ==> ET56
// 	entry->fileSizeHi =(((u_int16)((u_int16)(fi->currentFragment.sizeBytes >> 16))>>8)|(((u_int16)(fi->currentFragment.sizeBytes >> 16))<<8));
	ldx (I1)+5,B1
	mv B1,B1	// update guard bits
	add B1,NULL,D0 ; mv B1,B1	// ET68 >>> ET6f
	// update guard bits
	mv B1,B0 ; ashl D,A1,D	// ET68 >>> ET72
	ashl B1,A0,A0	// ET73 << ET48 -> ET74
	or D0,A0,A0	// ET71 or ET74 -> ET75
	stx A0,(I0) ; sub NULL,ONES,A0	// ET75 ==> ET56
// 	dirfile->dev->BlockWrite(dirfile->dev, fi->directoryEntrySector, 1, secbuf);
	stx C0,(I6)+1	// 'secbuf'
	stx A0,(I6)+1	// ET41
	ldx (I1)+1,A0
	ldx (I1)-1,A1
	stx A0,(I6)+1	// A0
	stx A1,(I6)	// A1
	ldx (I4)-1,I1	// unspill AT8f from #1
	ldx (I1)+6,NULL	// 'dirfile' += 6
	ldx (I1)-6,I2	// 'dirfile' ==> 6 -> ET77
	mv I2,I0	// ET77 -> I0
	ldx (I2)+7,NULL	// ET77 += 8
	ldx (I2)+1,NULL	// ...
	ldx (I2),A0	// ET77 ==> ET78
	mv A0,LR0
	jr
	ldc lo(F20B21),LR0	// (return address)
// jumped away
F20B21:
	ldc 83,A0	// 83 -> 1 -> ET7a
	ldy (I6)-4,NULL ; stx A0,(I1)	// I6 += -4
// 	dirfile->flags =(1 << 0) |(1 << 1) |(1 << 4) |(1 << 6);
// 	return 0;
	ldx (I6)-1,LE ; and NULL,NULL,A0	// 0 -> 0 -> ET2e
	ldy (I6),LS ; ldx (I6)-1,LC
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F20B13:	// (loop lvl 2)
// 		}
// {
// 			j=7;
	j F20B15
	ldc 7,A0	// 7 -> 'j'
// jumped away

//_____________________________________________________________
//
	.sect code,FileNameCompare	// 77 words
	.export _FileNameCompare
_FileNameCompare:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	mv I2,B0 ; sub C0,NULL,A1	// I2 -> 'filespec'
	stx B1,(I6) ; sty I0,(I6)+1
	stx I3,(I6)
	mv I1,I3	// I1 -> 'candidate'
// (n<=0)
	jle F21B3	// signed compare
	mv B0,I0	// 'filespec' -> I0
// jumped away
// 	w=strchr(filespec,'*');
	call _strchr
	ldc 42,A0	// 42 -> A0
// jumped away
// 	if (w >= filespec+n)
	add B0,A1,A0 ; mv I0,B1	// 'filespec' + 'n' -> ET4
	sub B1,A0,A0	// 'w' < ET4 -> AT17
	nop
	jlt F21B7	// signed compare
	nop
// jumped away
// 	}
// {
// 		w = 0;
	ldc 0,B1	// 0 -> 'w'
F21B7:
// 	if (!w)
	sub B1,NULL,B1	// 'w' == (0) -> (0)
	nop
	jzs F21B8	// signed compare
	nop
// jumped away
	mv I3,I2 ; sub B1,B0,C0	// 'w' - 'filespec' -> ET9
	mv B0,I1	// 'filespec' -> I1
// 	if (strncasecmp(candidate, filespec, w-filespec))
	call _strncasecmp
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
	sub A0,NULL,A0	// ETa != (0) -> (0)
	nop
	jzc F21B14	// signed compare
	sub B1,ONES,B1	// 'w' - (-1) -> 'w'
// jumped away
// 	w++;
// 	n -= w-filespec;
	sub B1,B0,A0	// 'w' - 'filespec' -> ETe
	sub A1,A0,C0	// 'n' - ETe -> 'n'
// 	if (n <= 0)
	sub C0,NULL,C0	// 'n' <= (0) -> (0)
	nop
	jle F21B17	// signed compare
	nop
// jumped away
// 	cLen = strlen(candidate);
	call _strlen
	mv I3,I0	// 'candidate' -> I0
// jumped away
// 	if (cLen < n)
	sub A0,C0,A1	// 'cLen' < 'n' -> AT20
	nop
	jlt F21B20	// signed compare
	sub A0,C0,A1 ; mv I3,A0	// 'cLen' - 'n' -> ET12
// jumped away
// 	candidate += cLen-n;
	add A0,A1,A0 ; mv B1,I1	// AT23 + ET12 -> ET13
	mv A0,I0	// ET13 -> 'candidate'
	mv I0,I2	// 'candidate' -> I2
// 	return strncasecmp(candidate,w,n);
	call _strncasecmp
	ldx (I6)+1,NULL	// I6 += 1
// jumped away
F21B1:
	ldx (I6)-1,I3
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F21B20:
// 	}
// {
// 		return -1;
	j F21B1
	or NULL,ONES,A0	// -1 -> 0 -> ET1
// jumped away
F21B17:
// 	}
// {
// 		return 0;
	j F21B1
	and NULL,NULL,A0	// 0 -> 0 -> ET0
// jumped away
F21B14:
// 	}
// {
// 		return -1;
	j F21B1
	or NULL,ONES,A0	// -1 -> 0 -> ET1
// jumped away
F21B8:
// 	}
// {
// 		if (strlen(candidate)>n)
	call _strlen
	mv I3,I0	// 'candidate' -> I0
// jumped away
	sub A1,A0,B1	// 'n' > ET6 -> AT1a
	nop
	jcc F21B10	// unsigned compare
	nop
// jumped away
	mv B0,I1 ; add A1,NULL,C0	// 'filespec' -> I1
	mv I3,I2	// 'candidate' -> I2
// 		return strncasecmp(candidate, filespec, n);
	ldx (I6)+1,NULL	// 'n' -> C0
	call _strncasecmp
	ldc F21B1,LR0
// jumped away
F21B10:
// 		}
// {
// 			return -1;
	j F21B1
	or NULL,ONES,A0	// -1 -> 0 -> ET1
// jumped away
F21B3:
// return -1;
	j F21B1
	or NULL,ONES,A0	// -1 -> 0 -> ET1
// jumped away

//_____________________________________________________________
//
	.sect code,FatFindFile	// 733 words
	.export _FatFindFile
_FatFindFile:
	ldc 37,I7
	ldc 150,A0	// 150 -> A0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)*,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I3 ; and NULL,NULL,A1	// I0 -> 'f'
	ldc _longFileName,I0	// I0
	mv I3,I1 ; and NULL,NULL,B0	// 0 -> A1
	mv I3,I2 ; and NULL,NULL,D1	// 'f' -> ET1
	ldy (I2)+6,NULL ; ldx (I4)+1,NULL	// I4 += 1
// di
	ldx (I2),I2 ; ldy (I1)+7,NULL	// ET1 ==> 6 -> 'di'
// fi
// searchingForDirectory
// longNameStartPos
// lfnReset
// unlinkEntry
// writeEntry
// skipEntries
// (longFileName,0,sizeof(longFileName));
	ldy (I2)+7,NULL ; ldx (I1)+7,NULL	// 0 -> AT137
	stx B0,(I4)+1 ; ldy (I1)+1,NULL	// AT137 spills to #0
	stx B0,(I4) ; sty B0,(I4)+2	// 'writeEntry' spills to #0
	ldx (I2)+7,NULL ; or NULL,ONES,B0	// 0 -> 'unlinkEntry'
	or NULL,ONES,B1 ; stx B0,(I4)	// -1 -> B0
	sty B1,(I4)-1 ; ldx (I2)+3,NULL	// B1 spills to #0
	call _memset
	stx I1,(I4) ; sty I2,(I4)-3	// 'fi' spills to #0
// jumped away
// 	lfnStartCluster = 0;
	ldc _lfnStartCluster,I0	// ET10
	and A,NULL,A ; ldy (I3)+2,NULL	// 0 -> 3 -> ETf
	stx A0,(I0)+1/*V*/ ; ldy (I4)-5,NULL
	stx A1,(I0)-1/*V*/
// 	if (f->op != &FatFileOps)
	ldc _FatFileOps,A1	// ET14
	ldx (I3)-2,A0	// 'f' ==> 2 -> ET13
	sub A0,A1,A1	// ET13 != ET14 -> ATc7
	ldc 119,A1	// 119 -> 0 -> ET17
	jzc F22B4	// signed compare
	nop	// I4 += -5
// jumped away
// 	if (mode[0] == 'w')
	ldx (I4),I0	// unspill 'mode' from #0
	ldx (I0),A0	// 'mode' ==> ET16
	sub A0,A1,A1	// ET16 != ET17 -> ATc9
	ldc 85,A1
	jzc F22B7	// signed compare
	nop	// 85 -> 0 -> ET19
// jumped away
	ldx (I4)+7,NULL ; sub NULL,ONES,A0
// 	}
// {
// 	  unlinkEntry = 1;
// 	  writeEntry = 1;
	stx A0,(I4)-7 ; sub NULL,ONES,D1	// 'writeEntry' spills to #0
// 	if (mode[0] == 'U')
	ldx (I4),I0	// unspill 'mode' from #0
	ldx (I0),A0	// 'mode' ==> ET16
F22B7:
	sub A0,A1,A1 ; ldx (I4),I0	// ET16 != ET19 -> ATca
	ldc 78,A1
	jzc F22B9	// signed compare
	ldx (I0),A0	// 78 -> 0 -> ET1a
// jumped away
// 	}
// {
// 	  unlinkEntry = 1;
	sub NULL,ONES,D1 ; ldx (I4),I0	// 1 -> 'unlinkEntry'
// 	if (mode[0] == 'N')
	ldx (I0),A0	// 'mode' ==> ET16
F22B9:
	sub A0,A1,A1 ; ldx (I4),I0	// ET16 == ET1a -> ATcb
	ldc 35,A0	// 35 -> 0 -> ET1e
	jzs F22B10	// signed compare
	ldx (I0)+2,NULL	// 'mode' += 2
// jumped away
// 	if(mode[2]=='#')
	ldx (I0)-2,A1	// 'mode' ==> 2 -> ET1d
	stx I0,(I4)+5 ; sub A1,A0,A1	// 'mode' spills to #0
	nop
	jzc F22B21	// signed compare
	nop
// jumped away
	ldx (I4)-5,NULL ; ldy (I6)+1,NULL	// I4 += -5
// 	}
// {
// 		skipEntries = atoi(&mode[3]);
	ldx (I4),I0	// unspill 'mode' from #0
	ldx (I0)+3,NULL	// 'mode' += 3
	stx I0,(I6) ; ldy (I0)-3,NULL	// 'mode'
	call _atoi
	stx I0,(I4)+5	// 'mode' spills to #0
// jumped away
	ldx (I4)+1,NULL ; ldy (I6)-1,NULL	// I4 += 1
	j F22B21
	stx A0,(I4)-1	// A0 spills to #0
// jumped away
F22B41:
// 		if (unlinkEntry && writeEntry)
	sub D1,NULL,D1	// 'unlinkEntry' == (0) -> (0)
	nop
	jzs F22B147	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL	// I4 += 2
	ldx (I4)-2,A0	// unspill 'writeEntry' from #0
	sub A0,NULL,A0	// 'writeEntry' == (0) -> (0)
	ldc 0,D1	// 0 -> 'unlinkEntry'
	jzs F22B147	// unsigned compare
	nop
// jumped away
// 		}
// {
// 		  unlinkEntry = 0;
// 		  goto tryAgain;
F22B21:
// 		searchingForDirectory = 0;
// 		for (i=0; name[i]; i++)
	ldc 0,A1	// 0 -> 'i'
	j F22B25
	and NULL,NULL,D0	// 0 -> 'searchingForDirectory'
// jumped away
F22B22:	// (loop lvl 2)
	ldc 47,B0	// 47 -> 0 -> ET26
	ldx (I4)-4,NULL	// I4 += -4
// 		}
// {
// 			if (name[i]=='/' || name[i]=='\\')
	ldx (I4)+4,A0	// unspill AT12f from #0
	add A0,A1,A0	// AT12f + 'i' -> AT117
	mv A0,I0	// AT117 -> ET24
	ldx (I0),A0	// ET24 ==> ET25
	sub A0,B0,B0	// ET25 == ET26 -> ATce
	nop
	jzs F22B26	// signed compare
	nop
// jumped away
	ldc 92,B0	// 92 -> 0 -> ET27
	sub A0,B0,A0	// ET25 == ET27 -> ATd1
	nop
	jzs F22B26	// signed compare
	nop
// jumped away
	sub A1,ONES,A1	// 'i' - (-1) -> 'i'
F22B25:	// (loop lvl 2)
	ldx (I4)-4,NULL	// I4 += -4
	ldx (I4)+4,A0	// unspill AT12f from #0
	add A0,A1,A0	// AT12f + 'i' -> AT118
	mv A0,I0	// AT118 -> ET24
	ldx (I0),A0	// ET24 ==> ET25
	sub A0,NULL,A0	// ET25 != (0) -> (0)
	nop
	jzc F22B22	// signed compare
	nop
// jumped away
	j F22B23
	nop
// jumped away
F22B26:
// 			}





	mv A1,A0
	mv A0,D0	// A0 -> 'searchingForDirectory'



// {
// 				__asm {
// 				  get (searchingForDirectory),a0
// 				  get (i),a1
// 				  mv a1,a0
// 				  set a0,(searchingForDirectory)
// 				}
// 				break;
F22B23:
	ldx (I4)-3,NULL	// I4 += -3
// 		if ((dirStartCluster == 0) && (di->fatBits != 32))
	ldx (I4)+1,A0	// unspill A0 from #0
	ldx (I4)+2,A1	// unspill A1 from #0
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A	// AT133 != (0) -> (0)
	ldc 32,A0	// 32 -> 1 -> ET2d
	jzc F22B34	// unsigned compare
	nop
// jumped away
	ldx (I4)+3,NULL	// I4 += 3
	ldy (I4),I0	// unspill 'di' from #0
	ldx (I0)+5,NULL	// 'di' += 5
	ldx (I0)-5,A1	// 'di' ==> 5 -> ET2c
	sty I0,(I4)-3 ; sub A1,A0,A1	// 'di' spills to #0
	nop
	jzs F22B34	// unsigned compare
	nop
// jumped away
	ldx (I4)+3,NULL ; ldy (I3)+7,NULL	// I4 += 3
// 		}
// {
// 			fi->currentFragment.startSector = di->rootStart;
	ldy (I4),I2 ; ldx (I3)+5,NULL	// unspill 'di' from #0
	mv I2,I0	// 'di' -> ET2f
	ldx (I0)+7,NULL	// ET2f += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldx (I4),I0	// unspill 'fi' from #0
	stx A0,(I0)+1
	ldc 32,A0	// 32 lsw ET34
	stx A1,(I0)+1
// 			f->fileSize = fi->currentFragment.sizeBytes = (u_int32)di->rootEntCnt*32;
	ldx (I2),A1	// 'di' ==> ET31
	muluu A1,A0	// ET31 * ET34 -> ET35
	add NULL,P,A	// 16x16->32bit
	stx A0,(I0)+1
	stx A1,(I0)+1
	stx A0,(I3)+1
	stx A1,(I3)-7 ; and A,NULL,A
// 			f->pos = 0;
	ldx (I3)-3,NULL	// 'f' += -9
	stx A0,(I3)+1
	stx A1,(I3)-4
// 			fi->currentFragment.startByteOffset = 0;
	stx A0,(I0)+1
	stx A1,(I0)-5
	j F22B43
	stx I0,(I4)-3	// 'fi' spills to #0
// jumped away
F22B134:
// 				if ( fn & 0x40 )
	ldc 64,A0	// 64 -> 1 -> ETc3
	and B0,A0,A0 ; ldx (I4)+2,NULL	// 'fn' and ETc3 -> ETc4
	ldc 0,A0
	jzs F22B141	// compare against zero
	nop
// jumped away
	ldc 150,A0	// 150 -> 1 -> ETb
	ldx (I4)-2,NULL ; sub A1,A0,A0
// 				}
// {
// 					if (idx >= 150)
	ldc _longFileName,A0
	jcc F22B143	// unsigned compare
	nop	// ETd
// jumped away
// 					idx = 150 -1;
	ldc 149,A1	// 149 -> 'idx'
// 					longFileName[idx] = '\0';
F22B143:
	add A0,A1,A0 ; ldx (I4)+2,NULL	// ETd + 'idx' -> AT11a
	mv A0,I0 ; and NULL,NULL,A0	// AT11a -> ETc5
	stx A0,(I0) ; and NULL,NULL,A0	// ETc ==> ETc5
F22B141:
// 				lfnReset = 0;
// 				  if (longNameStartPos < 0)
	sty A0,(I4)+2	// 'lfnReset' spills to #0
	ldx (I4),A0 ; ldy (I4)-4,A1	// unspill A0 from #0
	mv A1,A1	// update guard bits (cmp)
	sub A,NULL,A	// 'longNameStartPos' >= (0) -> (0)
	nop
	jge F22B43	// signed compare
	nop
// jumped away
	ldc 32,B0	// 32 -> 3 -> B0
	ldy (I3)+3,NULL ; ldx (I4)+4,NULL	// I4 += 4
// 				  }
// {
// 				    longNameStartPos = f->pos-32;
	ldx (I3)+1,A0 ; and NULL,NULL,B1
	ldx (I3)-4,A1
	sub A,B,A	// ET47 - ET33 -> 'longNameStartPos'
	stx A0,(I4) ; sty A1,(I4)-4	// A0 spills to #0
F22B43:
// 		}
// {
// 			if((f)->flags &(1 << 2))
	ldc 4,A1	// 4 -> 1 -> ET3d
	ldx (I3),A0 ; ldy (I6)+1,NULL	// 'f' ==> ET43
	and A0,A1,A0	// ET43 and ET3d -> ET44
	ldc endofdir_5,A0	// ET45
	jzc F22B44	// compare against zero
	nop	// I6 += 1
// jumped away
	ldx (I6)-1,NULL
F22B12:
	mv I3,I0	// 'f' -> ET3c
// 			if (f->pos >= f->fileSize && !unlinkEntry && writeEntry)
	ldx (I0)+3,NULL	// ET3c += 3
	ldx (I0)+1,B0
	ldx (I0)+7,B1
	ldc 0,B2	// update guard bits (cmp)
	ldx (I0)+1,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	ldc 0,A2	// update guard bits (cmp)
	sub B,A,C	// ET47 < ET48 -> ATcd
	nop
	jcc F22B48	// unsigned compare
	nop
// jumped away
	sub D1,NULL,D1	// 'unlinkEntry' != (0) -> (0)
	nop
	jzc F22B48	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL	// I4 += 2
	ldx (I4)-2,A0	// unspill 'writeEntry' from #0
	sub A0,NULL,A0	// 'writeEntry' == (0) -> (0)
	nop
	jzs F22B48	// unsigned compare
	nop
// jumped away
// 			}
// {
// 			  if (FatExtendDirectory(f))
	call _FatExtendDirectory
	mv I3,I0	// 'f' -> I0
// jumped away
	sub A0,NULL,A0 ; ldx (I6)+1,NULL	// ET49 != (0) -> (0)
	ldc diskfull_6,A0	// ET4a
	jzc F22B51	// signed compare
	nop	// I6 += 1
// jumped away
	ldx (I6)-1,NULL
F22B48:
	mv I3,I0	// 0 -> 1 -> ET9
	ldc 32,A0	// 32 -> 1 -> ET2d
	ldy (I6)+1,NULL ; ldx (I4)+7,NULL	// I4 += 7
// 			if (!f->op->Read(f, &de, 0, 32))
	stx A0,(I6)+1 ; and NULL,NULL,A0	// ET2d
	stx A0,(I6)+1 ; ldy (I3)+2,NULL	// ET9
	stx I4,(I6) ; ldy (I4)-7,NULL	// ET4c
	ldx (I3)-2,I2	// 'f' ==> 2 -> ET4d
	ldx (I2)+3,NULL	// ET4d += 3
	ldx (I2),A0	// ET4d ==> ET4e
	mv A0,LR0
	jr
	ldc lo(F22B57),LR0	// (return address)
// jumped away
F22B57:
	sub A0,NULL,A0 ; ldy (I6)-3,NULL	// I6 += -3
	ldc 4,A1	// 4 -> 1 -> ET3d
	jzs F22B55	// unsigned compare
	ldx (I4)+7,NULL	// I4 += 7
// jumped away
	mv I4,A0	// I4 -> [] -> A0


	ldx (I4)-7,NULL	// I4 += -7

	add A0,NULL,A1
	add A,NULL,B
	add A,NULL,C

// 			__asm {
// 			  get (&de),a0
// 			    add a0,null,a1
// 			    add a,null,b
// 			    add a,null,c
// 			}
// 			if (!searchingForDirectory && writeEntry &&
// 			    !unlinkEntry &&
// 			    (((de.filename[0] & 0xff00) == 0x0000) ||
// 			     ((de.filename[0] & 0xff00) == 0xe500)))
	sub D0,NULL,D0	// 'searchingForDirectory' != (0) -> (0)
	nop
	jzc F22B67	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL	// I4 += 2
	ldx (I4)-2,A0	// unspill 'writeEntry' from #0
	sub A0,NULL,A0	// 'writeEntry' != (0) -> (0)
	nop
	jzc F22B69	// unsigned compare
	nop
// jumped away
F22B67:
	ldc 65280,A1	// 65280 -> 1 -> ET54
	ldx (I4)+7,NULL	// I4 += 7
// 			if (!(de.filename[0] & 0xff00))
	ldx (I4)-7,A0	// I4 ==> ET53
	and A0,A1,A0	// ET53 and ET54 -> ET55
	ldc -8,A0	// -8 -> 0 -> ET59
	jzs F22B41	// compare against zero
	nop
// jumped away
	ldx (I4)+7,NULL ; and B1,NULL,B1	// I4 += 7
// 			if ((de.filename[0]>>8) == 0xe5)
	ldx (I4)-3,B0	// I4 ==> ET53
	ashl B,A0,B	// ATe8 <- ET59 -> ATe9
	ldc 229,A0	// 229 -> 1 -> ET5b
	sub B0,A0,A1	// ET5a == ET5b -> ATea
	ldc -1,A0
	jzs F22B75	// unsigned compare
	nop	// I4 += 4
// jumped away
	ldc 15,A0	// 15 -> 1 -> ET6
	ldx (I4)+7,NULL
	ldx (I4)+1,NULL	// ...
// 			}
// else {
// 				if ((de.attr & 0x0F) != 0x0F)
	ldx (I4)-7,A1	// I4 ==> 5 -> ET5d
	and A1,A0,A1 ; ldx (I4)-3,NULL	// ...
	sub A1,A0,A1 ; ldy (I4),A0	// ET5e == ET6 -> ATeb
	ldc 2,A1	// 2 -> 1 -> ET11
	jzs F22B79	// unsigned compare
	sub A0,ONES,A0	// 'lfnReset' - (-1) -> 'lfnReset'
// jumped away
// 				}
// {
// 					if (++lfnReset == 2)
	sty A0,(I4)-2 ; sub A0,A1,A1	// 'lfnReset' spills to #0
	ldc 23,I5
	jzc F22B82	// unsigned compare
	ldc _longFileName,I0	// ETd
// jumped away
	ldx (I4)+2,NULL ; and NULL,NULL,A0	// I4 += 2
// 					}
// {
// 						longFileName[0] = 0;
	stx A0,(I0) ; sub NULL,ONES,A0	// ETc ==> ETd
// 						lfnReset = 1;
	sty A0,(I4)-2	// 'lfnReset' spills to #0
F22B82:
	ldc _longFileName,I0	// ETd
	ldx (I4)*,NULL ; ldy (I6)+1,NULL	// I4 += 23
	ldc -16,I5
// 					FatNameFromDirEntry((u_int16*)&de, tempName);
	stx I4,(I6)+1 ; ldy (I4)*,NULL	// ET60
	call _FatNameFromDirEntry
	stx I4,(I6) ; ldy (I4)-7,NULL	// ET4c
// jumped away
	ldx (I0),A0 ; ldy (I6)-2,NULL	// I6 += -2
// 					if (longFileName[0]==0)
	sub A0,NULL,A0	// ET62 != (0) -> (0)
	nop	// I0
	jzc F22B85	// signed compare
	nop
// jumped away
	ldc 23,I5
	ldx (I4)*,NULL	// I4 += 23
	mv I4,I1	// I4 -> [] -> I1
	ldc -23,I5
// 					}
// {
// 						strcpy(longFileName,tempName);
	call _strcpy
	ldx (I4)*,NULL	// I4 += -23
// jumped away
F22B85:
// 					if (searchingForDirectory)
	sub D0,NULL,D0 ; ldx (I4)-4,NULL	// 'searchingForDirectory' != (0) -> (0)
	ldx (I4)+4,A0	// unspill AT12f from #0
	jzc F22B87	// unsigned compare
	nop	// I4 += -4
// jumped away
// 					}
// namelen
	call _strlen
	mv A0,I0	// AT12f -> I0
// jumped away
	ldc 115,B0	// 115 -> 0 -> ET7a
	ldx (I4)-5,NULL ; add A0,NULL,A1	// I4 += -5
	ldx (I4)+5,I0	// A0 -> 'namelen'
// (mode[0]=='s' || mode[0]=='N')
	ldx (I0),A0	// 'mode' ==> ET16
	sub A0,B0,B0	// ET16 == ET7a -> ATf5
	nop
	jzs F22B96	// signed compare
	nop
// jumped away
	ldc 78,B0	// 78 -> 0 -> ET1a
	sub A0,B0,A0	// ET16 == ET1a -> ATf7
	ldc _longFileName,I1	// I1
	jzs F22B96	// signed compare
	nop
// jumped away
	ldx (I4)-4,NULL ; add A1,NULL,C0	// I4 += -4
// 						if (((!FileNameCompare(name,longFileName,namelen))
// 							|| (!FileNameCompare(name,tempName,namelen)))
// 							&& ((de.attr & 0x08) == 0) && (skipEntries-- == 0))
	ldx (I4)+4,A0	// unspill AT12f from #0
	call _FileNameCompare
	mv A0,I2	// AT12f -> I2
// jumped away
	sub A0,NULL,A0 ; ldx (I4)+7,NULL	// ET95 == (0) -> (0)
	ldc 8,A0
	jzs F22B106	// signed compare
	ldx (I4)+5,NULL
// jumped away
	ldc 27,I5
	ldx (I4)-7,NULL ; add A1,NULL,C0
	ldx (I4)-7,NULL
	ldx (I4)-2,NULL	// I4 += -4
	ldx (I4)*,A0	// unspill AT12f from #0
	mv I4,I1	// I4 -> [] -> I1
	mv A0,I2	// AT12f -> I2
	ldc -23,I5
	call _FileNameCompare
	ldx (I4)*,NULL	// I4 += -23
// jumped away
	sub A0,NULL,A0	// ET96 != (0) -> (0)
	ldc 8,A0	// 8 -> 1 -> ET97
	jzc F22B89	// signed compare
	nop
// jumped away
	ldx (I4)+7,NULL	// I4 += 12
	ldx (I4)+5,NULL	// ...
F22B106:
	ldx (I4)-7,A1	// I4 ==> 5 -> ET5d
	ldx (I4)-5,NULL ; and A1,A0,A0	// ...
	nop
	jzc F22B89	// compare against zero
	nop
// jumped away
	ldx (I4)+1,NULL	// I4 += 1
	ldx (I4),A0	// unspill AT137 from #0
	add A0,ONES,A1	// AT137 + (-1) -> AT120
	stx A1,(I4) ; sub A0,NULL,A0	// AT120 spills to #0
	nop	// I4 += 1
	jzc F22B188	// unsigned compare
	nop
// jumped away
	ldx (I4)+1,NULL ; sub D1,NULL,D1
// 						}
// {
// 						  if (unlinkEntry)
	ldc -8,B1
	jzc F22B110	// unsigned compare
	ldc 8,B0	// I4 += 2
// jumped away
// 						  }
// result
	or NULL,ONES,A0 ; ldx (I4)-2,A1	// -1 -> 'result'
	sub A1,NULL,A1	// 'writeEntry' != (0) -> (0)
	nop
	jzc F22B1	// unsigned compare
	nop
// jumped away
	mv I3,I0	// 'f' -> I0
	ldx (I4)+7,NULL ; ldy (I6)+1,NULL	// I4 += 7
	call _FatOpenEntry
	stx I4,(I6) ; ldy (I4)-7,NULL	// ET4c
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
F22B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldc 8,B0	// 8 -> 0 -> ET58
	ldc -8,B1	// -8 -> 0 -> ET59
	ldx (I4)+2,NULL
F22B110:
	ldc -16,I5
	ldy (I3)+3,NULL ; ldx (I4)+3,NULL
// 						  }
// endPos
	ldx (I3)+1,A0 ; and D1,NULL,D1
	ldx (I3)-1,A1
	stx A0,(I4)+1	// A0 spills to #0
	stx A1,(I4)+7 ; and A1,NULL,A1	// A1 spills to #0
	ldx (I4)+4,NULL	// ...
// currCluster
	ldx (I4)+3,C0	// I4 ==> 10 -> ET6a
	ashl C0,B0,C0 ; mv C0,D0	// ET6a << ET58 -> ET6c
	ashl D,B1,D	// AT102 <- ET59 -> AT103
	or D0,C0,C0	// ET6b or ET6c -> ET6d
	ldc 0,D0
	ldx (I4)*,C0 ; add C0,NULL,D1	// ET6e <<< ET70
	mv C0,A0 ; ashl C0,B0,B0	// ET73 msw AT104
	mv D0,B1 ; ashl A,B1,A
	or A0,B0,B0	// ET74 or ET75 -> ET76
	or D,B,B ; ldx (I4),D0	// ET70 or ET77 -> AT138
// ->pos = (longNameStartPos>=0) ? longNameStartPos : f->pos-32;
	ldy (I4)+1,D1	// unspill D1 from #0
	ldx (I4)+1,A0	// unspill A0 from #0
	ldx (I4)-6,A1	// unspill A1 from #0
	add A,NULL,C ; mv D1,D1	// ET47 -> 'endPos'
	sub D,NULL,D	// ET9f >= (0) -> (0)
	nop
	jge F22B114	// signed compare
	nop
// jumped away
	ldc 32,D0	// 32 -> 3 -> D0
	ldc 0,D1	// 0 -> D1
	sub A,D,D	// ET47 - ET33 -> ET9f
F22B114:
	ldc 58853,A0	// 58853 -> 1 -> ETa0
	stx D0,(I3)+1
	stx D1,(I3)-4
	mv I3,I0	// 1 -> 1 -> ET18
// while (f->pos < endPos);
F22B115:	// (loop lvl 2)
	ldc 36,I5
	ldx (I4)*,NULL ; ldy (I6)+1,NULL	// I4 += 36
	ldc -36,I5
// 						    }

	stx A0,(I4) ; sub NULL,ONES,A0
// ->op->Write(f, &d, 0, 1);
	stx A0,(I6)+1 ; ldy (I3)+2,NULL	// ET18
	and NULL,NULL,A0	// 0 -> 1 -> ET9
	stx A0,(I6)+1	// ET9
	stx I4,(I6) ; ldy (I4)*,NULL	// ETa1
	ldx (I3)-2,I2	// 'f' ==> 2 -> ETa2
	ldx (I2)+4,NULL	// ETa2 += 4
	ldx (I2),A0	// ETa2 ==> ETa3
	mv A0,LR0
	jr
	ldc lo(F22B118),LR0	// (return address)
// jumped away
F22B118:	// (loop lvl 2)
	ldc 0,C2	// update guard bits (cmp)
	ldc 31,A0	// 31 -> 3 -> A0
	ldy (I3)+3,NULL ; ldx (I6)-3,NULL	// I6 += -3
// 						      f->pos += 31;
	ldx (I3)+1,D0 ; and NULL,NULL,A1
	ldx (I3)-1,D1
	add D,A,A	// ET47 + ETa5 -> ETa6
	stx A0,(I3)+1
	stx A1,(I3)-1
	ldx (I3)+1,A0
	ldx (I3)-4,A1
	ldc 0,A2	// update guard bits (cmp)
	sub A,C,D ; mv I3,I0	// ET47 < 'endPos' -> AT108
	ldc 58853,A0
	jcc F22B115	// unsigned compare
	nop
// jumped away
	ldc 4095,C1	// 4095 -> C1
	and D,NULL,D	// 0 -> 3 -> ETf
	j F22B119
	ldc 65528,C0	// 65528 -> 3 -> C0
// jumped away
F22B124:	// (loop lvl 2)
// 						      VoFatWriteClusterRecord(f, oldCluster, 0);
	stx D0,(I6)+1	// D0
	stx D1,(I6)+1	// D1
	stx B0,(I6)+1	// B0
	call _VoFatWriteClusterRecord
	stx B1,(I6)	// B1
// jumped away
	ldx (I4)+5,NULL ; ldy (I6)-4,NULL	// I4 += 5
	ldx (I4),A0 ; ldy (I4)-3,A1	// unspill A0 from #0
	sub A,C,B	// 'currCluster' >= ETa9 -> AT10a
	nop
	jcs F22B120	// unsigned compare
	nop
// jumped away
	ldx (I4)+3,NULL
	ldx (I4),B0 ; ldy (I4)-5,B1	// unspill B0 from #0
F22B119:	// (loop lvl 2)
	mv I3,I0	// 'f' -> I0
	ldx (I6)+1,NULL	// I6 += 1
// 						    }
// oldCluster
// = VoFatReadClusterRecord(f, currCluster);
	stx B0,(I6)+1	// B0
	call _VoFatReadClusterRecord
	stx B1,(I6)	// B1
// jumped away
	ldx (I4)+5,NULL ; ldy (I6)-1,NULL	// I4 += 5
	stx A0,(I4) ; sty A1,(I4)-5	// A0 spills to #0
// 						      if (!currCluster)
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; mv I3,I0	// 'currCluster' != (0) -> (0)
	nop	// 'f' -> I0
	jzc F22B124	// unsigned compare
	nop	// I6 += 1
// jumped away
// 						    FatFlush(f);
	ldx (I4)+2,NULL ; ldy (I6)-1,NULL	// I4 += 2
F22B120:
	call _FatFlush
	mv I3,I0	// 'f' -> I0
// jumped away
// 						    if (writeEntry)
	ldx (I4)-2,A0	// unspill 'writeEntry' from #0
	sub A0,NULL,A0	// 'writeEntry' == (0) -> (0)
	nop
	jzs F22B128	// unsigned compare
	nop
// jumped away
// 						    }
// {
// 						      unlinkEntry = 0;
// 						      goto tryAgain;
	and NULL,NULL,D1 ; ldx (I4)+1,NULL	// 0 -> 'unlinkEntry'
	j F22B21
	sty A0,(I4)-1	// AT139 spills to #1
// jumped away
F22B128:
// 						    return 0;
	j F22B1
	and NULL,NULL,A0	// 0 -> 0 -> ETc
// jumped away
F22B188:
	sty A0,(I4)-1	// AT13a spills to #1
F22B89:
	ldx (I4)+4,NULL ; or NULL,ONES,A0	// I4 += 4
// 					longNameStartPos = -1;
	stx A0,(I4) ; or NULL,ONES,A1	// -1 -> A1
	j F22B43
	sty A1,(I4)-4	// A1 spills to #0
// jumped away
F22B96:
	mv I3,I0	// 'f' -> ET7c
	ldx (I4)+1,NULL ; ldy (I0)+7,NULL	// I4 += 1
// 						}
// {
// 							if (f->extraInfo)
	ldx (I0)+2,NULL ; ldy (I3)+5,NULL	// ...
	stx I0,(I4)+7	// ET7c spills to #0
	ldx (I0),D0 ; ldy (I4)+4,NULL	// ET7c ==> 9 -> ET7d
	sub D0,NULL,D0 ; ldx (I4)-7,A0	// ET7d == (0) -> (0)
	ldc 255,A1
	jzs F22B100	// signed compare
	nop
// jumped away
	ldc 18,A1	// 18 -> 1 -> ET80
	ldx (I3)-5,A0 ; ldy (I4)-5,NULL
// 							}
// len
	sub A0,A1,A0 ; mv D0,I0	// ET7f - ET80 -> 'len'

	add D0,A0,A1	// ET7d + 'len' -> ET82
	mv A1,I2	// ET82 -> AT11e
// (f->extraInfo,longFileName,len);
	call _strncpy
	ldc _longFileName,I1	// I1
// jumped away
	ldc 22,I5
	and NULL,NULL,A0 ; ldy (I4)+1,NULL	// I4 += 1
// 								*p++ = 0;
	stx A0,(I2)+1	// ETc ==> AT11e
// 								f->extraInfo = p;
	ldx (I4)*,I0	// unspill ET7c from #0
	mv I4,I1	// I4 -> [] -> I1
	ldc -23,I5
	stx I2,(I0) ; ldy (I4)*,NULL	// AT11e ==> ET7c
// 								strcpy(p,tempName);
	call _strcpy
	mv I2,I0	// AT11e -> I0
// jumped away
	ldc 255,A1	// 255 -> 1 -> ET8e
	ldc -8,A0	// -8 -> 0 -> ET59
	ldx (I4)+7,NULL ; ldy (I2)+7,NULL	// I4 += 11
	ldx (I4)+4,NULL ; ldy (I2)+6,NULL	// ...
// 								p += 13;
// 								*p++ = de.filename[4]>>8;
	ldx (I4),B0 ; and B1,NULL,B1	// I4 ==> 4 -> ET8b
	ashl B,A0,B ; ldy (I3)+5,NULL	// ATf9 <- ET59 -> ATfa
	stx B0,(I2)+1 ; and B1,NULL,B1	// ET8c ==> AT11e
// 								*p++ = de.filename[4]&0xff;
	ldx (I4)+1,B0	// I4 ==> 4 -> ET8b
	and B0,A1,A1	// ET8b and ET8e -> ET8f
	stx A1,(I2)+1	// ET8f ==> AT11e
// 								*p++ = de.attr>>8;
	ldx (I4),B0	// I4 ==> 5 -> ET5d
	ashl B,A0,A	// ...
	ldc 255,A1	// 255 -> 1 -> ET8e
	stx A0,(I2)+1 ; and NULL,NULL,A0	// ET91 ==> AT11e
// 								*p = 0;
	stx A0,(I2)	// ETc ==> AT11e
// 							f->ungetc_buffer = de.attr&0xff;
	ldx (I4)-7,A0	// I4 ==> 5 -> ET5d
F22B100:
	ldx (I4)-5,NULL ; and A0,A1,A0	// ...
// 							return 0;
	j F22B1
	stx A0,(I3) ; and NULL,NULL,A0	// ET93 ==> 'f'
// jumped away
F22B87:
	ldc _longFileName,I1	// I1
	mv A0,I2 ; add D0,NULL,A1	// I4 += -4
// 					}
// {
// 						if (((!FileNameCompare(name,longFileName,searchingForDirectory))
// 						|| (!FileNameCompare(name,tempName,searchingForDirectory))))
	call _FileNameCompare
	add D0,NULL,C0	// unspill AT12f from #0
// jumped away
	sub A0,NULL,A0	// ET65 == (0) -> (0)
	ldc 27,I5
	jzs F22B90	// signed compare
	nop
// jumped away
	ldx (I4)-4,NULL ; add A1,NULL,C0	// I4 += -4
	ldx (I4)*,A0	// unspill AT12f from #0
	mv I4,I1	// I4 -> [] -> I1
	mv A0,I2	// AT12f -> I2
	ldc -23,I5
	call _FileNameCompare
	ldx (I4)*,NULL	// I4 += -23
// jumped away
	sub A0,NULL,A0	// ET66 != (0) -> (0)
	nop
	jzc F22B89	// signed compare
	nop
// jumped away
F22B90:
	ldc -8,B0	// -8 -> 0 -> ET59
	ldc 21,I5
	ldx (I4)+5,NULL ; and C1,NULL,C1	// I4 += 5
// 						}
// {
// 							name += searchingForDirectory+1;
	stx D0,(I4) ; sty D1,(I4)-7	// D0 spills to #0
	ldy (I4)-2,NULL ; and D1,NULL,D1	// ...
	ldx (I4),A0 ; sub D0,ONES,A1	// 'searchingForDirectory' - (-1) -> ET67
	add A0,A1,A0	// AT12f + ET67 -> AT12f
	ldc 8,A1	// 8 -> 0 -> ET58
	stx A0,(I4)*	// AT12f spills to #0
// 							dirStartCluster = ((u_int32)(((u_int16)(de.firstClusHi)>>8)|((de.firstClusHi)<<8)) << 16) |(((u_int16)(de.firstClusLo)>>8)|((de.firstClusLo)<<8)) ;
	ldc -23,I5
	ldx (I4)+3,A0	// I4 ==> 10 -> ET6a
	ashl A0,A1,A0 ; mv A0,C0	// ET6a << ET58 -> ET6c
	ashl C,B0,C	// ATef <- ET59 -> ATf0
	or C0,A0,C0 ; ldx (I4)*,A0	// ET6b or ET6c -> ET6d
	mv C0,C1 ; add A0,NULL,D0	// ET6e <<< ET70
	ldc 0,C0
	mv C0,A1 ; ashl A0,A1,A0
	ashl D,B0,B	// ATf1 <- ET59 -> ATf2
	or B0,A0,A0	// ET74 or ET75 -> ET76
	or C,A,C	// ET70 or ET77 -> AT133
	stx C0,(I4)+1	// C0 spills to #0
	stx C1,(I4)+7	// C1 spills to #0
// 							goto nextEntry;
	j F22B21
	ldy (I4)-5,D1	// unspill D1 from #0
// jumped away
F22B79:
	ldx (I4)+5,NULL ; and NULL,NULL,C0
	mv I4,I2	// I4 += 7
// 				}
// fn
	call _MegaFatGetByte
	ldx (I4)-7,NULL	// I4 += -7
// jumped away
	mv A0,B0	// A0 -> 'fn'
	ldc _placesdabb98,I0	// 'p'
	ldc 13,A1	// 13 -> 1 -> ET71
// idx
	ldc 63,A0	// 63 -> 1 -> ETae
	and B0,A0,A0	// 'fn' and ETae -> ETaf
	add A0,ONES,A0	// ETaf + (-1) -> ETb0
	muluu A0,A1	// ETb0 * ET71 -> P
	add NULL,P,A	// P -> AT10f

// (*p >= 0 && idx < 150 -1 )
	j F22B136
	add A0,NULL,A1	// AT10f lsw 'idx'
// jumped away
F22B137:	// (loop lvl 2)
	sub A1,A0,A0	// 'idx' >= ETb4 -> AT112
	nop
	jcs F22B134	// unsigned compare
	nop
// jumped away
	ldc 8,B1	// 8 -> 0 -> ET58
	ldy (I4)+7,NULL ; ldx (I0),A0	// I4 += 7
// 				}
// {
// 					longFileName[idx++] =
// 					(MegaFatGetByte(((void*)&de),(*p+1)) << 8) + MegaFatGetByte(((void*)&de),(*p++));
	sub A0,ONES,C0 ; mv I4,I2	// ETb3 - (-1) -> ETb5
	call _MegaFatGetByte
	ldx (I4)-7,NULL	// I4 += -7
// jumped away
	ldy (I4)+7,NULL ; ldx (I0)+1,C0	// I4 += 7
	ashl A0,B1,B1 ; mv I4,I2	// ETb7 << ET58 -> ETb8
	call _MegaFatGetByte
	ldx (I4)-7,NULL	// I4 += -7
// jumped away
	ldc _longFileName,C0	// ETd
	add B1,A0,B1	// ETb8 + ETbd -> ETbe
	sub A1,ONES,A0	// 'idx' - (-1) -> AT122
	add C0,A1,A1	// ETd + 'idx' -> AT119
	mv A1,I2 ; add A0,NULL,A1	// AT119 -> ETc2
	stx B1,(I2)	// ETbe ==> ETc2
F22B136:	// (loop lvl 2)
	ldx (I0),A0	// 'p' ==> ETb3
	sub A0,NULL,A0	// ETb3 >= (0) -> (0)
	ldc 149,A0	// 149 -> 1 -> ETb4
	jge F22B137	// signed compare
	nop
// jumped away
	j F22B134
	nop
// jumped away
F22B75:
// 			}
// {
// 				longNameStartPos = -1;
	or NULL,ONES,A1 ; stx A0,(I4)	// -1 -> A1
	j F22B43
	sty A1,(I4)-4	// A1 spills to #0
// jumped away
F22B69:
	sub D1,NULL,D1	// 'unlinkEntry' != (0) -> (0)
	ldc 65280,A1	// 65280 -> 1 -> ET54
	jzc F22B67	// unsigned compare
	nop
// jumped away
	ldx (I4)+7,NULL ; ldy (I6)+1,NULL	// I4 += 7
	ldx (I4)-4,A0	// I4 ==> ET53
	and A0,A1,A1	// ET53 and ET54 -> ET55
	ldc 58624,A0	// 58624 -> 1 -> ET56
	jzs F22B66	// compare against zero
	nop
// jumped away
	ldx (I4)-3,NULL ; ldy (I6)-1,NULL
	sub A1,A0,A1	// ET55 == ET56 -> ATe6
	nop
	jzc F22B67	// unsigned compare
	nop
// jumped away
	ldx (I4)+3,NULL ; ldy (I6)+1,NULL	// I4 += 3
F22B66:
// 			}
// ->currentFragment.startByteOffset = 0;
	ldx (I4)-7,I0 ; and A,NULL,A	// unspill 'fi' from #0
	ldx (I0)+4,NULL	// 'fi' += 4
	stx A0,(I0)+1
	stx A1,(I0)-1
	mv I3,I0	// 'f' -> I0
// 			  t = FatMakeEntry(f, name);
	ldx (I4)+4,A0	// unspill AT12f from #0
	call _FatMakeEntry
	stx A0,(I6)	// AT12f
// jumped away
// 			  return t;
	j F22B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F22B55:
	ldx (I3),A0 ; ldy (I4)-7,NULL
// 			}
// {
// 			  if (((f)->flags &(1 << 2)))
	and A0,A1,A0	// ET43 and ET3d -> ET44
	nop
	jzs F22B59	// compare against zero
	nop
// jumped away
// 			  }
// {
// 			    if (unlinkEntry)
	sub D1,NULL,D1	// 'unlinkEntry' == (0) -> (0)
	nop
	jzs F22B59	// unsigned compare
	nop
// jumped away
	ldx (I4)+2,NULL	// I4 += 2
// 			    }
// {
// 			      if (writeEntry)
	ldx (I4)-2,A0	// unspill 'writeEntry' from #0
	sub A0,NULL,A0	// 'writeEntry' == (0) -> (0)
	nop
	jzs F22B63	// unsigned compare
	nop
// jumped away
	mv I3,I0 ; and A,NULL,A	// 'f' -> ET3c
// 			      }
// {
// 				unlinkEntry = 0;
// 				f->pos = 0;
	ldx (I0)+3,NULL ; and NULL,NULL,D1	// ET3c += 3
	stx A0,(I0)+1
	ldc 65531,A0	// 65531 -> 1 -> ET50
	stx A1,(I0)-1
// 				f->flags &= ~((1 << 2));
	ldx (I3),A1	// 'f' ==> ET43
	and A1,A0,A0	// ET43 and ET50 -> ET51
// 				goto nextEntry;
	j F22B21
	stx A0,(I3)	// ET51 ==> 'f'
// jumped away
F22B63:
// 			      }
// else {
// 				return -2;
	j F22B1
	ldc -2,A0	// -2 -> 0 -> ET52
// jumped away
F22B59:
// 			  return -2;
	j F22B1
	ldc -2,A0	// -2 -> 0 -> ET52
// jumped away
F22B51:
// 			  }
// {
// 			    return SysError("Disk full");
	call _SysError
	stx A0,(I6)	// ET4a
// jumped away
	j F22B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F22B44:
// 			}
// {
// 				return SysError("End of dir");
	call _SysError
	stx A0,(I6)	// ET45
// jumped away
	j F22B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F22B34:
	ldx (I4)-3,NULL ; ldy (I6)+1,NULL	// I4 += -3
// 		}
// else {
// 			if (dirStartCluster == 0)
	ldx (I4)+1,A0	// unspill A0 from #0
	ldx (I4)+5,A1	// unspill A1 from #0
	ldc 0,A2	// update guard bits (cmp)
	sub A,NULL,A ; mv I3,I1	// AT133 != (0) -> (0)
	ldc 32,B1
	jzc F22B38	// unsigned compare
	nop
// jumped away
	mv I3,I1	// 'f' -> ET3c
// 			}
// {
// 				dirStartCluster = di->rootStart;
	ldy (I4)-6,I0	// unspill 'di' from #0
	ldx (I0)+7,NULL	// ET2f += 10
	ldx (I0)+3,NULL	// ...
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	stx A0,(I4)+1	// A0 spills to #0
	stx A1,(I4)+5	// A1 spills to #0
// 			fi->startCluster = dirStartCluster;
F22B38:
	ldx (I4)-6,I2 ; ldy (I1)+3,NULL	// unspill 'fi' from #0
	mv I2,I0	// 'fi' -> ET3f
	ldy (I0)+6,NULL ; ldx (I4)+1,A0	// ET3f += 6
	ldx (I4)+2,A1	// unspill A1 from #0
	stx A0,(I0)+1
	stx A1,(I0)-1 ; and A,NULL,A
// 			f->pos = 0;
	stx A0,(I1)+1 ; and NULL,NULL,B0
	stx A1,(I1)+7
// 			f->fileSize = 65536*32;
	ldx (I1)+1,NULL	// ...
	stx B0,(I1)+1
	stx B1,(I1)-1
// 			fi->currentFragment = FatGetFragmentFromFAT(f, fi->startCluster, 0);
	stx A0,(I6)+1	// A0
	stx A1,(I6)+1	// A1
	ldx (I0)+1,A0
	ldx (I0)-1,A1
	mv I3,I0	// 'f' -> I0
	stx A0,(I6)+1	// A0
	stx A1,(I6)+1	// A1
	call _FatGetFragmentFromFAT
	stx I2,(I6)+1	// 'fi'
// jumped away
	j F22B43
	ldx (I6)-5,NULL	// I6 += -5
// jumped away
F22B147:
// 		return -2;
	j F22B1
	ldc -2,A0	// -2 -> 0 -> ET52
// jumped away
F22B10:
// 	}
// {
// 		searchingForDirectory = 0;
// 		goto readEntry;
	j F22B12
	ldx (I4)+5,NULL ; and NULL,NULL,D0
// jumped away
F22B4:
// return -1;
	j F22B1
	ldx (I4)+5,NULL ; or NULL,ONES,A0
// jumped away

//_____________________________________________________________
//
	.sect code,FatFindFirst	// 41 words
	.export _FatFindFirst
_FatFindFirst:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty I2,(I6)
	ldc 18,A1	// 18 -> 1 -> ET0
	ldx (I4)-4,NULL	// I4 += -4
// 	if (len>18)
	ldx (I4)+4,A0	// unspill 'len' from #-4
	sub A1,A0,A1	// ET0 <= 'len' -> ATb
	nop
	jcs F23B4	// unsigned compare
	nop
// jumped away
	ldx (I4)-3,NULL ; ldy (I0)+7,NULL	// I4 += -3
// 	}
// {
// 		f->extraInfo = result;
	ldy (I0)+2,NULL ; ldx (I4)+3,A1	// ...
	stx A1,(I0)-4	// 'result' ==> 'f'
// 		f->ungetc_buffer = len;
	stx A0,(I0)-5	// 'len' ==> 'f'
F23B5:
	ldc sf_7,A0	// ET7
	ldy (I6)+1,NULL ; ldx (I4)-2,NULL	// I4 += -2
// 	if (0 == FatFindFile(f,0,name,"s"))
	stx A0,(I6)+1	// ET7
	ldx (I4)+2,A0	// unspill 'name' from #0
	stx A0,(I6)+1 ; and A,NULL,A	// 'name'
	stx A0,(I6)+1	// A0
	call _FatFindFile
	stx A1,(I6)	// A1
// jumped away
	sub NULL,A0,A0 ; ldx (I6)-4,NULL	// I6 += -4
	nop
	jzc F23B7	// signed compare
	and NULL,NULL,A0	// 0 -> 0 -> ET6
// jumped away
// 	}
// {
// 		return 0;
F23B1:
	ldy (I6),I2 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F23B7:
// 	}
// else {
// 		return -1;
	j F23B1
	or NULL,ONES,A0	// -1 -> 0 -> ETa
// jumped away
F23B4:
	mv I0,I2 ; and NULL,NULL,A0	// 'f' -> ET2
// 	}
// else {
// 		f->extraInfo = 0;
	ldx (I2)+7,NULL	// ET2 += 9
	ldx (I2)+2,NULL	// ...
	j F23B5
	stx A0,(I2)	// ET5 ==> ET2
// jumped away

//_____________________________________________________________
//
	.sect code,FatFindNext	// 41 words
	.export _FatFindNext
_FatFindNext:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty I2,(I6)
	ldc 18,A1	// 18 -> 1 -> ET0
	ldx (I4)-3,NULL	// I4 += -3
// 	if (len>18)
	ldx (I4)+3,A0	// unspill 'len' from #-3
	sub A1,A0,A1	// ET0 <= 'len' -> ATc
	nop
	jcs F24B4	// unsigned compare
	nop
// jumped away
	ldx (I4)-2,NULL ; ldy (I0)+7,NULL	// I4 += -2
// 	}
// {
// 		f->extraInfo = result;
	ldy (I0)+2,NULL ; ldx (I4)+2,A1	// ...
	stx A1,(I0)-4	// 'result' ==> 'f'
// 		f->ungetc_buffer = len;
	stx A0,(I0)-5	// 'len' ==> 'f'
F24B5:
	ldc n_8,A0	// ET7
	ldx (I6)+1,NULL	// I6 += 1
// 	if (0 == FatFindFile(f,0,"","N"))
	stx A0,(I6)+1	// ET7
	ldc String_9,A0	// ET8
	stx A0,(I6)+1 ; and A,NULL,A	// ET8
	stx A0,(I6)+1	// A0
	call _FatFindFile
	stx A1,(I6)	// A1
// jumped away
	sub NULL,A0,A0 ; ldx (I6)-4,NULL	// I6 += -4
	nop
	jzc F24B7	// signed compare
	and NULL,NULL,A0	// 0 -> 0 -> ET6
// jumped away
// 	}
// {
// 		return 0;
F24B1:
	ldy (I6),I2 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F24B7:
// 	}
// else {
// 		return -1;
	j F24B1
	or NULL,ONES,A0	// -1 -> 0 -> ETb
// jumped away
F24B4:
	mv I0,I2 ; and NULL,NULL,A0	// 'f' -> ET2
// 	}
// else {
// 		f->extraInfo = 0;
	ldx (I2)+7,NULL	// ET2 += 9
	ldx (I2)+2,NULL	// ...
	j F24B5
	stx A0,(I2)	// ET5 ==> ET2
// jumped away

//_____________________________________________________________
//
	.sect code,VoFatOpenFile	// 144 words
	.export _VoFatOpenFile
_VoFatOpenFile:
	ldc 3,A0	// 3 -> A0
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+5,I4
	stx A1,(I6) ; sty B0,(I6)+1
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sty I3,(I6)
	mv I0,I2 ; and NULL,NULL,A1	// I0 -> 'f'
	ldx (I4)+1,NULL	// I4 += 1
	mv I4,I0	// I4 -> [] -> I0
// di
// fi
// append
// update
// (modeCopy, mode, 3);
	ldx (I4)-4,NULL	// I4 += -4
	ldx (I4)+7,I3	// unspill 'mode' from #-3
	call _strncpy
	mv I3,I1	// 'mode' -> I1
// jumped away
//   modeCopy[3] = '\0';
	and NULL,NULL,A0 ; mv I3,I0	// 0 -> 0 -> ET9
	stx A0,(I4)-4 ; sub NULL,ONES,B0
//   update = strchr(mode, '+') ? 1 : 0;
	call _strchr
	ldc 43,A0	// 43 -> A0
// jumped away
	mv I0,A0	// I0 -> ET12
	sub A0,NULL,A0	// ET12 != (0) -> (0)
	ldc 114,A0
	jzc F25B5	// signed compare
	nop	// 114 -> 0 -> ET14
// jumped away
	ldc 0,B0	// 0 -> 'update'
//   if ((mode[0] != 'r' || update) && !(f->dev->flags &(1 << 6)))
F25B5:
	ldx (I3),B1	// 'mode' ==> ET13
	sub B1,A0,B1	// ET13 != ET14 -> AT28
	nop
	jzc F25B9	// signed compare
	nop
// jumped away
	sub B0,NULL,B0	// 'update' != (0) -> (0)
	ldc 97,A0	// 97 -> 0 -> ET1a
	jzc F25B9	// signed compare
	nop
// jumped away
F25B8:
	ldx (I4)+1,NULL	// I4 += 1
//   if (modeCopy[0] == 'a')
	ldx (I4),B1	// I4 ==> ET19
	sub B1,A0,B1	// ET19 != ET1a -> AT2b
	ldc 114,A0	// 114 -> 0 -> ET14
	jzc F25B33	// signed compare
	and D,NULL,D ; mv I4,B1
// jumped away
	stx A0,(I4) ; sub NULL,ONES,A1	// I4 += 1
//   }
// {
//     append = 1;
//     modeCopy[0] = 'r';
	and D,NULL,D ; mv I4,B1	// 0 -> 3 -> ET1b
F25B33:
	ldc 119,C0	// 119 -> 0 -> ET25
	ldx (I4)-3,NULL	// I4 += -1
	j F25B13
	ldx (I4)+2,C1	// unspill 'name' from #-2
// jumped away
F25B15:	// (loop lvl 2)
//   if (append)
	sub A1,NULL,A1	// 'append' == (0) -> (0)
	nop
	jzs F25B25	// signed compare
	nop
// jumped away
	ldx (I4)+1,NULL ; and NULL,NULL,A1	// I4 += 1
// 	}
// {
//     modeCopy[0] = 'w';
	stx C0,(I4)-1
//     append = 0;
//     goto tryagain;
F25B13:	// (loop lvl 2)
	mv I2,I0	// 'f' -> I0
	ldx (I6)+1,NULL	// I6 += 1
//   if ((errorCode = FatFindFile(f, 0, name, modeCopy)) == 0)
	stx B1,(I6)+1	// ETb
	stx C1,(I6)+1	// 'name'
	stx D0,(I6)+1	// D0
	call _FatFindFile
	stx D1,(I6)	// D1
// jumped away
	ldx (I6)-4,NULL ; sub A0,NULL,A0	// I6 += -4
	nop
	jzc F25B15	// signed compare
	nop
// jumped away
	ldc 85,A0	// 85 -> 0 -> ET1e
	ldx (I4)+1,NULL	// I4 += 1
//   }
// {
//     if (modeCopy[0]=='U')
	ldx (I4)-1,B1	// I4 ==> ET1d
	sub B1,A0,B1	// ET1d != ET1e -> AT2e
	nop
	jzc F25B18	// signed compare
	nop
// jumped away
// 		}
// {
// 		  return 0;
	j F25B1
	and NULL,NULL,A0	// 0 -> 0 -> ET9
// jumped away
F25B25:
// 	if (mode[0]=='r'||mode[0]=='U')
	ldc 114,B0	// 114 -> 0 -> ET14
	ldx (I3),A1	// 'mode' ==> ET13
	sub A1,B0,B0	// ET13 == ET14 -> AT37
	ldc 85,B0	// 85 -> 0 -> ET1e
	jzs F25B1	// signed compare
	nop
// jumped away
	sub A1,B0,A1	// ET13 != ET1e -> AT3a
	ldc 119,A1
	jzc F25B27	// signed compare
	nop
// jumped away
F25B1:
	ldy (I6),I3 ; ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
// 	if (mode[0]=='w')
	ldc 119,A1	// 119 -> 0 -> ET25
F25B27:
	ldx (I3),A0 ; ldy (I6)+1,NULL	// 'mode' ==> ET13
	sub A0,A1,A1	// ET13 != ET25 -> AT39
	ldc cannotcre_10,A0	// ET26
	jzc F25B30	// signed compare
	nop	// I6 += 1
// jumped away
// 	}
// {
// 		return SysError("Cannot create file");
	call _SysError
	stx A0,(I6)	// ET26
// jumped away
	j F25B1
	ldx (I6)-1,NULL	// I6 += -1
// jumped away
F25B30:
// 	return 0;
	j F25B1
	ldx (I6)-1,NULL ; and NULL,NULL,A0
// jumped away
F25B18:
	mv I2,I0 ; and C,NULL,C	// 'f' -> ET1f
//     f->pos = 0;
	ldx (I0)+3,NULL ; sub A1,NULL,A1	// ET1f += 3
	stx C0,(I0)+1
	stx C1,(I0)-1
//     if (append)
	jzs F25B20	// signed compare
	ldc 114,A0
// jumped away
	mv I2,I1	// 'f' -> ET21
//     }
// {
//       f->pos = f->fileSize;
	ldx (I1)+7,NULL	// ET21 += 12
	ldx (I1)+5,NULL	// ...
	ldx (I1)+1,A0
	ldx (I1)-1,A1
	stx A0,(I0)+1
	ldc 114,A0	// 114 -> 0 -> ET14
	stx A1,(I0)-1
//     if (mode[0]=='r' && !update)
F25B20:
	ldx (I3),A1	// 'mode' ==> ET13
	sub A1,A0,A1	// ET13 != ET14 -> AT33
	ldc 51,A0	// 51 -> 1 -> ET23
	jzc F25B22	// signed compare
	sub B0,NULL,B0	// 'update' != (0) -> (0)
// jumped away
	nop
	jzc F25B22	// signed compare
	nop
// jumped away
// 		}
// {
// 		f->flags =(1 << 1) |(1 << 5) |(1 << 4) |(1 << 0);
// 			return 0;
	j F25B1
	stx A0,(I2) ; and NULL,NULL,A0	// ET23 ==> 'f'
// jumped away
F25B22:
//     f->flags =(1 << 1) |(1 << 5) |(1 << 6) |(1 << 4) |(1 << 0);
	ldc 115,A0	// 115 -> 1 -> ET24
// 		return 0;
	j F25B1
	stx A0,(I2) ; and NULL,NULL,A0	// ET24 ==> 'f'
// jumped away
F25B9:
	ldc 64,B1	// 64 -> 1 -> ET16
	ldx (I2)+6,NULL	// 'f' += 6
	ldx (I2)-6,I0	// 'f' ==> 6 -> ET2
	ldx (I0),A0	// ET2 ==> ET15
	and A0,B1,A0	// ET15 and ET16 -> ET17
	sub A0,NULL,A0	// ET17 != (0) -> (0)
	ldc 97,A0
	jzc F25B8	// unsigned compare
	nop
// jumped away
// 	}
// {
// 	  return -2;
	j F25B1
	ldc -2,A0	// -2 -> 0 -> ET18
// jumped away

//_____________________________________________________________
//
	.sect code,IdentifyFat	// 97 words
	.export _IdentifyFat
_IdentifyFat:
	ldx (I6)+1,NULL	// I6 += 1
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+1,I4
	stx A1,(I6) ; sty B0,(I6)+1
	mv I0,B0	// I0 -> 'f'
	stx B1,(I6) ; sty C0,(I6)+1
	stx C1,(I6) ; sty I1,(I6)+1
	stx I2,(I6) ; sub B0,NULL,B0
// ((f) && (((f)->flags &(1 << 1))) && ((void*)f != &FatFileSystem))
	nop
	jzs F26B4	// signed compare
	nop	// 'f' == (0) -> (0)
// jumped away
	mv B0,I0	// 'f' -> AT30
	ldc 2,A0	// 2 -> 1 -> ET1
	ldx (I0),A1	// AT30 ==> ET0
	and A1,A0,A0	// ET0 and ET1 -> ET2
	ldc _FatFileSystem,A0	// ET3
	jzs F26B4	// compare against zero
	nop
// jumped away
	sub B0,A0,A1	// 'f' == ET3 -> AT29
	ldc 6,A1	// 6 -> 1 -> ET4
	jzs F26B4	// signed compare
	nop
// jumped away
// 	}
// {
// 		if (f->dev->fs == &FatFileSystem)
	add B0,A1,A0	// 'f' + ET4 -> AT2f
	mv A0,I0	// AT2f -> ET5
	ldc _FatFileSystem,A0	// ET3
	ldx (I0),I0	// ET5 ==> 6 -> ET6
	ldx (I0)+7,NULL	// ET6 += 9
	ldx (I0)+2,NULL	// ...
	ldx (I0),B1	// ET6 ==> ET9
	sub B1,A0,A0	// ET9 != ET3 -> AT27
	ldc 15,A0	// 15 -> 1 -> ETa
	jzc F26B4	// signed compare
	nop
// jumped away
// 		}
// fi
// (fi->startCluster == lfnStartCluster)
	ldc _lfnStartCluster,I0	// ETf
	add B0,A0,A0	// 'f' + ETa -> ETb
	mv A0,I2	// ETb -> 'fi'
	ldy (I2)+6,NULL ; ldx (I0)+1,A0/*V*/	// 'fi' += 6
	ldx (I2)+1,C0
	ldx (I2)-7,C1
	ldc 0,C2	// update guard bits (cmp)
	ldx (I0)-1,A1/*V*/
	ldc 0,A2	// update guard bits (cmp)
	sub C,A,A	// ETe == 'lfnStartCluster' -> AT2b
	ldc 256,A0	// 256 -> 1 -> ET11
	jzs F26B9	// unsigned compare
	nop
// jumped away
	ldx (I6)+1,NULL	// I6 += 1
// 			}
// buf
	call _malloc
	stx A0,(I6)	// ET11
// jumped away
	ldx (I6)-1,NULL ; sub A0,NULL,A1	// I6 += -1
// result
// (buf)
	ldc file_11,A0	// 'result'
	jzs F26B1	// signed compare
	nop
// jumped away
	mv I2,I0 ; sub NULL,ONES,A0	// 1 -> 1 -> ET14
	ldx (I6)+1,NULL ; ldy (I0)+7,NULL	// I6 += 1
// 				}
// {
// 					f->dev->BlockRead(f->dev,fi->directoryEntrySector,1,buf);
	stx A1,(I6)+1 ; ldy (I0)+1,NULL	// 'buf'
	stx A0,(I6)+1	// ET14
	ldc 6,A0	// 6 -> 1 -> ET4
	add B0,A0,A0 ; ldx (I0)+1,C0	// ...
	ldx (I0)-1,C1
	mv A0,I0	// AT31 -> ET5
	stx C0,(I6)+1	// C0
	stx C1,(I6)	// C1
	ldx (I0),I1	// ET5 ==> 6 -> ET19
	mv I1,I0	// ET19 -> I0
	ldx (I1)+7,NULL	// ET19 += 7
	ldx (I1),A0	// ET19 ==> ET1a
	mv A0,LR0
	jr
	ldc lo(F26B15),LR0	// (return address)
// jumped away
F26B15:
	ldc _seaf000,A0	// ET1c
	ldc 4,B0	// 4 -> 0 -> ET21
	ldx (I6)-3,NULL ; ldy (I2)+7,NULL	// I6 += 1
// 					result = FatNameFromDirEntry(&buf[(fi->directoryEntryNumber)*16], s);
	stx A0,(I6)+1 ; ldy (I2)+3,NULL	// ET1c
	ldx (I2),A0	// 'fi' ==> 10 -> ET1f
	ashl A0,B0,A0	// ET1f << ET21 -> ET22
	add A1,A0,A0	// 'buf' + ET22 -> ET23
	call _FatNameFromDirEntry
	stx A0,(I6)	// ET23
// jumped away
	ldx (I6)-1,NULL	// I6 += 1
// 					free(buf);
	call _free
	stx A1,(I6)	// 'buf'
// jumped away
	ldx (I6)-1,NULL	// I6 += -1
F26B1:
	ldx (I6)-1,I2
	ldy (I6),I1 ; ldx (I6)-1,C1
	ldy (I6),C0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F26B9:
// 			}
// {
// 				return longFileName;
	j F26B1
	ldc _longFileName,A0	// ET10
// jumped away
F26B4:
// 	return "FAT";
	j F26B1
	ldc fat_12,A0	// ET25
// jumped away

//_____________________________________________________________
//
	.sect data_x,vofatconst_x	// 121 words
	.export _FatFileSystem
_FatFileSystem:
	.word 115, _IdentifyFat, _FatCreate, 0, 0, _FatFileOps
	.export _FatFileOps
_FatFileOps:
	.word _VoFatOpenFile, _VoFatCloseFile, _CommonErrorResultFunction, _VoFatReadFile, _VoFatWriteFile
sectorove_1:
	.word "Sector Overwrite"

	.zero 1
diskfull_2:
	.word "Disk Full"

	.zero 1
read_3:
	.word "Read"

	.zero 1
rootfull_4:
	.word "Root full"

	.zero 1
endofdir_5:
	.word "End of dir"

	.zero 1
diskfull_6:
	.word "Disk full"

	.zero 1
_placesdabb98:
	.word 1, 3, 5, 7, 9, 14, 16, 18
	.word 20, 22, 24, 28, 30, -1
sf_7:
	.word "s"

	.zero 1
n_8:
	.word "N"

	.zero 1
String_9:

	.zero 1
cannotcre_10:
	.word "Cannot create file"

	.zero 1
file_11:
	.word "FILE"

	.zero 1
fat_12:
	.word "FAT"

	.zero 1

//_____________________________________________________________
//
	.sect data_x,vofatbss_x	// 165 words
	.export _longFileName
_longFileName:
	.bss 150
	.export _lfnStartCluster
_lfnStartCluster:
	.bss 2
_seaf000:
	.bss 13

	.end
