
//_____________________________________________________________
//
	.sect code,GpioReadInputPin	// 30 words
	.export _GpioReadInputPin
_GpioReadInputPin:
	ldx (I6)+1,NULL	// I6 += 1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A1,(I6) ; sty B0,(I6)+1
	ldc -4,A1	// -4 -> 0 -> ET2
	stx B1,(I6) ; add C0,NULL,B0	// I4 += 1
	sty I0,(I6) ; and B1,NULL,B1
// gpioport
	ashl B,A1,B ; ldy (I4)+1,NULL	// AT14 <- ET2 -> AT15
	ldc _vo_gpio_perips,A1	// ET0
	add A1,B0,A1	// ET0 + ET3 -> AT18
	mv A1,I0	// AT18 -> ET4
	ldx (I0),A1	// ET4 ==> ET5
	mv A1,I0	// ET5 -> ET6
	ldc 15,A1	// 15 -> 1 -> ETe
	sty I0,(I4)-1 ; ldx (I0)+2,NULL
// (gpioport->idata & (1 << (pin & 0xf))) ? 1 : 0;
	ldy (I0),B0 ; and C0,A1,A0	// ET6 ==> 2 -> ETc
	sub NULL,ONES,A1	// 1 -> 0 -> ETd
	ashl A1,A0,A0	// ETd << ETf -> ET10
	and B0,A0,A1	// ETc and ET10 -> ET12
	sub NULL,ONES,A0	// 1 -> AT9
	sub A1,NULL,A1	// ET12 != (0) -> (0)
	nop
	jzc F0B1	// unsigned compare
	nop
// jumped away
	and NULL,NULL,A0	// 0 -> AT9
F0B1:
	ldy (I6),I0 ; ldx (I6)-1,B1
	ldy (I6),B0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	jr
	ldx (I6)-2,NULL
// jumped away

//_____________________________________________________________
//
	.sect code,GpioReadPinDelay	// 80 words
	.export _GpioReadPinDelay
_GpioReadPinDelay:
	ldc -4,A0	// -4 -> 0 -> ET2
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+5,I4
	stx A1,(I6) ; sty D0,(I6)+1
	stx D1,(I6) ; sty I0,(I6)
	add B,NULL,D ; ldy (I4)+4,NULL	// B -> 'microSeconds'
	mv C0,B0	// 'pin' msw AT20
	ldc 0,B1
// gpioport
	ashl B,A0,A	// AT20 <- ET2 -> AT21
	ldc _vo_gpio_perips,A1	// ET0
	add A1,A0,A1	// ET0 + ET3 -> AT2b
	mv A1,I0	// AT2b -> ET4
	ldx (I0),A1	// ET4 ==> ET5
// ();
	call _Disable
	sty A1,(I4)-4
// jumped away
	ldc 64560,A1	// 64560 -> 1 -> ET8
	ldx (I4)+4,NULL ; add A1,A0,A0	// I4 += 4
// 	modeSave =(*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4)));
	mv A0,I0 ; sub NULL,ONES,B1	// ET9 -> ETa
	ldc 15,A0	// 15 -> 1 -> ETe
	ldy (I0),A1/*V*/ ; and C0,A0,A0	// ETa ==> 'modeSave'
// 	ddrSave = gpioport->ddr;
	ldy (I4)-4,I0 ; ashl B1,A0,A0	// I4 ==> 'gpioport'
	ldy (I0),B0/*V*/ ; sub C1,NULL,C1	// 'gpioport' ==> 'ddrSave'
// 	mask = (1 << (pin & 0xf));
// 	if (waitAlways || (modeSave & mask) || (ddrSave & mask))
	nop
	jzc F1B4	// unsigned compare
	and A1,A0,B1	// 'modeSave' and 'mask' -> ET12
// jumped away
	nop
	jzc F1B4	// compare against zero
	and B0,A0,B1	// 'ddrSave' and 'mask' -> ET13
// jumped away
	nop
	jzc F1B4	// compare against zero
	nop
// jumped away
F1B5:
	ldx (I4)+4,NULL	// I4 += 4
// 	result = (gpioport->idata & mask) ? 1 : 0;
	ldy (I4),I0	// I4 ==> 'gpioport'
	ldx (I0)+2,NULL	// ET1c += 2
	ldy (I0),B1/*V*/	// ET1c ==> 2 -> ET1d
	and B1,A0,B1	// ET1d and 'mask' -> ET1e
	sub NULL,ONES,A0	// 1 -> 'result'
	sub B1,NULL,B1	// ET1e != (0) -> (0)
	ldc -4,B1
	jzc F1B10	// unsigned compare
	and C1,NULL,C1
// jumped away
	ldc 0,A0	// 0 -> 'result'
	mv A0,C1
F1B10:
// (*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4))) = modeSave;
	ashl C,B1,C	// AT28 <- ET2 -> AT29
	ldc 64560,B1	// 64560 -> 1 -> ET8
	add B1,C0,B1	// ET8 + ET3 -> ET9
	mv B1,I0	// ET9 -> ETa
	sty A1,(I0)/*V*/	// 'modeSave' ==> ETa
// 	gpioport->ddr = ddrSave;
	ldy (I4)-4,I0	// I4 ==> 'gpioport'
// 	Enable();
	call _Enable
	sty B0,(I0)/*V*/	// 'ddrSave' ==> 'gpioport'
// jumped away
	ldy (I6),I0 ; ldx (I6)-1,D1
	ldy (I6),D0 ; ldx (I6)-1,A1
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
F1B4:
	ldx (I4)+2,NULL ; ldy (I6)+1,NULL	// I4 += 2
	stx D0,(I4) ; sty D1,(I4)-1	// D0 spills to #0
	stx A1,(I4)+3 ; add C0,NULL,D0	// AT2c spills to #1
// 	}
// {
// 		gpioport->ddr &= ~mask;
	ldy (I4)-2,I0 ; xor A0,ONES,B1	// 'mask' xor (-1) -> ET14
	ldy (I0),C1/*V*/ ; and D1,NULL,D1	// 'gpioport' ==> ET15
	and C1,B1,C1	// ET15 and ET14 -> ET16
	sty C1,(I0)/*V*/	// ET16 ==> 'gpioport'
// (*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4))) &= ~mask;
	ldc -4,C1	// -4 -> 0 -> ET2
	ashl D,C1,D	// AT23 <- ET2 -> AT24
	ldc 64560,C1	// 64560 -> 1 -> ET8
	add C1,D0,C1 ; ldx (I4),D0	// ET8 + ET3 -> ET9
	mv C1,I0	// ET9 -> ETa
	ldy (I0),C1/*V*/ ; stx D0,(I6)+1	// ETa ==> ET17
	and C1,B1,B1	// ET17 and ET14 -> ET18
	sty B1,(I0)/*V*/	// ET18 ==> ETa
// 		DelayMicroSec(microSeconds);
	ldy (I4)-1,D1	// unspill D1 from #0
	stx D1,(I6)+1	// D1
	call _DelayMicroSec
	ldx (I4)-1,A1	// unspill AT2c from #1
// jumped away
	j F1B5
	ldx (I6)-2,NULL	// I6 += -2
// jumped away

//_____________________________________________________________
//
	.sect code,GpioSetPin	// 48 words
	.export _GpioSetPin
_GpioSetPin:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -4,A0	// -4 -> 0 -> ET2
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; and B1,NULL,B1
	add C0,NULL,B0 ; ldy (I4)+1,NULL	// 'pin' msw AT18
// gpioport
	ashl B,A0,A	// AT18 <- ET2 -> AT19
	ldc _vo_gpio_perips,A1	// ET0
	add A1,A0,A1	// ET0 + ET3 -> AT1b
	mv A1,I0 ; sub NULL,ONES,B0	// AT1b -> ET4
	ldx (I0),A1	// ET4 ==> ET5
	sty A1,(I4)-1
// mask
	ldc 15,A1	// 15 -> 1 -> ET9
	and C0,A1,A1	// 'pin' and ET9 -> ETa
// ();
	call _Disable
	ashl B0,A1,C0	// ET8 << ETa -> 'mask'
// jumped away
	ldx (I4)+1,NULL ; xor C0,ONES,B0	// I4 += 1
// 	gpioport->ddr |= mask;
	ldy (I4)-1,I0	// I4 ==> 'gpioport'
	ldy (I0),A1/*V*/	// 'gpioport' ==> ETc
	or A1,C0,A1	// ETc or 'mask' -> ETd
	sty A1,(I0)/*V*/	// ETd ==> 'gpioport'
// (*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4))) &= ~mask;
	ldc 64560,A1	// 64560 -> 1 -> ETf
	add A1,A0,A0	// ETf + ET3 -> ET10
	mv A0,I0	// ET10 -> ET11
	ldy (I0),A0/*V*/	// ET11 ==> ET12
	and A0,B0,A0	// ET12 and ETe -> ET13
// 	Enable();
	call _Enable
	sty A0,(I0)/*V*/	// ET13 ==> ET11
// jumped away
// 	if (state)
	sub C1,NULL,C1 ; ldx (I4)+1,NULL	// 'state' != (0) -> (0)
	nop
	jzc F2B5	// unsigned compare
	nop
// jumped away
	ldy (I4)-1,I0
// 	}
// else {
// 		gpioport->clear_mask = mask;
	ldx (I0)+7,NULL	// ET17 += 7
F2B1:
	sty C0,(I0)/*V*/ ; ldx (I6)-1,I0	// 'mask' ==> ET17
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away
	ldx (I4)+1,NULL	// I4 += 1
F2B5:
// 	}
// {
// 		gpioport->set_mask = mask;
	ldy (I4)-1,I0	// I4 ==> 'gpioport'
	j F2B1
	ldx (I0)+6,NULL	// ET15 += 6
// jumped away

//_____________________________________________________________
//
	.sect code,GpioSetAsInput	// 38 words
	.export _GpioSetAsInput
_GpioSetAsInput:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -4,A1	// -4 -> 0 -> ET2
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; and B1,NULL,B1
	add C0,NULL,B0 ; ldy (I4)+1,NULL	// 'pin' msw AT15
// gpioport
	ashl B,A1,B	// AT15 <- ET2 -> AT16
	mv B0,A1 ; sub NULL,ONES,A0	// AT16 lsw ET3
	ldc _vo_gpio_perips,B0	// ET0
	add B0,A1,B0	// ET0 + ET3 -> AT17
	mv B0,I0	// AT17 -> ET4
	ldx (I0),B0	// ET4 ==> ET5
	sty B0,(I4)
// mask
	ldc 15,B0	// 15 -> 1 -> ET9
	and C0,B0,B0	// 'pin' and ET9 -> ETa
// ();
	call _Disable
	ashl A0,B0,A0	// ET8 << ETa -> 'mask'
// jumped away
// 	gpioport->ddr &= ~mask;
	xor A0,ONES,A0 ; ldy (I4)-1,I0	// 'mask' xor (-1) -> ETd
	ldy (I0),B0/*V*/	// 'gpioport' ==> ETe
	and B0,A0,B0	// ETe and ETd -> ETf
	sty B0,(I0)/*V*/	// ETf ==> 'gpioport'
// (*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4))) &= ~mask;
	ldc 64560,B0	// 64560 -> 1 -> ET10
	add B0,A1,A1	// ET10 + ET3 -> ET11
	mv A1,I0	// ET11 -> ET12
	ldy (I0),A1/*V*/	// ET12 ==> ET13
	and A1,A0,A0	// ET13 and ETd -> ET14
// 	Enable();
	call _Enable
	sty A0,(I0)/*V*/	// ET14 ==> ET12
// jumped away
	ldx (I6)-1,I0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect code,GpioSetAsPeripheral	// 35 words
	.export _GpioSetAsPeripheral
_GpioSetAsPeripheral:
	stx LR0,(I6)+1
	stx I6,(I6) ; sty I4,(I6)
	ldx (I6)+2,I4
	stx A0,(I6) ; sty A1,(I6)+1
	ldc -4,A1	// -4 -> 0 -> ET2
	stx B0,(I6) ; sty B1,(I6)+1
	stx I0,(I6) ; and B1,NULL,B1
	add C0,NULL,B0 ; ldy (I4)+1,NULL	// 'pin' msw AT12
// gpioport
	ashl B,A1,B	// AT12 <- ET2 -> AT13
	mv B0,A1	// AT13 lsw ET3
	ldc _vo_gpio_perips,B0	// ET0
	add B0,A1,B0	// ET0 + ET3 -> AT14
	mv B0,I0	// AT14 -> ET4
	ldx (I0),B0	// ET4 ==> ET5
	sty B0,(I4)-1
// mask
	ldc 15,B0	// 15 -> 1 -> ET9
	and C0,B0,A0	// 'pin' and ET9 -> ETa
	sub NULL,ONES,B0	// 1 -> 0 -> ET8
// ();
	call _Disable
	ashl B0,A0,A0	// ET8 << ETa -> 'mask'
// jumped away
// (*(__y volatile u_int16 *)(u_int16)(0xFC30 +(pin>>4))) |= mask;
	ldc 64560,B0	// 64560 -> 1 -> ETd
	add B0,A1,A1	// ETd + ET3 -> ETe
	mv A1,I0	// ETe -> ETf
	ldy (I0),A1/*V*/	// ETf ==> ET10
	or A1,A0,A0	// ET10 or 'mask' -> ET11
// 	Enable();
	call _Enable
	sty A0,(I0)/*V*/	// ET11 ==> ETf
// jumped away
	ldx (I6)-1,I0
	ldy (I6),B1 ; ldx (I6)-1,B0
	ldy (I6),A1 ; ldx (I6)-1,A0
	ldx (I4),I6 ; ldy (I4),I4
	ldx (I6)-1,NULL	// I6 += -1
	ldx (I6)-1,LR0
	jr
	nop
// jumped away

//_____________________________________________________________
//
	.sect data_x,vogpioconst_x	// 3 words
	.export _vo_gpio_perips
_vo_gpio_perips:
	.word 64672, 64704, 64736

	.end
